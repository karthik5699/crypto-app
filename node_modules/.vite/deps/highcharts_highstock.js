import {
  __commonJS
} from "./chunk-YBOLLQGG.js";

// node_modules/highcharts/highstock.js
var require_highstock = __commonJS({
  "node_modules/highcharts/highstock.js"(exports, module) {
    (function(S, L) {
      "object" === typeof module && module.exports ? (L["default"] = L, module.exports = S.document ? L(S) : L) : "function" === typeof define && define.amd ? define("highcharts/highstock", function() {
        return L(S);
      }) : (S.Highcharts && S.Highcharts.error(16, true), S.Highcharts = L(S));
    })("undefined" !== typeof window ? window : exports, function(S) {
      function L(a2, A, J, K) {
        a2.hasOwnProperty(A) || (a2[A] = K.apply(null, J), "function" === typeof CustomEvent && S.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: A, module: a2[A] } })));
      }
      var a = {};
      L(a, "Core/Globals.js", [], function() {
        var a2;
        (function(a3) {
          a3.SVG_NS = "http://www.w3.org/2000/svg";
          a3.product = "Highcharts";
          a3.version = "11.1.0";
          a3.win = "undefined" !== typeof S ? S : {};
          a3.doc = a3.win.document;
          a3.svg = a3.doc && a3.doc.createElementNS && !!a3.doc.createElementNS(a3.SVG_NS, "svg").createSVGRect;
          a3.userAgent = a3.win.navigator && a3.win.navigator.userAgent || "";
          a3.isChrome = -1 !== a3.userAgent.indexOf("Chrome");
          a3.isFirefox = -1 !== a3.userAgent.indexOf("Firefox");
          a3.isMS = /(edge|msie|trident)/i.test(a3.userAgent) && !a3.win.opera;
          a3.isSafari = !a3.isChrome && -1 !== a3.userAgent.indexOf("Safari");
          a3.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a3.userAgent);
          a3.isWebKit = -1 !== a3.userAgent.indexOf("AppleWebKit");
          a3.deg2rad = 2 * Math.PI / 360;
          a3.hasBidiBug = a3.isFirefox && 4 > parseInt(a3.userAgent.split("Firefox/")[1], 10);
          a3.hasTouch = !!a3.win.TouchEvent;
          a3.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
          a3.noop = function() {
          };
          a3.supportsPassiveEvents = function() {
            let u = false;
            if (!a3.isMS) {
              const A = Object.defineProperty({}, "passive", { get: function() {
                u = true;
              } });
              a3.win.addEventListener && a3.win.removeEventListener && (a3.win.addEventListener("testPassive", a3.noop, A), a3.win.removeEventListener("testPassive", a3.noop, A));
            }
            return u;
          }();
          a3.charts = [];
          a3.dateFormats = {};
          a3.seriesTypes = {};
          a3.symbolSizes = {};
          a3.chartCount = 0;
        })(a2 || (a2 = {}));
        "";
        return a2;
      });
      L(a, "Core/Utilities.js", [a["Core/Globals.js"]], function(a2) {
        function u(c, b2, d2, z) {
          const k = b2 ? "Highcharts error" : "Highcharts warning";
          32 === c && (c = `${k}: Deprecated member`);
          const w = t(c);
          let r2 = w ? `${k} #${c}: www.highcharts.com/errors/${c}/` : c.toString();
          if ("undefined" !== typeof z) {
            let c2 = "";
            w && (r2 += "?");
            M(z, function(b3, k2) {
              c2 += `
 - ${k2}: ${b3}`;
              w && (r2 += encodeURI(k2) + "=" + encodeURI(b3));
            });
            r2 += c2;
          }
          f(a2, "displayError", { chart: d2, code: c, message: r2, params: z }, function() {
            if (b2)
              throw Error(r2);
            l.console && -1 === u.messages.indexOf(r2) && console.warn(r2);
          });
          u.messages.push(r2);
        }
        function J(c, b2) {
          return parseInt(c, b2 || 10);
        }
        function K(c) {
          return "string" === typeof c;
        }
        function G(c) {
          c = Object.prototype.toString.call(c);
          return "[object Array]" === c || "[object Array Iterator]" === c;
        }
        function D(c, b2) {
          return !!c && "object" === typeof c && (!b2 || !G(c));
        }
        function E(c) {
          return D(c) && "number" === typeof c.nodeType;
        }
        function B(c) {
          const b2 = c && c.constructor;
          return !(!D(c, true) || E(c) || !b2 || !b2.name || "Object" === b2.name);
        }
        function t(c) {
          return "number" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;
        }
        function q(c) {
          return "undefined" !== typeof c && null !== c;
        }
        function m(c, b2, d2) {
          const k = K(b2) && !q(d2);
          let F;
          const w = (b3, d3) => {
            q(b3) ? c.setAttribute(d3, b3) : k ? (F = c.getAttribute(d3)) || "class" !== d3 || (F = c.getAttribute(d3 + "Name")) : c.removeAttribute(d3);
          };
          K(b2) ? w(d2, b2) : M(b2, w);
          return F;
        }
        function p(c) {
          return G(c) ? c : [c];
        }
        function n(c, b2) {
          let k;
          c || (c = {});
          for (k in b2)
            c[k] = b2[k];
          return c;
        }
        function h() {
          const c = arguments, b2 = c.length;
          for (let k = 0; k < b2; k++) {
            const b3 = c[k];
            if ("undefined" !== typeof b3 && null !== b3)
              return b3;
          }
        }
        function g(c, b2) {
          a2.isMS && !a2.svg && b2 && q(b2.opacity) && (b2.filter = `alpha(opacity=${100 * b2.opacity})`);
          n(c.style, b2);
        }
        function e(c) {
          return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));
        }
        function x(c, b2) {
          return 1e14 < c ? c : parseFloat(c.toPrecision(b2 || 14));
        }
        function I(c, b2, d2) {
          let k;
          if ("width" === b2)
            return b2 = Math.min(c.offsetWidth, c.scrollWidth), d2 = c.getBoundingClientRect && c.getBoundingClientRect().width, d2 < b2 && d2 >= b2 - 1 && (b2 = Math.floor(d2)), Math.max(0, b2 - (I(c, "padding-left", true) || 0) - (I(c, "padding-right", true) || 0));
          if ("height" === b2)
            return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (I(c, "padding-top", true) || 0) - (I(c, "padding-bottom", true) || 0));
          if (c = l.getComputedStyle(c, void 0))
            k = c.getPropertyValue(b2), h(d2, "opacity" !== b2) && (k = J(k));
          return k;
        }
        function M(c, b2, d2) {
          for (const k in c)
            Object.hasOwnProperty.call(
              c,
              k
            ) && b2.call(d2 || c[k], c[k], k, c);
        }
        function C(c, b2, d2) {
          function k(b3, k2) {
            const d3 = c.removeEventListener;
            d3 && d3.call(c, b3, k2, false);
          }
          function F(d3) {
            let F2, w2;
            c.nodeName && (b2 ? (F2 = {}, F2[b2] = true) : F2 = d3, M(F2, function(c2, b3) {
              if (d3[b3])
                for (w2 = d3[b3].length; w2--; )
                  k(b3, d3[b3][w2].fn);
            }));
          }
          var w = "function" === typeof c && c.prototype || c;
          if (Object.hasOwnProperty.call(w, "hcEvents")) {
            const c2 = w.hcEvents;
            b2 ? (w = c2[b2] || [], d2 ? (c2[b2] = w.filter(function(c3) {
              return d2 !== c3.fn;
            }), k(b2, d2)) : (F(c2), c2[b2] = [])) : (F(c2), delete w.hcEvents);
          }
        }
        function f(c, b2, d2, f2) {
          d2 = d2 || {};
          if (r.createEvent && (c.dispatchEvent || c.fireEvent && c !== a2)) {
            var k = r.createEvent("Events");
            k.initEvent(b2, true, true);
            d2 = n(k, d2);
            c.dispatchEvent ? c.dispatchEvent(d2) : c.fireEvent(b2, d2);
          } else if (c.hcEvents) {
            d2.target || n(d2, { preventDefault: function() {
              d2.defaultPrevented = true;
            }, target: c, type: b2 });
            k = [];
            let F = c, w = false;
            for (; F.hcEvents; )
              Object.hasOwnProperty.call(F, "hcEvents") && F.hcEvents[b2] && (k.length && (w = true), k.unshift.apply(k, F.hcEvents[b2])), F = Object.getPrototypeOf(F);
            w && k.sort((c2, b3) => c2.order - b3.order);
            k.forEach((b3) => {
              false === b3.fn.call(c, d2) && d2.preventDefault();
            });
          }
          f2 && !d2.defaultPrevented && f2.call(c, d2);
        }
        const { charts: y, doc: r, win: l } = a2;
        (u || (u = {})).messages = [];
        Math.easeInOutSine = function(c) {
          return -0.5 * (Math.cos(Math.PI * c) - 1);
        };
        var v = Array.prototype.find ? function(c, b2) {
          return c.find(b2);
        } : function(c, b2) {
          let k;
          const d2 = c.length;
          for (k = 0; k < d2; k++)
            if (b2(c[k], k))
              return c[k];
        };
        M({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(c, b2) {
          a2[b2] = function(k) {
            u(32, false, void 0, { [`Highcharts.${b2}`]: `use Array.${c}` });
            return Array.prototype[c].apply(k, [].slice.call(
              arguments,
              1
            ));
          };
        });
        let d;
        const b = function() {
          const c = Math.random().toString(36).substring(2, 9) + "-";
          let b2 = 0;
          return function() {
            return "highcharts-" + (d ? "" : c) + b2++;
          };
        }();
        l.jQuery && (l.jQuery.fn.highcharts = function() {
          const c = [].slice.call(arguments);
          if (this[0])
            return c[0] ? (new a2[K(c[0]) ? c.shift() : "Chart"](this[0], c[0], c[1]), this) : y[m(this[0], "data-highcharts-chart")];
        });
        v = { addEvent: function(c, b2, d2, f2 = {}) {
          var k = "function" === typeof c && c.prototype || c;
          Object.hasOwnProperty.call(k, "hcEvents") || (k.hcEvents = {});
          k = k.hcEvents;
          a2.Point && c instanceof a2.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = true);
          const w = c.addEventListener;
          w && w.call(c, b2, d2, a2.supportsPassiveEvents ? { passive: void 0 === f2.passive ? -1 !== b2.indexOf("touch") : f2.passive, capture: false } : false);
          k[b2] || (k[b2] = []);
          k[b2].push({ fn: d2, order: "number" === typeof f2.order ? f2.order : Infinity });
          k[b2].sort((c2, b3) => c2.order - b3.order);
          return function() {
            C(c, b2, d2);
          };
        }, arrayMax: function(c) {
          let b2 = c.length, d2 = c[0];
          for (; b2--; )
            c[b2] > d2 && (d2 = c[b2]);
          return d2;
        }, arrayMin: function(c) {
          let b2 = c.length, d2 = c[0];
          for (; b2--; )
            c[b2] < d2 && (d2 = c[b2]);
          return d2;
        }, attr: m, clamp: function(c, b2, d2) {
          return c > b2 ? c < d2 ? c : d2 : b2;
        }, clearTimeout: function(c) {
          q(c) && clearTimeout(c);
        }, correctFloat: x, createElement: function(c, b2, d2, f2, F) {
          c = r.createElement(c);
          b2 && n(c, b2);
          F && g(c, { padding: "0", border: "none", margin: "0" });
          d2 && g(c, d2);
          f2 && f2.appendChild(c);
          return c;
        }, css: g, defined: q, destroyObjectProperties: function(c, b2) {
          M(c, function(k, d2) {
            k && k !== b2 && k.destroy && k.destroy();
            delete c[d2];
          });
        }, diffObjects: function(c, b2, d2, f2) {
          function k(c2, b3, F, w2) {
            const H = d2 ? b3 : c2;
            M(c2, function(d3, l2) {
              if (!w2 && f2 && -1 < f2.indexOf(l2) && b3[l2]) {
                d3 = p(d3);
                F[l2] = [];
                for (let c3 = 0; c3 < Math.max(d3.length, b3[l2].length); c3++)
                  b3[l2][c3] && (void 0 === d3[c3] ? F[l2][c3] = b3[l2][c3] : (F[l2][c3] = {}, k(d3[c3], b3[l2][c3], F[l2][c3], w2 + 1)));
              } else if (D(d3, true) && !d3.nodeType)
                F[l2] = G(d3) ? [] : {}, k(d3, b3[l2] || {}, F[l2], w2 + 1), 0 !== Object.keys(F[l2]).length || "colorAxis" === l2 && 0 === w2 || delete F[l2];
              else if (c2[l2] !== b3[l2] || l2 in c2 && !(l2 in b3))
                F[l2] = H[l2];
            });
          }
          const w = {};
          k(c, b2, w, 0);
          return w;
        }, discardElement: function(c) {
          c && c.parentElement && c.parentElement.removeChild(c);
        }, erase: function(c, b2) {
          let k = c.length;
          for (; k--; )
            if (c[k] === b2) {
              c.splice(k, 1);
              break;
            }
        }, error: u, extend: n, extendClass: function(c, b2) {
          const k = function() {
          };
          k.prototype = new c();
          n(k.prototype, b2);
          return k;
        }, find: v, fireEvent: f, getClosestDistance: function(c, b2) {
          const k = !b2;
          let d2, F, f2, l2;
          c.forEach((c2) => {
            if (1 < c2.length)
              for (l2 = F = c2.length - 1; 0 < l2; l2--)
                f2 = c2[l2] - c2[l2 - 1], 0 > f2 && !k ? (null === b2 || void 0 === b2 ? void 0 : b2(), b2 = void 0) : f2 && ("undefined" === typeof d2 || f2 < d2) && (d2 = f2);
          });
          return d2;
        }, getMagnitude: e, getNestedProperty: function(c, b2) {
          for (c = c.split("."); c.length && q(b2); ) {
            const d2 = c.shift();
            if ("undefined" === typeof d2 || "__proto__" === d2)
              return;
            if ("this" === d2) {
              let c2;
              D(b2) && (c2 = b2["@this"]);
              return null !== c2 && void 0 !== c2 ? c2 : b2;
            }
            b2 = b2[d2];
            if (!q(b2) || "function" === typeof b2 || "number" === typeof b2.nodeType || b2 === l)
              return;
          }
          return b2;
        }, getStyle: I, inArray: function(c, b2, d2) {
          u(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
          return b2.indexOf(c, d2);
        }, insertItem: function(c, b2) {
          const d2 = c.options.index, k = b2.length;
          let F;
          for (F = c.options.isInternal ? k : 0; F < k + 1; F++)
            if (!b2[F] || t(d2) && d2 < h(b2[F].options.index, b2[F]._i) || b2[F].options.isInternal) {
              b2.splice(
                F,
                0,
                c
              );
              break;
            }
          return F;
        }, isArray: G, isClass: B, isDOMElement: E, isFunction: function(b2) {
          return "function" === typeof b2;
        }, isNumber: t, isObject: D, isString: K, keys: function(b2) {
          u(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
          return Object.keys(b2);
        }, merge: function() {
          let b2, d2 = arguments, f2 = {};
          const l2 = function(b3, c) {
            "object" !== typeof b3 && (b3 = {});
            M(c, function(d3, k) {
              "__proto__" !== k && "constructor" !== k && (!D(d3, true) || B(d3) || E(d3) ? b3[k] = c[k] : b3[k] = l2(b3[k] || {}, d3));
            });
            return b3;
          };
          true === d2[0] && (f2 = d2[1], d2 = Array.prototype.slice.call(d2, 2));
          const F = d2.length;
          for (b2 = 0; b2 < F; b2++)
            f2 = l2(f2, d2[b2]);
          return f2;
        }, normalizeTickInterval: function(b2, d2, f2, l2, F) {
          let c = b2;
          f2 = h(f2, e(b2));
          const k = b2 / f2;
          d2 || (d2 = F ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === l2 && (1 === f2 ? d2 = d2.filter(function(b3) {
            return 0 === b3 % 1;
          }) : 0.1 >= f2 && (d2 = [1 / f2])));
          for (l2 = 0; l2 < d2.length && !(c = d2[l2], F && c * f2 >= b2 || !F && k <= (d2[l2] + (d2[l2 + 1] || d2[l2])) / 2); l2++)
            ;
          return c = x(c * f2, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: M, offset: function(b2) {
          const c = r.documentElement;
          b2 = b2.parentElement || b2.parentNode ? b2.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return { top: b2.top + (l.pageYOffset || c.scrollTop) - (c.clientTop || 0), left: b2.left + (l.pageXOffset || c.scrollLeft) - (c.clientLeft || 0), width: b2.width, height: b2.height };
        }, pad: function(b2, d2, f2) {
          return Array((d2 || 2) + 1 - String(b2).replace("-", "").length).join(f2 || "0") + b2;
        }, pick: h, pInt: J, pushUnique: function(b2, d2) {
          return 0 > b2.indexOf(d2) && !!b2.push(d2);
        }, relativeLength: function(b2, d2, f2) {
          return /%$/.test(b2) ? d2 * parseFloat(b2) / 100 + (f2 || 0) : parseFloat(b2);
        }, removeEvent: C, splat: p, stableSort: function(b2, d2) {
          const c = b2.length;
          let k, F;
          for (F = 0; F < c; F++)
            b2[F].safeI = F;
          b2.sort(function(b3, c2) {
            k = d2(b3, c2);
            return 0 === k ? b3.safeI - c2.safeI : k;
          });
          for (F = 0; F < c; F++)
            delete b2[F].safeI;
        }, syncTimeout: function(b2, d2, f2) {
          if (0 < d2)
            return setTimeout(b2, d2, f2);
          b2.call(0, f2);
          return -1;
        }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: b, useSerialIds: function(b2) {
          return d = h(b2, d);
        }, wrap: function(b2, d2, f2) {
          const c = b2[d2];
          b2[d2] = function() {
            const b3 = arguments, d3 = this;
            return f2.apply(this, [function() {
              return c.apply(
                d3,
                arguments.length ? arguments : b3
              );
            }].concat([].slice.call(arguments)));
          };
        } };
        "";
        return v;
      });
      L(a, "Core/Chart/ChartDefaults.js", [], function() {
        return {
          alignThresholds: false,
          panning: { enabled: false, type: "x" },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } },
          reflow: true,
          type: "line",
          zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        };
      });
      L(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { isNumber: u, merge: K, pInt: G } = A;
        class D {
          static parse(a3) {
            return a3 ? new D(a3) : D.None;
          }
          constructor(u2) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = u2;
            const B = a2.Color;
            if (B && B !== D)
              return new B(u2);
            this.init(u2);
          }
          init(a3) {
            let B;
            let t;
            if ("object" === typeof a3 && "undefined" !== typeof a3.stops)
              this.stops = a3.stops.map((m2) => new D(m2[1]));
            else if ("string" === typeof a3) {
              this.input = a3 = D.names[a3.toLowerCase()] || a3;
              if ("#" === a3.charAt(0)) {
                var q = a3.length;
                var m = parseInt(a3.substr(1), 16);
                7 === q ? B = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === q && (B = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1]);
              }
              if (!B)
                for (m = D.parsers.length; m-- && !B; )
                  t = D.parsers[m], (q = t.regex.exec(a3)) && (B = t.parse(q));
            }
            B && (this.rgba = B);
          }
          get(a3) {
            const B = this.input, t = this.rgba;
            if ("object" === typeof B && "undefined" !== typeof this.stops) {
              const q = K(B);
              q.stops = [].slice.call(q.stops);
              this.stops.forEach((m, p) => {
                q.stops[p] = [
                  q.stops[p][0],
                  m.get(a3)
                ];
              });
              return q;
            }
            return t && u(t[0]) ? "rgb" === a3 || !a3 && 1 === t[3] ? "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" : "a" === a3 ? `${t[3]}` : "rgba(" + t.join(",") + ")" : B;
          }
          brighten(a3) {
            const B = this.rgba;
            if (this.stops)
              this.stops.forEach(function(t) {
                t.brighten(a3);
              });
            else if (u(a3) && 0 !== a3)
              for (let t = 0; 3 > t; t++)
                B[t] += G(255 * a3), 0 > B[t] && (B[t] = 0), 255 < B[t] && (B[t] = 255);
            return this;
          }
          setOpacity(a3) {
            this.rgba[3] = a3;
            return this;
          }
          tweenTo(a3, B) {
            const t = this.rgba, q = a3.rgba;
            if (!u(t[0]) || !u(q[0]))
              return a3.input || "none";
            a3 = 1 !== q[3] || 1 !== t[3];
            return (a3 ? "rgba(" : "rgb(") + Math.round(q[0] + (t[0] - q[0]) * (1 - B)) + "," + Math.round(q[1] + (t[1] - q[1]) * (1 - B)) + "," + Math.round(q[2] + (t[2] - q[2]) * (1 - B)) + (a3 ? "," + (q[3] + (t[3] - q[3]) * (1 - B)) : "") + ")";
          }
        }
        D.names = { white: "#ffffff", black: "#000000" };
        D.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(a3) {
          return [G(a3[1]), G(a3[2]), G(a3[3]), parseFloat(a3[4], 10)];
        } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(a3) {
          return [
            G(a3[1]),
            G(a3[2]),
            G(a3[3]),
            1
          ];
        } }];
        D.None = new D("");
        "";
        return D;
      });
      L(a, "Core/Color/Palettes.js", [], function() {
        return { colors: "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(" ") };
      });
      L(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { win: u } = a2, { defined: K, error: G, extend: D, isObject: E, merge: B, objectEach: t, pad: q, pick: m, splat: p, timeUnits: n } = A, h = a2.isSafari && u.Intl && u.Intl.DateTimeFormat.prototype.formatRange, g = a2.isSafari && u.Intl && !u.Intl.DateTimeFormat.prototype.formatRange;
        class e {
          constructor(x) {
            this.options = {};
            this.variableTimezone = this.useUTC = false;
            this.Date = u.Date;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(x);
          }
          get(x, e2) {
            if (this.variableTimezone || this.timezoneOffset) {
              const g2 = e2.getTime(), h2 = g2 - this.getTimezoneOffset(e2);
              e2.setTime(h2);
              x = e2["getUTC" + x]();
              e2.setTime(g2);
              return x;
            }
            return this.useUTC ? e2["getUTC" + x]() : e2["get" + x]();
          }
          set(x, e2, g2) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === x || "Seconds" === x || "Minutes" === x && 0 === this.getTimezoneOffset(e2) % 36e5)
                return e2["setUTC" + x](g2);
              var I = this.getTimezoneOffset(e2);
              I = e2.getTime() - I;
              e2.setTime(I);
              e2["setUTC" + x](g2);
              x = this.getTimezoneOffset(e2);
              I = e2.getTime() + x;
              return e2.setTime(I);
            }
            return this.useUTC || h && "FullYear" === x ? e2["setUTC" + x](g2) : e2["set" + x](g2);
          }
          update(e2 = {}) {
            const x = m(e2.useUTC, true);
            this.options = e2 = B(true, this.options, e2);
            this.Date = e2.Date || u.Date || Date;
            this.timezoneOffset = (this.useUTC = x) && e2.timezoneOffset || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.variableTimezone = x && !(!e2.getTimezoneOffset && !e2.timezone);
          }
          makeTime(e2, h2, n2, q2, f, y) {
            let r, l, v;
            this.useUTC ? (r = this.Date.UTC.apply(0, arguments), l = this.getTimezoneOffset(r), r += l, v = this.getTimezoneOffset(r), l !== v ? r += v - l : l - 36e5 !== this.getTimezoneOffset(r - 36e5) || g || (r -= 36e5)) : r = new this.Date(e2, h2, m(n2, 1), m(q2, 0), m(f, 0), m(y, 0)).getTime();
            return r;
          }
          timezoneOffsetFunction() {
            const e2 = this, g2 = this.options, h2 = g2.getTimezoneOffset, n2 = g2.moment || u.moment;
            if (!this.useUTC)
              return function(f) {
                return 6e4 * new Date(f.toString()).getTimezoneOffset();
              };
            if (g2.timezone) {
              if (n2)
                return function(f) {
                  return 6e4 * -n2.tz(f, g2.timezone).utcOffset();
                };
              G(25);
            }
            return this.useUTC && h2 ? function(f) {
              return 6e4 * h2(f.valueOf());
            } : function() {
              return 6e4 * (e2.timezoneOffset || 0);
            };
          }
          dateFormat(e2, g2, h2) {
            if (!K(g2) || isNaN(g2))
              return a2.defaultOptions.lang && a2.defaultOptions.lang.invalidDate || "";
            e2 = m(e2, "%Y-%m-%d %H:%M:%S");
            const x = this;
            var f = new this.Date(g2);
            const y = this.get("Hours", f), r = this.get("Day", f), l = this.get("Date", f), v = this.get("Month", f), d = this.get("FullYear", f), b = a2.defaultOptions.lang, c = b && b.weekdays, k = b && b.shortWeekdays;
            f = D({ a: k ? k[r] : c[r].substr(0, 3), A: c[r], d: q(l), e: q(l, 2, " "), w: r, b: b.shortMonths[v], B: b.months[v], m: q(v + 1), o: v + 1, y: d.toString().substr(2, 2), Y: d, H: q(y), k: y, I: q(y % 12 || 12), l: y % 12 || 12, M: q(this.get("Minutes", f)), p: 12 > y ? "AM" : "PM", P: 12 > y ? "am" : "pm", S: q(f.getSeconds()), L: q(Math.floor(g2 % 1e3), 3) }, a2.dateFormats);
            t(f, function(b2, c2) {
              for (; -1 !== e2.indexOf("%" + c2); )
                e2 = e2.replace("%" + c2, "function" === typeof b2 ? b2.call(x, g2) : b2);
            });
            return h2 ? e2.substr(0, 1).toUpperCase() + e2.substr(1) : e2;
          }
          resolveDTLFormat(e2) {
            return E(e2, true) ? e2 : (e2 = p(e2), {
              main: e2[0],
              from: e2[1],
              to: e2[2]
            });
          }
          getTimeTicks(e2, g2, h2, q2) {
            const f = this, y = [], r = {};
            var l = new f.Date(g2);
            const v = e2.unitRange, d = e2.count || 1;
            let b;
            q2 = m(q2, 1);
            if (K(g2)) {
              f.set("Milliseconds", l, v >= n.second ? 0 : d * Math.floor(f.get("Milliseconds", l) / d));
              v >= n.second && f.set("Seconds", l, v >= n.minute ? 0 : d * Math.floor(f.get("Seconds", l) / d));
              v >= n.minute && f.set("Minutes", l, v >= n.hour ? 0 : d * Math.floor(f.get("Minutes", l) / d));
              v >= n.hour && f.set("Hours", l, v >= n.day ? 0 : d * Math.floor(f.get("Hours", l) / d));
              v >= n.day && f.set("Date", l, v >= n.month ? 1 : Math.max(1, d * Math.floor(f.get(
                "Date",
                l
              ) / d)));
              if (v >= n.month) {
                f.set("Month", l, v >= n.year ? 0 : d * Math.floor(f.get("Month", l) / d));
                var c = f.get("FullYear", l);
              }
              v >= n.year && f.set("FullYear", l, c - c % d);
              v === n.week && (c = f.get("Day", l), f.set("Date", l, f.get("Date", l) - c + q2 + (c < q2 ? -7 : 0)));
              c = f.get("FullYear", l);
              q2 = f.get("Month", l);
              const k = f.get("Date", l), w = f.get("Hours", l);
              g2 = l.getTime();
              !f.variableTimezone && f.useUTC || !K(h2) || (b = h2 - g2 > 4 * n.month || f.getTimezoneOffset(g2) !== f.getTimezoneOffset(h2));
              g2 = l.getTime();
              for (l = 1; g2 < h2; )
                y.push(g2), g2 = v === n.year ? f.makeTime(c + l * d, 0) : v === n.month ? f.makeTime(c, q2 + l * d) : !b || v !== n.day && v !== n.week ? b && v === n.hour && 1 < d ? f.makeTime(c, q2, k, w + l * d) : g2 + v * d : f.makeTime(c, q2, k + l * d * (v === n.day ? 1 : 7)), l++;
              y.push(g2);
              v <= n.hour && 1e4 > y.length && y.forEach(function(b2) {
                0 === b2 % 18e5 && "000000000" === f.dateFormat("%H%M%S%L", b2) && (r[b2] = "day");
              });
            }
            y.info = D(e2, { higherRanks: r, totalRange: v * d });
            return y;
          }
          getDateFormat(e2, g2, h2, q2) {
            const f = this.dateFormat("%m-%d %H:%M:%S.%L", g2), y = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
            let r, l = "millisecond";
            for (r in n) {
              if (e2 === n.week && +this.dateFormat(
                "%w",
                g2
              ) === h2 && "00:00:00.000" === f.substr(6)) {
                r = "week";
                break;
              }
              if (n[r] > e2) {
                r = l;
                break;
              }
              if (y[r] && f.substr(y[r]) !== "01-01 00:00:00.000".substr(y[r]))
                break;
              "week" !== r && (l = r);
            }
            return this.resolveDTLFormat(q2[r]).main;
          }
        }
        "";
        return e;
      });
      L(a, "Core/Defaults.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palettes.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D) {
        const { isTouchDevice: u, svg: B } = J, { merge: t } = D, q = {
          colors: K.colors,
          symbols: [
            "circle",
            "diamond",
            "square",
            "triangle",
            "triangle-down"
          ],
          lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " },
          global: {},
          time: {
            Date: void 0,
            getTimezoneOffset: void 0,
            timezone: void 0,
            timezoneOffset: 0,
            useUTC: true
          },
          chart: a2,
          title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 },
          subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 },
          caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" },
          plotOptions: {},
          legend: {
            enabled: true,
            align: "center",
            alignColumns: true,
            className: "highcharts-no-tooltip",
            layout: "horizontal",
            itemMarginBottom: 2,
            itemMarginTop: 2,
            labelFormatter: function() {
              return this.name;
            },
            borderColor: "#999999",
            borderRadius: 0,
            navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" },
            itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" },
            itemHoverStyle: { color: "#000000" },
            itemHiddenStyle: { color: "#666666", textDecoration: "line-through" },
            shadow: false,
            itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" },
            squareSymbol: true,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: { style: { fontSize: "0.8em", fontWeight: "bold" } }
          },
          loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } },
          tooltip: {
            enabled: true,
            animation: B,
            borderRadius: 3,
            dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" },
            footerFormat: "",
            headerShape: "callout",
            hideDelay: 500,
            padding: 8,
            shape: "callout",
            shared: false,
            snap: u ? 25 : 10,
            headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">‚óè</span> {series.name}: <b>{point.y}</b><br/>',
            backgroundColor: "#ffffff",
            borderWidth: void 0,
            shadow: true,
            stickOnContact: false,
            style: { color: "#333333", cursor: "default", fontSize: "0.8em" },
            useHTML: false
          },
          credits: {
            enabled: true,
            href: "https://www.highcharts.com?credits",
            position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 },
            style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" },
            text: "Highcharts.com"
          }
        };
        q.chart.styledMode = false;
        "";
        const m = new G(q.time);
        a2 = { defaultOptions: q, defaultTime: m, getOptions: function() {
          return q;
        }, setOptions: function(a3) {
          t(true, q, a3);
          if (a3.time || a3.global)
            J.time ? J.time.update(t(q.global, q.time, a3.global, a3.time)) : J.time = m;
          return q;
        } };
        "";
        return a2;
      });
      L(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { parse: u } = a2, { win: G } = A, { isNumber: D, objectEach: E } = J;
        class B {
          constructor(a3, q, m) {
            this.pos = NaN;
            this.options = q;
            this.elem = a3;
            this.prop = m;
          }
          dSetter() {
            var a3 = this.paths;
            const q = a3 && a3[0];
            a3 = a3 && a3[1];
            const m = this.now || 0;
            let p = [];
            if (1 !== m && q && a3)
              if (q.length === a3.length && 1 > m)
                for (let n = 0; n < a3.length; n++) {
                  const h = q[n], g = a3[n], e = [];
                  for (let x = 0; x < g.length; x++) {
                    const a4 = h[x], n2 = g[x];
                    D(a4) && D(n2) && ("A" !== g[0] || 4 !== x && 5 !== x) ? e[x] = a4 + m * (n2 - a4) : e[x] = n2;
                  }
                  p.push(e);
                }
              else
                p = a3;
            else
              p = this.toD || [];
            this.elem.attr("d", p, void 0, true);
          }
          update() {
            const a3 = this.elem, q = this.prop, m = this.now, p = this.options.step;
            if (this[q + "Setter"])
              this[q + "Setter"]();
            else
              a3.attr ? a3.element && a3.attr(q, m, null, true) : a3.style[q] = m + this.unit;
            p && p.call(a3, m, this);
          }
          run(a3, q, m) {
            const p = this, n = p.options, h = function(e2) {
              return h.stopped ? false : p.step(e2);
            }, g = G.requestAnimationFrame || function(e2) {
              setTimeout(e2, 13);
            }, e = function() {
              for (let e2 = 0; e2 < B.timers.length; e2++)
                B.timers[e2]() || B.timers.splice(e2--, 1);
              B.timers.length && g(e);
            };
            a3 !== q || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = a3, this.end = q, this.unit = m, this.now = this.start, this.pos = 0, h.elem = this.elem, h.prop = this.prop, h() && 1 === B.timers.push(h) && g(e)) : (delete n.curAnim[this.prop], n.complete && 0 === Object.keys(n.curAnim).length && n.complete.call(this.elem));
          }
          step(a3) {
            const q = +/* @__PURE__ */ new Date(), m = this.options, p = this.elem, n = m.complete, h = m.duration, g = m.curAnim;
            let e;
            p.attr && !p.element ? a3 = false : a3 || q >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), e = g[this.prop] = true, E(g, function(g2) {
              true !== g2 && (e = false);
            }), e && n && n.call(p), a3 = false) : (this.pos = m.easing((q - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a3 = true);
            return a3;
          }
          initPath(a3, q, m) {
            function p(f, y) {
              for (; f.length < M; ) {
                var r = f[0];
                const l = y[M - f.length];
                l && "M" === r[0] && (f[0] = "C" === l[0] ? ["C", r[1], r[2], r[1], r[2], r[1], r[2]] : ["L", r[1], r[2]]);
                f.unshift(r);
                e && (r = f.pop(), f.push(f[f.length - 1], r));
              }
            }
            function n(f, y) {
              for (; f.length < M; )
                if (y = f[Math.floor(f.length / x) - 1].slice(), "C" === y[0] && (y[1] = y[5], y[2] = y[6]), e) {
                  const e2 = f[Math.floor(f.length / x)].slice();
                  f.splice(f.length / 2, 0, y, e2);
                } else
                  f.push(y);
            }
            const h = a3.startX, g = a3.endX;
            m = m.slice();
            const e = a3.isArea, x = e ? 2 : 1;
            let I, M, C;
            q = q && q.slice();
            if (!q)
              return [
                m,
                m
              ];
            if (h && g && g.length) {
              for (a3 = 0; a3 < h.length; a3++)
                if (h[a3] === g[0]) {
                  I = a3;
                  break;
                } else if (h[0] === g[g.length - h.length + a3]) {
                  I = a3;
                  C = true;
                  break;
                } else if (h[h.length - 1] === g[g.length - h.length + a3]) {
                  I = h.length - a3;
                  break;
                }
              "undefined" === typeof I && (q = []);
            }
            q.length && D(I) && (M = m.length + I * x, C ? (p(q, m), n(m, q)) : (p(m, q), n(q, m)));
            return [q, m];
          }
          fillSetter() {
            B.prototype.strokeSetter.apply(this, arguments);
          }
          strokeSetter() {
            this.elem.attr(this.prop, u(this.start).tweenTo(u(this.end), this.pos), void 0, true);
          }
        }
        B.timers = [];
        return B;
      });
      L(
        a,
        "Core/Animation/AnimationUtilities.js",
        [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]],
        function(a2, A) {
          function u(a3) {
            return t(a3) ? q({ duration: 500, defer: 0 }, a3) : { duration: a3 ? 500 : 0, defer: 0 };
          }
          function K(n, h) {
            let g = a2.timers.length;
            for (; g--; )
              a2.timers[g].elem !== n || h && h !== a2.timers[g].prop || (a2.timers[g].stopped = true);
          }
          const { defined: G, getStyle: D, isArray: E, isNumber: B, isObject: t, merge: q, objectEach: m, pick: p } = A;
          return { animate: function(n, h, g) {
            let e, x = "", I, p2, C;
            t(g) || (C = arguments, g = { duration: C[2], easing: C[3], complete: C[4] });
            B(g.duration) || (g.duration = 400);
            g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
            g.curAnim = q(h);
            m(h, function(f, y) {
              K(n, y);
              p2 = new a2(n, g, y);
              I = void 0;
              "d" === y && E(h.d) ? (p2.paths = p2.initPath(n, n.pathArray, h.d), p2.toD = h.d, e = 0, I = 1) : n.attr ? e = n.attr(y) : (e = parseFloat(D(n, y)) || 0, "opacity" !== y && (x = "px"));
              I || (I = f);
              "string" === typeof I && I.match("px") && (I = I.replace(/px/g, ""));
              p2.run(e, I, x);
            });
          }, animObject: u, getDeferredAnimation: function(a3, h, g) {
            const e = u(h);
            let x = 0, n = 0;
            (g ? [g] : a3.series).forEach((g2) => {
              g2 = u(g2.options.animation);
              x = h && G(h.defer) ? e.defer : Math.max(x, g2.duration + g2.defer);
              n = Math.min(e.duration, g2.duration);
            });
            a3.renderer.forExport && (x = 0);
            return { defer: Math.max(0, x - n), duration: Math.min(x, n) };
          }, setAnimation: function(a3, h) {
            h.renderer.globalAnimation = p(a3, h.options.chart.animation, true);
          }, stop: K };
        }
      );
      L(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { SVG_NS: u, win: K } = a2, { attr: G, createElement: D, css: E, error: B, isFunction: t, isString: q, objectEach: m, splat: p } = A;
        ({ trustedTypes: A } = K);
        const n = A && t(A.createPolicy) && A.createPolicy("highcharts", { createHTML: (e2) => e2 });
        A = n ? n.createHTML("") : "";
        try {
          var h = !!new DOMParser().parseFromString(A, "text/html");
        } catch (x) {
          h = false;
        }
        const g = h;
        class e {
          static filterUserAttributes(g2) {
            m(g2, (x, h2) => {
              let a3 = true;
              -1 === e.allowedAttributes.indexOf(h2) && (a3 = false);
              -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(h2) && (a3 = q(x) && e.allowedReferences.some((f) => 0 === x.indexOf(f)));
              a3 || (B(33, false, void 0, { "Invalid attribute in config": `${h2}` }), delete g2[h2]);
              q(x) && g2[h2] && (g2[h2] = x.replace(
                /</g,
                "&lt;"
              ));
            });
            return g2;
          }
          static parseStyle(e2) {
            return e2.split(";").reduce((e3, g2) => {
              g2 = g2.split(":").map((f) => f.trim());
              const x = g2.shift();
              x && g2.length && (e3[x.replace(/-([a-z])/g, (f) => f[1].toUpperCase())] = g2.join(":"));
              return e3;
            }, {});
          }
          static setElementHTML(g2, h2) {
            g2.innerHTML = e.emptyHTML;
            h2 && new e(h2).addToDOM(g2);
          }
          constructor(e2) {
            this.nodes = "string" === typeof e2 ? this.parseMarkup(e2) : e2;
          }
          addToDOM(g2) {
            function h2(g3, x) {
              let f;
              p(g3).forEach(function(y) {
                var r = y.tagName;
                const l = y.textContent ? a2.doc.createTextNode(y.textContent) : void 0, v = e.bypassHTMLFiltering;
                let d;
                if (r)
                  if ("#text" === r)
                    d = l;
                  else if (-1 !== e.allowedTags.indexOf(r) || v) {
                    r = a2.doc.createElementNS("svg" === r ? u : x.namespaceURI || u, r);
                    const b = y.attributes || {};
                    m(y, function(c, d2) {
                      "tagName" !== d2 && "attributes" !== d2 && "children" !== d2 && "style" !== d2 && "textContent" !== d2 && (b[d2] = c);
                    });
                    G(r, v ? b : e.filterUserAttributes(b));
                    y.style && E(r, y.style);
                    l && r.appendChild(l);
                    h2(y.children || [], r);
                    d = r;
                  } else
                    B(33, false, void 0, { "Invalid tagName in config": r });
                d && x.appendChild(d);
                f = d;
              });
              return f;
            }
            return h2(this.nodes, g2);
          }
          parseMarkup(h2) {
            const x = [];
            h2 = h2.trim().replace(/ style=(["'])/g, " data-style=$1");
            if (g)
              h2 = new DOMParser().parseFromString(n ? n.createHTML(h2) : h2, "text/html");
            else {
              const e2 = D("div");
              e2.innerHTML = h2;
              h2 = { body: e2 };
            }
            const a3 = (g2, f) => {
              var y = g2.nodeName.toLowerCase();
              const r = { tagName: y };
              "#text" === y && (r.textContent = g2.textContent || "");
              if (y = g2.attributes) {
                const f2 = {};
                [].forEach.call(y, (l) => {
                  "data-style" === l.name ? r.style = e.parseStyle(l.value) : f2[l.name] = l.value;
                });
                r.attributes = f2;
              }
              if (g2.childNodes.length) {
                const f2 = [];
                [].forEach.call(g2.childNodes, (l) => {
                  a3(
                    l,
                    f2
                  );
                });
                f2.length && (r.children = f2);
              }
              f.push(r);
            };
            [].forEach.call(h2.body.childNodes, (e2) => a3(e2, x));
            return x;
          }
        }
        e.allowedAttributes = "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
        e.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
        e.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");
        e.emptyHTML = A;
        e.bypassHTMLFiltering = false;
        "";
        return e;
      });
      L(a, "Core/Templating.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, A) {
        function u(g = "", e, x) {
          const a3 = /\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g, n2 = /\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g, q2 = [], f = /f$/, y = /\.([0-9])/, r = G.lang, l = x && x.time || D, v = x && x.numberFormatter || K, d = (b2 = "") => {
            let c2;
            return "true" === b2 ? true : "false" === b2 ? false : (c2 = Number(b2)).toString() === b2 ? c2 : B(b2, e);
          };
          let b, c, k = 0, w;
          for (; null !== (b = a3.exec(g)); ) {
            const d2 = n2.exec(b[1]);
            d2 && (b = d2, w = true);
            c && c.isBlock || (c = {
              ctx: e,
              expression: b[1],
              find: b[0],
              isBlock: "#" === b[1].charAt(0),
              start: b.index,
              startInner: b.index + b[0].length,
              length: b[0].length
            });
            var z = b[1].split(" ")[0].replace("#", "");
            h[z] && (c.isBlock && z === c.fn && k++, c.fn || (c.fn = z));
            z = "else" === b[1];
            if (c.isBlock && c.fn && (b[1] === `/${c.fn}` || z))
              if (k)
                z || k--;
              else {
                var F = c.startInner;
                F = g.substr(F, b.index - F);
                void 0 === c.body ? (c.body = F, c.startInner = b.index + b[0].length) : c.elseBody = F;
                c.find += F + b[0];
                z || (q2.push(c), c = void 0);
              }
            else
              c.isBlock || q2.push(c);
            if (d2 && (null === c || void 0 === c || !c.isBlock))
              break;
          }
          q2.forEach((b2) => {
            const { body: c2, elseBody: k2, expression: F2, fn: w2 } = b2;
            var H;
            if (w2) {
              var z2 = [b2], x2 = F2.split(" ");
              for (H = h[w2].length; H--; )
                z2.unshift(d(x2[H + 1]));
              H = h[w2].apply(e, z2);
              b2.isBlock && "boolean" === typeof H && (H = u(H ? c2 : k2, e));
            } else
              z2 = F2.split(":"), H = d(z2.shift() || ""), z2.length && "number" === typeof H && (z2 = z2.join(":"), f.test(z2) ? (x2 = parseInt((z2.match(y) || ["", "-1"])[1], 10), null !== H && (H = v(H, x2, r.decimalPoint, -1 < z2.indexOf(",") ? r.thousandsSep : ""))) : H = l.dateFormat(z2, H));
            g = g.replace(b2.find, p(H, ""));
          });
          return w ? u(g, e, x) : g;
        }
        function K(g, e, h2, a3) {
          g = +g || 0;
          e = +e;
          const x = G.lang;
          var m2 = (g.toString().split(".")[1] || "").split("e")[0].length;
          const f = g.toString().split("e"), y = e;
          if (-1 === e)
            e = Math.min(m2, 20);
          else if (!q(e))
            e = 2;
          else if (e && f[1] && 0 > f[1]) {
            var r = e + +f[1];
            0 <= r ? (f[0] = (+f[0]).toExponential(r).split("e")[0], e = r) : (f[0] = f[0].split(".")[0] || 0, g = 20 > e ? (f[0] * Math.pow(10, f[1])).toFixed(e) : 0, f[1] = 0);
          }
          r = (Math.abs(f[1] ? f[0] : g) + Math.pow(10, -Math.max(e, m2) - 1)).toFixed(e);
          m2 = String(n(r));
          const l = 3 < m2.length ? m2.length % 3 : 0;
          h2 = p(h2, x.decimalPoint);
          a3 = p(a3, x.thousandsSep);
          g = (0 > g ? "-" : "") + (l ? m2.substr(0, l) + a3 : "");
          g = 0 > +f[1] && !y ? "0" : g + m2.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + a3);
          e && (g += h2 + r.slice(-e));
          f[1] && 0 !== +g && (g += "e" + f[1]);
          return g;
        }
        const { defaultOptions: G, defaultTime: D } = a2, { extend: E, getNestedProperty: B, isArray: t, isNumber: q, isObject: m, pick: p, pInt: n } = A, h = { add: (g, e) => g + e, divide: (g, e) => 0 !== e ? g / e : "", eq: (g, e) => g == e, each: function(g) {
          const e = arguments[arguments.length - 1];
          return t(g) ? g.map((h2, a3) => u(e.body, E(m(h2) ? h2 : { "@this": h2 }, { "@index": a3, "@first": 0 === a3, "@last": a3 === g.length - 1 }))).join("") : false;
        }, ge: (g, e) => g >= e, gt: (g, e) => g > e, "if": (g) => !!g, le: (g, e) => g <= e, lt: (g, e) => g < e, multiply: (g, e) => g * e, ne: (g, e) => g != e, subtract: (g, e) => g - e, unless: (g) => !g };
        return { dateFormat: function(g, e, h2) {
          return D.dateFormat(g, e, h2);
        }, format: u, helpers: h, numberFormat: K };
      });
      L(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function(a2) {
        const { clamp: u, pick: J, stableSort: K } = a2;
        var G;
        (function(a3) {
          function A(a4, t, q) {
            const m = a4;
            var p = m.reducedLen || t, n = (e2, g2) => (g2.rank || 0) - (e2.rank || 0);
            const h = (e2, g2) => e2.target - g2.target;
            let g, e = true, x = [], I = 0;
            for (g = a4.length; g--; )
              I += a4[g].size;
            if (I > p) {
              K(a4, n);
              for (I = g = 0; I <= p; )
                I += a4[g].size, g++;
              x = a4.splice(g - 1, a4.length);
            }
            K(a4, h);
            for (a4 = a4.map((e2) => ({ size: e2.size, targets: [e2.target], align: J(e2.align, 0.5) })); e; ) {
              for (g = a4.length; g--; )
                p = a4[g], n = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = u(n - p.size * p.align, 0, t - p.size);
              g = a4.length;
              for (e = false; g--; )
                0 < g && a4[g - 1].pos + a4[g - 1].size > a4[g].pos && (a4[g - 1].size += a4[g].size, a4[g - 1].targets = a4[g - 1].targets.concat(a4[g].targets), a4[g - 1].align = 0.5, a4[g - 1].pos + a4[g - 1].size > t && (a4[g - 1].pos = t - a4[g - 1].size), a4.splice(g, 1), e = true);
            }
            m.push.apply(m, x);
            g = 0;
            a4.some((e2) => {
              let a5 = 0;
              return (e2.targets || []).some(() => {
                m[g].pos = e2.pos + a5;
                if ("undefined" !== typeof q && Math.abs(m[g].pos - m[g].target) > q)
                  return m.slice(0, g + 1).forEach((f) => delete f.pos), m.reducedLen = (m.reducedLen || t) - 0.1 * t, m.reducedLen > 0.1 * t && A(m, t, q), true;
                a5 += m[g].size;
                g++;
                return false;
              });
            });
            K(m, h);
            return m;
          }
          a3.distribute = A;
        })(G || (G = {}));
        return G;
      });
      L(a, "Core/Renderer/SVG/SVGElement.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K) {
        const { animate: u, animObject: D, stop: E } = a2, { deg2rad: B, doc: t, svg: q, SVG_NS: m, win: p } = J, { addEvent: n, attr: h, createElement: g, css: e, defined: x, erase: I, extend: M, fireEvent: C, isArray: f, isFunction: y, isObject: r, isString: l, merge: v, objectEach: d, pick: b, pInt: c, syncTimeout: k, uniqueKey: w } = K;
        class z {
          constructor() {
            this.element = void 0;
            this.onEvents = {};
            this.opacity = 1;
            this.renderer = void 0;
            this.SVG_NS = m;
          }
          _defaultGetter(c2) {
            c2 = b(this[c2 + "Value"], this[c2], this.element ? this.element.getAttribute(c2) : null, 0);
            /^[\-0-9\.]+$/.test(c2) && (c2 = parseFloat(c2));
            return c2;
          }
          _defaultSetter(b2, c2, d2) {
            d2.setAttribute(c2, b2);
          }
          add(b2) {
            const c2 = this.renderer, d2 = this.element;
            let k2;
            b2 && (this.parentGroup = b2);
            "undefined" !== typeof this.textStr && "text" === this.element.nodeName && c2.buildText(this);
            this.added = true;
            if (!b2 || b2.handleZ || this.zIndex)
              k2 = this.zIndexSetter();
            k2 || (b2 ? b2.element : c2.box).appendChild(d2);
            if (this.onAdd)
              this.onAdd();
            return this;
          }
          addClass(b2, c2) {
            const d2 = c2 ? "" : this.attr("class") || "";
            b2 = (b2 || "").split(/ /g).reduce(function(b3, c3) {
              -1 === d2.indexOf(c3) && b3.push(c3);
              return b3;
            }, d2 ? [d2] : []).join(" ");
            b2 !== d2 && this.attr("class", b2);
            return this;
          }
          afterSetters() {
            this.doTransform && (this.updateTransform(), this.doTransform = false);
          }
          align(c2, d2, k2) {
            const F = {};
            var f2 = this.renderer, e2 = f2.alignedObjects, H;
            let w2, r2;
            if (c2) {
              if (this.alignOptions = c2, this.alignByTranslate = d2, !k2 || l(k2))
                this.alignTo = H = k2 || "renderer", I(e2, this), e2.push(this), k2 = void 0;
            } else
              c2 = this.alignOptions, d2 = this.alignByTranslate, H = this.alignTo;
            k2 = b(k2, f2[H], "scrollablePlotBox" === H ? f2.plotBox : void 0, f2);
            H = c2.align;
            const z2 = c2.verticalAlign;
            f2 = (k2.x || 0) + (c2.x || 0);
            e2 = (k2.y || 0) + (c2.y || 0);
            "right" === H ? w2 = 1 : "center" === H && (w2 = 2);
            w2 && (f2 += (k2.width - (c2.width || 0)) / w2);
            F[d2 ? "translateX" : "x"] = Math.round(f2);
            "bottom" === z2 ? r2 = 1 : "middle" === z2 && (r2 = 2);
            r2 && (e2 += (k2.height - (c2.height || 0)) / r2);
            F[d2 ? "translateY" : "y"] = Math.round(e2);
            this[this.placed ? "animate" : "attr"](F);
            this.placed = true;
            this.alignAttr = F;
            return this;
          }
          alignSetter(b2) {
            const c2 = { left: "start", center: "middle", right: "end" };
            c2[b2] && (this.alignValue = b2, this.element.setAttribute("text-anchor", c2[b2]));
          }
          animate(c2, f2, l2) {
            const F = D(b(f2, this.renderer.globalAnimation, true));
            f2 = F.defer;
            t.hidden && (F.duration = 0);
            0 !== F.duration ? (l2 && (F.complete = l2), k(() => {
              this.element && u(this, c2, F);
            }, f2)) : (this.attr(c2, void 0, l2 || F.complete), d(c2, function(b2, c3) {
              F.step && F.step.call(this, b2, { prop: c3, pos: 1, elem: this });
            }, this));
            return this;
          }
          applyTextOutline(b2) {
            const c2 = this.element;
            -1 !== b2.indexOf("contrast") && (b2 = b2.replace(/contrast/g, this.renderer.getContrast(c2.style.fill)));
            var d2 = b2.split(" ");
            b2 = d2[d2.length - 1];
            if ((d2 = d2[0]) && "none" !== d2 && J.svg) {
              this.fakeTS = true;
              d2 = d2.replace(/(^[\d\.]+)(.*?)$/g, function(b3, c3, d3) {
                return 2 * Number(c3) + d3;
              });
              this.removeTextOutline();
              const k2 = t.createElementNS(m, "tspan");
              h(k2, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": d2, "stroke-linejoin": "round" });
              b2 = c2.querySelector("textPath") || c2;
              [].forEach.call(b2.childNodes, (b3) => {
                const c3 = b3.cloneNode(true);
                c3.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((b4) => c3.removeAttribute(b4));
                k2.appendChild(c3);
              });
              let F = 0;
              [].forEach.call(b2.querySelectorAll("text tspan"), (b3) => {
                F += Number(b3.getAttribute("dy"));
              });
              d2 = t.createElementNS(m, "tspan");
              d2.textContent = "‚Äã";
              h(d2, { x: Number(c2.getAttribute("x")), dy: -F });
              k2.appendChild(d2);
              b2.insertBefore(k2, b2.firstChild);
            }
          }
          attr(b2, c2, k2, f2) {
            const F = this.element, l2 = z.symbolCustomAttribs;
            let H, e2, w2 = this, r2, v2;
            "string" === typeof b2 && "undefined" !== typeof c2 && (H = b2, b2 = {}, b2[H] = c2);
            "string" === typeof b2 ? w2 = (this[b2 + "Getter"] || this._defaultGetter).call(this, b2, F) : (d(b2, function(c3, d2) {
              r2 = false;
              f2 || E(this, d2);
              this.symbolName && -1 !== l2.indexOf(d2) && (e2 || (this.symbolAttr(b2), e2 = true), r2 = true);
              !this.rotation || "x" !== d2 && "y" !== d2 || (this.doTransform = true);
              r2 || (v2 = this[d2 + "Setter"] || this._defaultSetter, v2.call(this, c3, d2, F));
            }, this), this.afterSetters());
            k2 && k2.call(this);
            return w2;
          }
          clip(b2) {
            return this.attr("clip-path", b2 ? "url(" + this.renderer.url + "#" + b2.id + ")" : "none");
          }
          crisp(b2, c2) {
            c2 = c2 || b2.strokeWidth || 0;
            const d2 = Math.round(c2) % 2 / 2;
            b2.x = Math.floor(b2.x || this.x || 0) + d2;
            b2.y = Math.floor(b2.y || this.y || 0) + d2;
            b2.width = Math.floor((b2.width || this.width || 0) - 2 * d2);
            b2.height = Math.floor((b2.height || this.height || 0) - 2 * d2);
            x(b2.strokeWidth) && (b2.strokeWidth = c2);
            return b2;
          }
          complexColor(b2, c2, k2) {
            const F = this.renderer;
            let l2, e2, H, r2, z2, y2, g2, N, a3, h2, n2 = [], q2;
            C(this.renderer, "complexColor", { args: arguments }, function() {
              b2.radialGradient ? e2 = "radialGradient" : b2.linearGradient && (e2 = "linearGradient");
              if (e2) {
                H = b2[e2];
                z2 = F.gradients;
                y2 = b2.stops;
                a3 = k2.radialReference;
                f(H) && (b2[e2] = H = { x1: H[0], y1: H[1], x2: H[2], y2: H[3], gradientUnits: "userSpaceOnUse" });
                "radialGradient" === e2 && a3 && !x(H.gradientUnits) && (r2 = H, H = v(H, F.getRadialAttr(a3, r2), { gradientUnits: "userSpaceOnUse" }));
                d(H, function(b3, c3) {
                  "id" !== c3 && n2.push(c3, b3);
                });
                d(y2, function(b3) {
                  n2.push(b3);
                });
                n2 = n2.join(",");
                if (z2[n2])
                  h2 = z2[n2].attr("id");
                else {
                  H.id = h2 = w();
                  const b3 = z2[n2] = F.createElement(e2).attr(H).add(F.defs);
                  b3.radAttr = r2;
                  b3.stops = [];
                  y2.forEach(function(c3) {
                    0 === c3[1].indexOf("rgba") ? (l2 = A.parse(c3[1]), g2 = l2.get("rgb"), N = l2.get("a")) : (g2 = c3[1], N = 1);
                    c3 = F.createElement("stop").attr({ offset: c3[0], "stop-color": g2, "stop-opacity": N }).add(b3);
                    b3.stops.push(c3);
                  });
                }
                q2 = "url(" + F.url + "#" + h2 + ")";
                k2.setAttribute(c2, q2);
                k2.gradient = n2;
                b2.toString = function() {
                  return q2;
                };
              }
            });
          }
          css(b2) {
            const k2 = this.styles, f2 = {}, F = this.element;
            let l2, w2 = !k2;
            k2 && d(b2, function(b3, c2) {
              k2 && k2[c2] !== b3 && (f2[c2] = b3, w2 = true);
            });
            if (w2) {
              k2 && (b2 = M(k2, f2));
              null === b2.width || "auto" === b2.width ? delete this.textWidth : "text" === F.nodeName.toLowerCase() && b2.width && (l2 = this.textWidth = c(b2.width));
              this.styles = b2;
              l2 && !q && this.renderer.forExport && delete b2.width;
              const d2 = v(b2);
              F.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach((b3) => d2 && delete d2[b3]), d2.color && (d2.fill = d2.color));
              e(F, d2);
            }
            this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b2.textOutline && this.applyTextOutline(b2.textOutline));
            return this;
          }
          dashstyleSetter(d2) {
            let k2 = this["stroke-width"];
            "inherit" === k2 && (k2 = 1);
            if (d2 = d2 && d2.toLowerCase()) {
              const f2 = d2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
              for (d2 = f2.length; d2--; )
                f2[d2] = "" + c(f2[d2]) * b(k2, NaN);
              d2 = f2.join(",").replace(/NaN/g, "none");
              this.element.setAttribute(
                "stroke-dasharray",
                d2
              );
            }
          }
          destroy() {
            const b2 = this;
            var c2 = b2.element || {};
            const k2 = b2.renderer;
            var f2 = c2.ownerSVGElement;
            let l2 = "SPAN" === c2.nodeName && b2.parentGroup || void 0;
            c2.onclick = c2.onmouseout = c2.onmouseover = c2.onmousemove = c2.point = null;
            E(b2);
            if (b2.clipPath && f2) {
              const c3 = b2.clipPath;
              [].forEach.call(f2.querySelectorAll("[clip-path],[CLIP-PATH]"), function(b3) {
                -1 < b3.getAttribute("clip-path").indexOf(c3.element.id) && b3.removeAttribute("clip-path");
              });
              b2.clipPath = c3.destroy();
            }
            if (b2.stops) {
              for (f2 = 0; f2 < b2.stops.length; f2++)
                b2.stops[f2].destroy();
              b2.stops.length = 0;
              b2.stops = void 0;
            }
            for (b2.safeRemoveChild(c2); l2 && l2.div && 0 === l2.div.childNodes.length; )
              c2 = l2.parentGroup, b2.safeRemoveChild(l2.div), delete l2.div, l2 = c2;
            b2.alignTo && I(k2.alignedObjects, b2);
            d(b2, function(c3, d2) {
              b2[d2] && b2[d2].parentGroup === b2 && b2[d2].destroy && b2[d2].destroy();
              delete b2[d2];
            });
          }
          dSetter(b2, c2, d2) {
            f(b2) && ("string" === typeof b2[0] && (b2 = this.renderer.pathToSegments(b2)), this.pathArray = b2, b2 = b2.reduce((b3, c3, d3) => c3 && c3.join ? (d3 ? b3 + " " : "") + c3.join(" ") : (c3 || "").toString(), ""));
            /(NaN| {2}|^$)/.test(b2) && (b2 = "M 0 0");
            this[c2] !== b2 && (d2.setAttribute(
              c2,
              b2
            ), this[c2] = b2);
          }
          fadeOut(c2) {
            const d2 = this;
            d2.animate({ opacity: 0 }, { duration: b(c2, 150), complete: function() {
              d2.hide();
            } });
          }
          fillSetter(b2, c2, d2) {
            "string" === typeof b2 ? d2.setAttribute(c2, b2) : b2 && this.complexColor(b2, c2, d2);
          }
          getBBox(c2, d2) {
            const { alignValue: k2, element: f2, renderer: l2, styles: F, textStr: H } = this, { cache: w2, cacheKeys: r2 } = l2;
            var v2 = f2.namespaceURI === this.SVG_NS;
            d2 = b(d2, this.rotation, 0);
            var g2 = l2.styledMode ? f2 && z.prototype.getStyle.call(f2, "font-size") : F && F.fontSize;
            let N;
            let a3;
            x(H) && (a3 = H.toString(), -1 === a3.indexOf("<") && (a3 = a3.replace(
              /[0-9]/g,
              "0"
            )), a3 += ["", l2.rootFontSize, g2, d2, this.textWidth, k2, F && F.textOverflow, F && F.fontWeight].join());
            a3 && !c2 && (N = w2[a3]);
            if (!N) {
              if (v2 || l2.forExport) {
                try {
                  var h2 = this.fakeTS && function(b2) {
                    const c3 = f2.querySelector(".highcharts-text-outline");
                    c3 && e(c3, { display: b2 });
                  };
                  y(h2) && h2("none");
                  N = f2.getBBox ? M({}, f2.getBBox()) : { width: f2.offsetWidth, height: f2.offsetHeight, x: 0, y: 0 };
                  y(h2) && h2("");
                } catch (da) {
                  "";
                }
                if (!N || 0 > N.width)
                  N = { x: 0, y: 0, width: 0, height: 0 };
              } else
                N = this.htmlGetBBox();
              h2 = N.width;
              c2 = N.height;
              v2 && (N.height = c2 = { "11px,17": 14, "13px,20": 16 }[`${g2 || ""},${Math.round(c2)}`] || c2);
              if (d2) {
                v2 = Number(f2.getAttribute("y") || 0) - N.y;
                g2 = { right: 1, center: 0.5 }[k2 || 0] || 0;
                var n2 = d2 * B, q2 = (d2 - 90) * B, m2 = h2 * Math.cos(n2);
                d2 = h2 * Math.sin(n2);
                var p2 = Math.cos(q2);
                n2 = Math.sin(q2);
                h2 = N.x + g2 * (h2 - m2) + v2 * p2;
                q2 = h2 + m2;
                p2 = q2 - c2 * p2;
                m2 = p2 - m2;
                v2 = N.y + v2 - g2 * d2 + v2 * n2;
                g2 = v2 + d2;
                c2 = g2 - c2 * n2;
                d2 = c2 - d2;
                N.x = Math.min(h2, q2, p2, m2);
                N.y = Math.min(v2, g2, c2, d2);
                N.width = Math.max(h2, q2, p2, m2) - N.x;
                N.height = Math.max(v2, g2, c2, d2) - N.y;
              }
            }
            if (a3 && ("" === H || 0 < N.height)) {
              for (; 250 < r2.length; )
                delete w2[r2.shift()];
              w2[a3] || r2.push(a3);
              w2[a3] = N;
            }
            return N;
          }
          getStyle(b2) {
            return p.getComputedStyle(this.element || this, "").getPropertyValue(b2);
          }
          hasClass(b2) {
            return -1 !== ("" + this.attr("class")).split(" ").indexOf(b2);
          }
          hide() {
            return this.attr({ visibility: "hidden" });
          }
          htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
          }
          init(b2, c2) {
            this.element = "span" === c2 ? g(c2) : t.createElementNS(this.SVG_NS, c2);
            this.renderer = b2;
            C(this, "afterInit");
          }
          on(b2, c2) {
            const { onEvents: d2 } = this;
            if (d2[b2])
              d2[b2]();
            d2[b2] = n(this.element, b2, c2);
            return this;
          }
          opacitySetter(b2, c2, d2) {
            this.opacity = b2 = Number(Number(b2).toFixed(3));
            d2.setAttribute(c2, b2);
          }
          removeClass(b2) {
            return this.attr(
              "class",
              ("" + this.attr("class")).replace(l(b2) ? new RegExp(`(^| )${b2}( |$)`) : b2, " ").replace(/ +/g, " ").trim()
            );
          }
          removeTextOutline() {
            const b2 = this.element.querySelector("tspan.highcharts-text-outline");
            b2 && this.safeRemoveChild(b2);
          }
          safeRemoveChild(b2) {
            const c2 = b2.parentNode;
            c2 && c2.removeChild(b2);
          }
          setRadialReference(b2) {
            const c2 = this.element.gradient && this.renderer.gradients[this.element.gradient];
            this.element.radialReference = b2;
            c2 && c2.radAttr && c2.animate(this.renderer.getRadialAttr(b2, c2.radAttr));
            return this;
          }
          setTextPath(b2, c2) {
            c2 = v(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, c2);
            const d2 = this.renderer.url, k2 = this.text || this, f2 = k2.textPath, { attributes: l2, enabled: H } = c2;
            b2 = b2 || f2 && f2.path;
            f2 && f2.undo();
            b2 && H ? (c2 = n(k2, "afterModifyTree", (c3) => {
              if (b2 && H) {
                let H2 = b2.attr("id");
                H2 || b2.attr("id", H2 = w());
                var f3 = { x: 0, y: 0 };
                x(l2.dx) && (f3.dx = l2.dx, delete l2.dx);
                x(l2.dy) && (f3.dy = l2.dy, delete l2.dy);
                k2.attr(f3);
                this.attr({ transform: "" });
                this.box && (this.box = this.box.destroy());
                f3 = c3.nodes.slice(0);
                c3.nodes.length = 0;
                c3.nodes[0] = { tagName: "textPath", attributes: M(
                  l2,
                  { "text-anchor": l2.textAnchor, href: `${d2}#${H2}` }
                ), children: f3 };
              }
            }), k2.textPath = { path: b2, undo: c2 }) : (k2.attr({ dx: 0, dy: 0 }), delete k2.textPath);
            this.added && (k2.textCache = "", this.renderer.buildText(k2));
            return this;
          }
          shadow(b2) {
            var c2;
            const { renderer: d2 } = this, k2 = v(90 === (null === (c2 = this.parentGroup) || void 0 === c2 ? void 0 : c2.rotation) ? { offsetX: -1, offsetY: -1 } : {}, r(b2) ? b2 : {});
            c2 = d2.shadowDefinition(k2);
            return this.attr({ filter: b2 ? `url(${d2.url}#${c2})` : "none" });
          }
          show(b2 = true) {
            return this.attr({ visibility: b2 ? "inherit" : "visible" });
          }
          ["stroke-widthSetter"](b2, c2, d2) {
            this[c2] = b2;
            d2.setAttribute(c2, b2);
          }
          strokeWidth() {
            if (!this.renderer.styledMode)
              return this["stroke-width"] || 0;
            const b2 = this.getStyle("stroke-width");
            let d2 = 0, k2;
            b2.indexOf("px") === b2.length - 2 ? d2 = c(b2) : "" !== b2 && (k2 = t.createElementNS(m, "rect"), h(k2, { width: b2, "stroke-width": 0 }), this.element.parentNode.appendChild(k2), d2 = k2.getBBox().width, k2.parentNode.removeChild(k2));
            return d2;
          }
          symbolAttr(c2) {
            const d2 = this;
            z.symbolCustomAttribs.forEach(function(k2) {
              d2[k2] = b(c2[k2], d2[k2]);
            });
            d2.attr({ d: d2.renderer.symbols[d2.symbolName](
              d2.x,
              d2.y,
              d2.width,
              d2.height,
              d2
            ) });
          }
          textSetter(b2) {
            b2 !== this.textStr && (delete this.textPxLength, this.textStr = b2, this.added && this.renderer.buildText(this));
          }
          titleSetter(c2) {
            const d2 = this.element, k2 = d2.getElementsByTagName("title")[0] || t.createElementNS(this.SVG_NS, "title");
            d2.insertBefore ? d2.insertBefore(k2, d2.firstChild) : d2.appendChild(k2);
            k2.textContent = String(b(c2, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
          }
          toFront() {
            const b2 = this.element;
            b2.parentNode.appendChild(b2);
            return this;
          }
          translate(b2, c2) {
            return this.attr({
              translateX: b2,
              translateY: c2
            });
          }
          updateTransform() {
            const { element: c2, matrix: d2, rotation: k2 = 0, scaleX: f2, scaleY: l2, translateX: e2 = 0, translateY: H = 0 } = this, w2 = ["translate(" + e2 + "," + H + ")"];
            x(d2) && w2.push("matrix(" + d2.join(",") + ")");
            k2 && w2.push("rotate(" + k2 + " " + b(this.rotationOriginX, c2.getAttribute("x"), 0) + " " + b(this.rotationOriginY, c2.getAttribute("y") || 0) + ")");
            (x(f2) || x(l2)) && w2.push("scale(" + b(f2, 1) + " " + b(l2, 1) + ")");
            w2.length && !(this.text || this).textPath && c2.setAttribute("transform", w2.join(" "));
          }
          visibilitySetter(b2, c2, d2) {
            "inherit" === b2 ? d2.removeAttribute(c2) : this[c2] !== b2 && d2.setAttribute(c2, b2);
            this[c2] = b2;
          }
          xGetter(b2) {
            "circle" === this.element.nodeName && ("x" === b2 ? b2 = "cx" : "y" === b2 && (b2 = "cy"));
            return this._defaultGetter(b2);
          }
          zIndexSetter(b2, d2) {
            var k2 = this.renderer, f2 = this.parentGroup;
            const l2 = (f2 || k2).element || k2.box, e2 = this.element;
            k2 = l2 === k2.box;
            let H = false, w2;
            var r2 = this.added;
            let z2;
            x(b2) ? (e2.setAttribute("data-z-index", b2), b2 = +b2, this[d2] === b2 && (r2 = false)) : x(this[d2]) && e2.removeAttribute("data-z-index");
            this[d2] = b2;
            if (r2) {
              (b2 = this.zIndex) && f2 && (f2.handleZ = true);
              d2 = l2.childNodes;
              for (z2 = d2.length - 1; 0 <= z2 && !H; z2--)
                if (f2 = d2[z2], r2 = f2.getAttribute("data-z-index"), w2 = !x(r2), f2 !== e2) {
                  if (0 > b2 && w2 && !k2 && !z2)
                    l2.insertBefore(e2, d2[z2]), H = true;
                  else if (c(r2) <= b2 || w2 && (!x(b2) || 0 <= b2))
                    l2.insertBefore(e2, d2[z2 + 1]), H = true;
                }
              H || (l2.insertBefore(e2, d2[k2 ? 3 : 0]), H = true);
            }
            return H;
          }
        }
        z.symbolCustomAttribs = "anchorX anchorY clockwise end height innerR r start width x y".split(" ");
        z.prototype.strokeSetter = z.prototype.fillSetter;
        z.prototype.yGetter = z.prototype.xGetter;
        z.prototype.matrixSetter = z.prototype.rotationOriginXSetter = z.prototype.rotationOriginYSetter = z.prototype.rotationSetter = z.prototype.scaleXSetter = z.prototype.scaleYSetter = z.prototype.translateXSetter = z.prototype.translateYSetter = z.prototype.verticalAlignSetter = function(b2, c2) {
          this[c2] = b2;
          this.doTransform = true;
        };
        "";
        return z;
      });
      L(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function(a2) {
        var u;
        (function(u2) {
          u2.rendererTypes = {};
          let A;
          u2.getRendererType = function(a3 = A) {
            return u2.rendererTypes[a3] || u2.rendererTypes[A];
          };
          u2.registerRendererType = function(G, D, E) {
            u2.rendererTypes[G] = D;
            if (!A || E)
              A = G, a2.Renderer = D;
          };
        })(u || (u = {}));
        return u;
      });
      L(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { defined: u, extend: K, isNumber: G, merge: D, pick: E, removeEvent: B } = A;
        class t extends a2 {
          constructor(a3, m, p, n, h, g, e, x, I, M) {
            super();
            this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;
            this.init(a3, "g");
            this.textStr = m;
            this.x = p;
            this.y = n;
            this.anchorX = g;
            this.anchorY = e;
            this.baseline = I;
            this.className = M;
            this.addClass("button" === M ? "highcharts-no-tooltip" : "highcharts-label");
            M && this.addClass("highcharts-" + M);
            this.text = a3.text(void 0, 0, 0, x).attr({ zIndex: 1 });
            let q;
            "string" === typeof h && ((q = /^url\((.*?)\)$/.test(h)) || this.renderer.symbols[h]) && (this.symbolKey = h);
            this.bBox = t.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = a3.styledMode || q;
            this.deferredAttr = {};
            this.alignFactor = 0;
          }
          alignSetter(a3) {
            a3 = { left: 0, center: 0.5, right: 1 }[a3];
            a3 !== this.alignFactor && (this.alignFactor = a3, this.bBox && G(this.xSetting) && this.attr({ x: this.xSetting }));
          }
          anchorXSetter(a3, m) {
            this.anchorX = a3;
            this.boxAttr(m, Math.round(a3) - this.getCrispAdjust() - this.xSetting);
          }
          anchorYSetter(a3, m) {
            this.anchorY = a3;
            this.boxAttr(m, a3 - this.ySetting);
          }
          boxAttr(a3, m) {
            this.box ? this.box.attr(a3, m) : this.deferredAttr[a3] = m;
          }
          css(q) {
            if (q) {
              const a3 = {};
              q = D(q);
              t.textProps.forEach((m) => {
                "undefined" !== typeof q[m] && (a3[m] = q[m], delete q[m]);
              });
              this.text.css(a3);
              "fontSize" in a3 || "fontWeight" in a3 ? this.updateTextPadding() : ("width" in a3 || "textOverflow" in a3) && this.updateBoxSize();
            }
            return a2.prototype.css.call(this, q);
          }
          destroy() {
            B(this.element, "mouseenter");
            B(this.element, "mouseleave");
            this.text && this.text.destroy();
            this.box && (this.box = this.box.destroy());
            a2.prototype.destroy.call(this);
          }
          fillSetter(a3, m) {
            a3 && (this.needsBox = true);
            this.fill = a3;
            this.boxAttr(m, a3);
          }
          getBBox() {
            this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
            const a3 = this.padding, m = E(this.paddingLeft, a3);
            return { width: this.width, height: this.height, x: this.bBox.x - m, y: this.bBox.y - a3 };
          }
          getCrispAdjust() {
            return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          }
          heightSetter(a3) {
            this.heightSetting = a3;
          }
          onAdd() {
            this.text.add(this);
            this.attr({ text: E(this.textStr, ""), x: this.x || 0, y: this.y || 0 });
            this.box && u(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
          }
          paddingSetter(a3, m) {
            G(a3) ? a3 !== this[m] && (this[m] = a3, this.updateTextPadding()) : this[m] = void 0;
          }
          rSetter(a3, m) {
            this.boxAttr(m, a3);
          }
          strokeSetter(a3, m) {
            this.stroke = a3;
            this.boxAttr(m, a3);
          }
          ["stroke-widthSetter"](a3, m) {
            a3 && (this.needsBox = true);
            this["stroke-width"] = a3;
            this.boxAttr(m, a3);
          }
          ["text-alignSetter"](a3) {
            this.textAlign = a3;
          }
          textSetter(a3) {
            "undefined" !== typeof a3 && this.text.attr({ text: a3 });
            this.updateTextPadding();
          }
          updateBoxSize() {
            var a3 = this.text;
            const m = {}, p = this.padding, n = this.bBox = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !u(a3.textStr) ? t.emptyBBox : a3.getBBox();
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || n.height || 0) + 2 * p;
            const h = this.renderer.fontMetrics(a3);
            this.baselineOffset = p + Math.min((this.text.firstLineMetrics || h).b, n.height || Infinity);
            this.heightSetting && (this.baselineOffset += (this.heightSetting - h.h) / 2);
            this.needsBox && !a3.textPath && (this.box || (a3 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a3.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a3.add(this)), a3 = this.getCrispAdjust(), m.x = a3, m.y = (this.baseline ? -this.baselineOffset : 0) + a3, m.width = Math.round(this.width), m.height = Math.round(this.height), this.box.attr(K(m, this.deferredAttr)), this.deferredAttr = {});
          }
          updateTextPadding() {
            const a3 = this.text;
            if (!a3.textPath) {
              this.updateBoxSize();
              const m = this.baseline ? 0 : this.baselineOffset;
              let p = E(this.paddingLeft, this.padding);
              u(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (p += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (p !== a3.x || m !== a3.y)
                a3.attr("x", p), a3.hasBoxWidthChanged && (this.bBox = a3.getBBox(true)), "undefined" !== typeof m && a3.attr("y", m);
              a3.x = p;
              a3.y = m;
            }
          }
          widthSetter(a3) {
            this.widthSetting = G(a3) ? a3 : void 0;
          }
          getPaddedWidth() {
            var a3 = this.padding;
            const m = E(this.paddingLeft, a3);
            a3 = E(
              this.paddingRight,
              a3
            );
            return (this.widthSetting || this.bBox.width || 0) + m + a3;
          }
          xSetter(a3) {
            this.x = a3;
            this.alignFactor && (a3 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true);
            this.xSetting = Math.round(a3);
            this.attr("translateX", this.xSetting);
          }
          ySetter(a3) {
            this.ySetting = this.y = Math.round(a3);
            this.attr("translateY", this.ySetting);
          }
        }
        t.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        t.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(" ");
        return t;
      });
      L(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function(a2) {
        function u(a3, t, q, m, p) {
          const n = [];
          if (p) {
            const h = p.start || 0, g = E(p.r, q);
            q = E(p.r, m || q);
            m = (p.end || 0) - 1e-3;
            const e = p.innerR, x = E(p.open, 1e-3 > Math.abs((p.end || 0) - h - 2 * Math.PI)), I = Math.cos(h), M = Math.sin(h), C = Math.cos(m), f = Math.sin(m), y = E(p.longArc, 1e-3 > m - h - Math.PI ? 0 : 1);
            let r = ["A", g, q, 0, y, E(p.clockwise, 1), a3 + g * C, t + q * f];
            r.params = { start: h, end: m, cx: a3, cy: t };
            n.push(["M", a3 + g * I, t + q * M], r);
            G(e) && (r = ["A", e, e, 0, y, G(p.clockwise) ? 1 - p.clockwise : 0, a3 + e * I, t + e * M], r.params = { start: m, end: h, cx: a3, cy: t }, n.push(x ? ["M", a3 + e * C, t + e * f] : ["L", a3 + e * C, t + e * f], r));
            x || n.push(["Z"]);
          }
          return n;
        }
        function J(a3, t, q, m, p) {
          return p && p.r ? K(a3, t, q, m, p) : [["M", a3, t], ["L", a3 + q, t], ["L", a3 + q, t + m], ["L", a3, t + m], ["Z"]];
        }
        function K(a3, t, q, m, p) {
          p = (null === p || void 0 === p ? void 0 : p.r) || 0;
          return [["M", a3 + p, t], ["L", a3 + q - p, t], ["A", p, p, 0, 0, 1, a3 + q, t + p], ["L", a3 + q, t + m - p], ["A", p, p, 0, 0, 1, a3 + q - p, t + m], ["L", a3 + p, t + m], ["A", p, p, 0, 0, 1, a3, t + m - p], ["L", a3, t + p], ["A", p, p, 0, 0, 1, a3 + p, t], ["Z"]];
        }
        const { defined: G, isNumber: D, pick: E } = a2;
        return { arc: u, callout: function(a3, t, q, m, p) {
          const n = Math.min(p && p.r || 0, q, m), h = n + 6, g = p && p.anchorX;
          p = p && p.anchorY || 0;
          const e = K(a3, t, q, m, { r: n });
          if (!D(g))
            return e;
          a3 + g >= q ? p > t + h && p < t + m - h ? e.splice(3, 1, ["L", a3 + q, p - 6], ["L", a3 + q + 6, p], ["L", a3 + q, p + 6], ["L", a3 + q, t + m - n]) : e.splice(3, 1, ["L", a3 + q, m / 2], ["L", g, p], ["L", a3 + q, m / 2], ["L", a3 + q, t + m - n]) : 0 >= a3 + g ? p > t + h && p < t + m - h ? e.splice(7, 1, ["L", a3, p + 6], ["L", a3 - 6, p], ["L", a3, p - 6], ["L", a3, t + n]) : e.splice(7, 1, ["L", a3, m / 2], ["L", g, p], ["L", a3, m / 2], ["L", a3, t + n]) : p && p > m && g > a3 + h && g < a3 + q - h ? e.splice(5, 1, [
            "L",
            g + 6,
            t + m
          ], ["L", g, t + m + 6], ["L", g - 6, t + m], ["L", a3 + n, t + m]) : p && 0 > p && g > a3 + h && g < a3 + q - h && e.splice(1, 1, ["L", g - 6, t], ["L", g, t - 6], ["L", g + 6, t], ["L", q - n, t]);
          return e;
        }, circle: function(a3, t, q, m) {
          return u(a3 + q / 2, t + m / 2, q / 2, m / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
        }, diamond: function(a3, t, q, m) {
          return [["M", a3 + q / 2, t], ["L", a3 + q, t + m / 2], ["L", a3 + q / 2, t + m], ["L", a3, t + m / 2], ["Z"]];
        }, rect: J, roundedRect: K, square: J, triangle: function(a3, t, q, m) {
          return [["M", a3 + q / 2, t], ["L", a3 + q, t + m], ["L", a3, t + m], ["Z"]];
        }, "triangle-down": function(a3, t, q, m) {
          return [[
            "M",
            a3,
            t
          ], ["L", a3 + q, t], ["L", a3 + q / 2, t + m], ["Z"]];
        } };
      });
      L(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { doc: u, SVG_NS: G, win: D } = A, { attr: E, extend: B, fireEvent: t, isString: q, objectEach: m, pick: p } = J;
        class n {
          constructor(a3) {
            const g = a3.styles;
            this.renderer = a3.renderer;
            this.svgElement = a3;
            this.width = a3.textWidth;
            this.textLineHeight = g && g.lineHeight;
            this.textOutline = g && g.textOutline;
            this.ellipsis = !(!g || "ellipsis" !== g.textOverflow);
            this.noWrap = !(!g || "nowrap" !== g.whiteSpace);
          }
          buildSVG() {
            const h = this.svgElement, g = h.element;
            var e = h.renderer, x = p(h.textStr, "").toString();
            const n2 = -1 !== x.indexOf("<"), m2 = g.childNodes;
            e = !h.added && e.box;
            const C = /<br.*?>/g;
            var f = [x, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, h.getStyle("font-size"), this.width].join();
            if (f !== h.textCache) {
              h.textCache = f;
              delete h.actualWidth;
              for (f = m2.length; f--; )
                g.removeChild(m2[f]);
              n2 || this.ellipsis || this.width || h.textPath || -1 !== x.indexOf(" ") && (!this.noWrap || C.test(x)) ? "" !== x && (e && e.appendChild(g), x = new a2(x), this.modifyTree(x.nodes), x.addToDOM(g), this.modifyDOM(), this.ellipsis && -1 !== (g.textContent || "").indexOf("‚Ä¶") && h.attr("title", this.unescapeEntities(h.textStr || "", ["&lt;", "&gt;"])), e && e.removeChild(g)) : g.appendChild(u.createTextNode(this.unescapeEntities(x)));
              q(this.textOutline) && h.applyTextOutline && h.applyTextOutline(this.textOutline);
            }
          }
          modifyDOM() {
            const a3 = this.svgElement, g = E(a3.element, "x");
            a3.firstLineMetrics = void 0;
            let e;
            for (; e = a3.element.firstChild; )
              if (/^[\s\u200B]*$/.test(e.textContent || " "))
                a3.element.removeChild(e);
              else
                break;
            [].forEach.call(a3.element.querySelectorAll("tspan.highcharts-br"), (e2, f) => {
              e2.nextSibling && e2.previousSibling && (0 === f && 1 === e2.previousSibling.nodeType && (a3.firstLineMetrics = a3.renderer.fontMetrics(e2.previousSibling)), E(e2, { dy: this.getLineHeight(e2.nextSibling), x: g }));
            });
            const x = this.width || 0;
            if (x) {
              var n2 = (e2, f) => {
                var y = e2.textContent || "";
                const r = y.replace(/([^\^])-/g, "$1- ").split(" ");
                var l = !this.noWrap && (1 < r.length || 1 < a3.element.childNodes.length);
                const v = this.getLineHeight(f);
                let d = 0, b = a3.actualWidth;
                if (this.ellipsis)
                  y && this.truncate(e2, y, void 0, 0, Math.max(0, x - 0.8 * v), (b2, d2) => b2.substring(0, d2) + "‚Ä¶");
                else if (l) {
                  y = [];
                  for (l = []; f.firstChild && f.firstChild !== e2; )
                    l.push(f.firstChild), f.removeChild(f.firstChild);
                  for (; r.length; )
                    r.length && !this.noWrap && 0 < d && (y.push(e2.textContent || ""), e2.textContent = r.join(" ").replace(/- /g, "-")), this.truncate(e2, void 0, r, 0 === d ? b || 0 : 0, x, (b2, d2) => r.slice(0, d2).join(" ").replace(/- /g, "-")), b = a3.actualWidth, d++;
                  l.forEach((b2) => {
                    f.insertBefore(b2, e2);
                  });
                  y.forEach((b2) => {
                    f.insertBefore(u.createTextNode(b2), e2);
                    b2 = u.createElementNS(G, "tspan");
                    b2.textContent = "‚Äã";
                    E(b2, { dy: v, x: g });
                    f.insertBefore(b2, e2);
                  });
                }
              }, m2 = (e2) => {
                [].slice.call(e2.childNodes).forEach((f) => {
                  f.nodeType === D.Node.TEXT_NODE ? n2(f, e2) : (-1 !== f.className.baseVal.indexOf("highcharts-br") && (a3.actualWidth = 0), m2(f));
                });
              };
              m2(a3.element);
            }
          }
          getLineHeight(a3) {
            a3 = a3.nodeType === D.Node.TEXT_NODE ? a3.parentElement : a3;
            return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a3 || this.svgElement.element).h;
          }
          modifyTree(a3) {
            const g = (e, h) => {
              const { attributes: x = {}, children: n2, style: m2 = {}, tagName: f } = e, y = this.renderer.styledMode;
              if ("b" === f || "strong" === f)
                y ? x["class"] = "highcharts-strong" : m2.fontWeight = "bold";
              else if ("i" === f || "em" === f)
                y ? x["class"] = "highcharts-emphasized" : m2.fontStyle = "italic";
              m2 && m2.color && (m2.fill = m2.color);
              "br" === f ? (x["class"] = "highcharts-br", e.textContent = "‚Äã", (h = a3[h + 1]) && h.textContent && (h.textContent = h.textContent.replace(/^ +/gm, ""))) : "a" === f && n2 && n2.some((f2) => "#text" === f2.tagName) && (e.children = [{ children: n2, tagName: "tspan" }]);
              "#text" !== f && "a" !== f && (e.tagName = "tspan");
              B(e, { attributes: x, style: m2 });
              n2 && n2.filter((f2) => "#text" !== f2.tagName).forEach(g);
            };
            a3.forEach(g);
            t(this.svgElement, "afterModifyTree", { nodes: a3 });
          }
          truncate(a3, g, e, x, n2, m2) {
            const h = this.svgElement, { rotation: f } = h, y = [];
            let r = e ? 1 : 0, l = (g || e || "").length, v = l, d, b;
            const c = function(b2, c2) {
              b2 = c2 || b2;
              if ((c2 = a3.parentNode) && "undefined" === typeof y[b2] && c2.getSubStringLength)
                try {
                  y[b2] = x + c2.getSubStringLength(0, e ? b2 + 1 : b2);
                } catch (z) {
                  "";
                }
              return y[b2];
            };
            h.rotation = 0;
            b = c(a3.textContent.length);
            if (x + b > n2) {
              for (; r <= l; )
                v = Math.ceil((r + l) / 2), e && (d = m2(e, v)), b = c(v, d && d.length - 1), r === l ? r = l + 1 : b > n2 ? l = v - 1 : r = v;
              0 === l ? a3.textContent = "" : g && l === g.length - 1 || (a3.textContent = d || m2(g || e, v));
            }
            e && e.splice(0, v);
            h.actualWidth = b;
            h.rotation = f;
          }
          unescapeEntities(a3, g) {
            m(this.renderer.escapes, function(e, h) {
              g && -1 !== g.indexOf(e) || (a3 = a3.toString().replace(new RegExp(e, "g"), h));
            });
            return a3;
          }
        }
        return n;
      });
      L(a, "Core/Renderer/SVG/SVGRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGLabel.js"],
        a["Core/Renderer/SVG/Symbols.js"],
        a["Core/Renderer/SVG/TextBuilder.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G, D, E, B, t) {
        const { charts: q, deg2rad: m, doc: p, isFirefox: n, isMS: h, isWebKit: g, noop: e, SVG_NS: x, symbolSizes: I, win: M } = J, { addEvent: C, attr: f, createElement: y, css: r, defined: l, destroyObjectProperties: v, extend: d, isArray: b, isNumber: c, isObject: k, isString: w, merge: z, pick: F, pInt: O, uniqueKey: P } = t;
        let T;
        class u {
          constructor(b2, c2, d2, k2, f2, a3, l2) {
            this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
            this.init(b2, c2, d2, k2, f2, a3, l2);
          }
          init(b2, c2, d2, k2, a3, l2, e2) {
            const H = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }), w2 = H.element;
            e2 || H.css(this.getStyle(k2));
            b2.appendChild(w2);
            f(b2, "dir", "ltr");
            -1 === b2.innerHTML.indexOf("xmlns") && f(w2, "xmlns", this.SVG_NS);
            this.box = w2;
            this.boxWrapper = H;
            this.alignedObjects = [];
            this.url = this.getReferenceURL();
            this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 11.1.0"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = l2;
            this.forExport = a3;
            this.styledMode = e2;
            this.gradients = {};
            this.cache = {};
            this.cacheKeys = [];
            this.imgCount = 0;
            this.rootFontSize = H.getStyle("font-size");
            this.setSize(c2, d2, false);
            let z2;
            n && b2.getBoundingClientRect && (c2 = function() {
              r(b2, { left: 0, top: 0 });
              z2 = b2.getBoundingClientRect();
              r(b2, { left: Math.ceil(z2.left) - z2.left + "px", top: Math.ceil(z2.top) - z2.top + "px" });
            }, c2(), this.unSubPixelFix = C(M, "resize", c2));
          }
          definition(b2) {
            return new a2([b2]).addToDOM(this.defs.element);
          }
          getReferenceURL() {
            if ((n || g) && p.getElementsByTagName("base").length) {
              if (!l(T)) {
                var b2 = P();
                b2 = new a2([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: b2 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${b2})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(p.body);
                r(b2, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                const c2 = p.elementFromPoint(6, 6);
                T = "hitme" === (c2 && c2.id);
                p.body.removeChild(b2);
              }
              if (T)
                return M.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
            }
            return "";
          }
          getStyle(b2) {
            return this.style = d({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, b2);
          }
          setStyle(b2) {
            this.boxWrapper.css(this.getStyle(b2));
          }
          isHidden() {
            return !this.boxWrapper.getBBox().width;
          }
          destroy() {
            const b2 = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            v(this.gradients || {});
            this.gradients = null;
            this.defs = b2.destroy();
            this.unSubPixelFix && this.unSubPixelFix();
            return this.alignedObjects = null;
          }
          createElement(b2) {
            const c2 = new this.Element();
            c2.init(this, b2);
            return c2;
          }
          getRadialAttr(b2, c2) {
            return { cx: b2[0] - b2[2] / 2 + (c2.cx || 0) * b2[2], cy: b2[1] - b2[2] / 2 + (c2.cy || 0) * b2[2], r: (c2.r || 0) * b2[2] };
          }
          shadowDefinition(b2) {
            const c2 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b2).map((c3) => b2[c3])].join("-").replace(/[^a-z0-9\-]/g, ""), d2 = z({
              color: "#000000",
              offsetX: 1,
              offsetY: 1,
              opacity: 0.15,
              width: 5
            }, b2);
            this.defs.element.querySelector(`#${c2}`) || this.definition({ tagName: "filter", attributes: { id: c2 }, children: [{ tagName: "feDropShadow", attributes: { dx: d2.offsetX, dy: d2.offsetY, "flood-color": d2.color, "flood-opacity": Math.min(5 * d2.opacity, 1), stdDeviation: d2.width / 2 } }] });
            return c2;
          }
          buildText(b2) {
            new B(b2).buildSVG();
          }
          getContrast(b2) {
            b2 = A.parse(b2).rgba.map((b3) => {
              b3 /= 255;
              return 0.03928 >= b3 ? b3 / 12.92 : Math.pow((b3 + 0.055) / 1.055, 2.4);
            });
            b2 = 0.2126 * b2[0] + 0.7152 * b2[1] + 0.0722 * b2[2];
            return 1.05 / (b2 + 0.05) > (b2 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
          }
          button(b2, c2, f2, l2, e2 = {}, w2, r2, v2, y2, g2) {
            const H = this.label(b2, c2, f2, y2, void 0, void 0, g2, void 0, "button"), N = this.styledMode;
            b2 = e2.states || {};
            let F2 = 0;
            e2 = z(e2);
            delete e2.states;
            const x2 = z({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, e2.style);
            delete e2.style;
            let n2 = a2.filterUserAttributes(e2);
            H.attr(z({ padding: 8, r: 2 }, n2));
            let m2, p2, Q;
            N || (n2 = z({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, n2), w2 = z(n2, { fill: "#e6e6e6" }, a2.filterUserAttributes(w2 || b2.hover || {})), m2 = w2.style, delete w2.style, r2 = z(n2, { fill: "#e6e9ff", style: {
              color: "#000000",
              fontWeight: "bold"
            } }, a2.filterUserAttributes(r2 || b2.select || {})), p2 = r2.style, delete r2.style, v2 = z(n2, { style: { color: "#cccccc" } }, a2.filterUserAttributes(v2 || b2.disabled || {})), Q = v2.style, delete v2.style);
            C(H.element, h ? "mouseover" : "mouseenter", function() {
              3 !== F2 && H.setState(1);
            });
            C(H.element, h ? "mouseout" : "mouseleave", function() {
              3 !== F2 && H.setState(F2);
            });
            H.setState = function(b3) {
              1 !== b3 && (H.state = F2 = b3);
              H.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [
                "normal",
                "hover",
                "pressed",
                "disabled"
              ][b3 || 0]);
              N || (H.attr([n2, w2, r2, v2][b3 || 0]), b3 = [x2, m2, p2, Q][b3 || 0], k(b3) && H.css(b3));
            };
            N || (H.attr(n2).css(d({ cursor: "default" }, x2)), g2 && H.text.css({ pointerEvents: "none" }));
            return H.on("touchstart", (b3) => b3.stopPropagation()).on("click", function(b3) {
              3 !== F2 && l2.call(H, b3);
            });
          }
          crispLine(b2, c2, d2 = "round") {
            const k2 = b2[0], f2 = b2[1];
            l(k2[1]) && k2[1] === f2[1] && (k2[1] = f2[1] = Math[d2](k2[1]) - c2 % 2 / 2);
            l(k2[2]) && k2[2] === f2[2] && (k2[2] = f2[2] = Math[d2](k2[2]) + c2 % 2 / 2);
            return b2;
          }
          path(c2) {
            const f2 = this.styledMode ? {} : { fill: "none" };
            b(c2) ? f2.d = c2 : k(c2) && d(f2, c2);
            return this.createElement("path").attr(f2);
          }
          circle(b2, c2, d2) {
            b2 = k(b2) ? b2 : "undefined" === typeof b2 ? {} : { x: b2, y: c2, r: d2 };
            c2 = this.createElement("circle");
            c2.xSetter = c2.ySetter = function(b3, c3, d3) {
              d3.setAttribute("c" + c3, b3);
            };
            return c2.attr(b2);
          }
          arc(b2, c2, d2, f2, a3, l2) {
            k(b2) ? (f2 = b2, c2 = f2.y, d2 = f2.r, b2 = f2.x) : f2 = { innerR: f2, start: a3, end: l2 };
            b2 = this.symbol("arc", b2, c2, d2, d2, f2);
            b2.r = d2;
            return b2;
          }
          rect(b2, c2, a3, l2, e2, w2) {
            b2 = k(b2) ? b2 : "undefined" === typeof b2 ? {} : { x: b2, y: c2, r: e2, width: Math.max(a3 || 0, 0), height: Math.max(l2 || 0, 0) };
            const H = this.createElement("rect");
            this.styledMode || ("undefined" !== typeof w2 && (b2["stroke-width"] = w2, d(b2, H.crisp(b2))), b2.fill = "none");
            H.rSetter = function(b3, c3, d2) {
              H.r = b3;
              f(d2, { rx: b3, ry: b3 });
            };
            H.rGetter = function() {
              return H.r || 0;
            };
            return H.attr(b2);
          }
          roundedRect(b2) {
            return this.symbol("roundedRect").attr(b2);
          }
          setSize(b2, c2, d2) {
            this.width = b2;
            this.height = c2;
            this.boxWrapper.animate({ width: b2, height: c2 }, { step: function() {
              this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
            }, duration: F(d2, true) ? void 0 : 0 });
            this.alignElements();
          }
          g(b2) {
            const c2 = this.createElement("g");
            return b2 ? c2.attr({ "class": "highcharts-" + b2 }) : c2;
          }
          image(b2, d2, k2, f2, a3, l2) {
            const H = { preserveAspectRatio: "none" };
            c(d2) && (H.x = d2);
            c(k2) && (H.y = k2);
            c(f2) && (H.width = f2);
            c(a3) && (H.height = a3);
            const e2 = this.createElement("image").attr(H);
            d2 = function(c2) {
              e2.attr({ href: b2 });
              l2.call(e2, c2);
            };
            l2 ? (e2.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" }), k2 = new M.Image(), C(k2, "load", d2), k2.src = b2, k2.complete && d2({})) : e2.attr({ href: b2 });
            return e2;
          }
          symbol(b2, c2, k2, a3, e2, w2) {
            const H = this, z2 = /^url\((.*?)\)$/, v2 = z2.test(b2), g2 = !v2 && (this.symbols[b2] ? b2 : "circle"), h2 = g2 && this.symbols[g2];
            let x2, n2, m2, Y;
            if (h2)
              "number" === typeof c2 && (n2 = h2.call(this.symbols, Math.round(c2 || 0), Math.round(k2 || 0), a3 || 0, e2 || 0, w2)), x2 = this.path(n2), H.styledMode || x2.attr("fill", "none"), d(x2, { symbolName: g2 || void 0, x: c2, y: k2, width: a3, height: e2 }), w2 && d(x2, w2);
            else if (v2) {
              m2 = b2.match(z2)[1];
              const d2 = x2 = this.image(m2);
              d2.imgwidth = F(w2 && w2.width, I[m2] && I[m2].width);
              d2.imgheight = F(w2 && w2.height, I[m2] && I[m2].height);
              Y = (b3) => b3.attr({ width: b3.width, height: b3.height });
              ["width", "height"].forEach(function(b3) {
                d2[b3 + "Setter"] = function(b4, c3) {
                  this[c3] = b4;
                  const {
                    alignByTranslate: d3,
                    element: k3,
                    width: a4,
                    height: H2,
                    imgwidth: e3,
                    imgheight: r2
                  } = this;
                  b4 = this["img" + c3];
                  if (l(b4)) {
                    let l2 = 1;
                    w2 && "within" === w2.backgroundSize && a4 && H2 ? (l2 = Math.min(a4 / e3, H2 / r2), f(k3, { width: Math.round(e3 * l2), height: Math.round(r2 * l2) })) : k3 && k3.setAttribute(c3, b4);
                    d3 || this.translate(((a4 || 0) - e3 * l2) / 2, ((H2 || 0) - r2 * l2) / 2);
                  }
                };
              });
              l(c2) && d2.attr({ x: c2, y: k2 });
              d2.isImg = true;
              l(d2.imgwidth) && l(d2.imgheight) ? Y(d2) : (d2.attr({ width: 0, height: 0 }), y("img", { onload: function() {
                const b3 = q[H.chartIndex];
                0 === this.width && (r(this, { position: "absolute", top: "-999em" }), p.body.appendChild(this));
                I[m2] = {
                  width: this.width,
                  height: this.height
                };
                d2.imgwidth = this.width;
                d2.imgheight = this.height;
                d2.element && Y(d2);
                this.parentNode && this.parentNode.removeChild(this);
                H.imgCount--;
                if (!H.imgCount && b3 && !b3.hasLoaded)
                  b3.onload();
              }, src: m2 }), this.imgCount++);
            }
            return x2;
          }
          clipRect(b2, c2, d2, k2) {
            const f2 = P() + "-", a3 = this.createElement("clipPath").attr({ id: f2 }).add(this.defs);
            b2 = this.rect(b2, c2, d2, k2, 0).add(a3);
            b2.id = f2;
            b2.clipPath = a3;
            b2.count = 0;
            return b2;
          }
          text(b2, c2, d2, k2) {
            const f2 = {};
            if (k2 && (this.allowHTML || !this.forExport))
              return this.html(b2, c2, d2);
            f2.x = Math.round(c2 || 0);
            d2 && (f2.y = Math.round(d2));
            l(b2) && (f2.text = b2);
            b2 = this.createElement("text").attr(f2);
            if (!k2 || this.forExport && !this.allowHTML)
              b2.xSetter = function(b3, c3, d3) {
                const k3 = d3.getElementsByTagName("tspan"), f3 = d3.getAttribute(c3);
                for (let d4 = 0, a3; d4 < k3.length; d4++)
                  a3 = k3[d4], a3.getAttribute(c3) === f3 && a3.setAttribute(c3, b3);
                d3.setAttribute(c3, b3);
              };
            return b2;
          }
          fontMetrics(b2) {
            b2 = O(G.prototype.getStyle.call(b2, "font-size") || 0);
            const c2 = 24 > b2 ? b2 + 3 : Math.round(1.2 * b2);
            return { h: c2, b: Math.round(0.8 * c2), f: b2 };
          }
          rotCorr(b2, c2, d2) {
            let k2 = b2;
            c2 && d2 && (k2 = Math.max(k2 * Math.cos(c2 * m), 4));
            return { x: -b2 / 3 * Math.sin(c2 * m), y: k2 };
          }
          pathToSegments(b2) {
            const d2 = [], k2 = [], f2 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
            for (let a3 = 0; a3 < b2.length; a3++)
              w(k2[0]) && c(b2[a3]) && k2.length === f2[k2[0].toUpperCase()] && b2.splice(a3, 0, k2[0].replace("M", "L").replace("m", "l")), "string" === typeof b2[a3] && (k2.length && d2.push(k2.slice(0)), k2.length = 0), k2.push(b2[a3]);
            d2.push(k2.slice(0));
            return d2;
          }
          label(b2, c2, d2, k2, f2, a3, l2, e2, w2) {
            return new D(this, b2, c2, d2, k2, f2, a3, l2, e2, w2);
          }
          alignElements() {
            this.alignedObjects.forEach((b2) => b2.align());
          }
        }
        d(u.prototype, {
          Element: G,
          SVG_NS: x,
          escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" },
          symbols: E,
          draw: e
        });
        K.registerRendererType("svg", u, true);
        "";
        return u;
      });
      L(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { isFirefox: u, isMS: G, isWebKit: D, win: E } = a2, { css: B, defined: t, extend: q, pick: m, pInt: p } = J, n = [];
        class h extends A {
          static compose(a3) {
            if (J.pushUnique(n, a3)) {
              const e = h.prototype, g = a3.prototype;
              g.getSpanCorrection = e.getSpanCorrection;
              g.htmlCss = e.htmlCss;
              g.htmlGetBBox = e.htmlGetBBox;
              g.htmlUpdateTransform = e.htmlUpdateTransform;
              g.setSpanRotation = e.setSpanRotation;
            }
            return a3;
          }
          getSpanCorrection(a3, e, h2) {
            this.xCorr = -a3 * h2;
            this.yCorr = -e;
          }
          htmlCss(a3) {
            const e = "SPAN" === this.element.tagName && a3 && "width" in a3, g = m(e && a3.width, void 0);
            let h2;
            e && (delete a3.width, this.textWidth = g, h2 = true);
            a3 && "ellipsis" === a3.textOverflow && (a3.whiteSpace = "nowrap", a3.overflow = "hidden");
            this.styles = q(this.styles, a3);
            B(this.element, a3);
            h2 && this.htmlUpdateTransform();
            return this;
          }
          htmlGetBBox() {
            const a3 = this.element;
            return { x: a3.offsetLeft, y: a3.offsetTop, width: a3.offsetWidth, height: a3.offsetHeight };
          }
          htmlUpdateTransform() {
            if (this.added) {
              var a3 = this.renderer, e = this.element, h2 = this.x || 0, n2 = this.y || 0, m2 = this.textAlign || "left", q2 = { left: 0, center: 0.5, right: 1 }[m2], f = this.styles, y = f && f.whiteSpace;
              B(e, { marginLeft: this.translateX || 0, marginTop: this.translateY || 0 });
              if ("SPAN" === e.tagName) {
                f = this.rotation;
                const l = this.textWidth && p(this.textWidth), v = [f, m2, e.innerHTML, this.textWidth, this.textAlign].join();
                let d = false;
                if (l !== this.oldTextWidth) {
                  if (this.textPxLength)
                    var r = this.textPxLength;
                  else
                    B(e, { width: "", whiteSpace: y || "nowrap" }), r = e.offsetWidth;
                  (l > this.oldTextWidth || r > l) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (B(e, { width: r > l || f ? l + "px" : "auto", display: "block", whiteSpace: y || "normal" }), this.oldTextWidth = l, d = true);
                }
                this.hasBoxWidthChanged = d;
                v !== this.cTT && (a3 = a3.fontMetrics(e).b, !t(f) || f === (this.oldRotation || 0) && m2 === this.oldAlign || this.setSpanRotation(f, q2, a3), this.getSpanCorrection(!t(f) && this.textPxLength || e.offsetWidth, a3, q2, f, m2));
                B(e, { left: h2 + (this.xCorr || 0) + "px", top: n2 + (this.yCorr || 0) + "px" });
                this.cTT = v;
                this.oldRotation = f;
                this.oldAlign = m2;
              }
            } else
              this.alignOnAdd = true;
          }
          setSpanRotation(a3, e, h2) {
            const g = {}, x = G && !/Edge/.test(E.navigator.userAgent) ? "-ms-transform" : D ? "-webkit-transform" : u ? "MozTransform" : E.opera ? "-o-transform" : void 0;
            x && (g[x] = g.transform = "rotate(" + a3 + "deg)", g[x + (u ? "Origin" : "-origin")] = g.transformOrigin = 100 * e + "% " + h2 + "px", B(this.element, g));
          }
        }
        return h;
      });
      L(a, "Core/Renderer/HTML/HTMLRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K) {
        const { attr: u, createElement: D, extend: E, pick: B } = K, t = [];
        class q extends J {
          static compose(a3) {
            K.pushUnique(t, a3) && (a3.prototype.html = q.prototype.html);
            return a3;
          }
          html(m, p, n) {
            const h = this.createElement("span"), g = h.element, e = h.renderer, x = function(a3, e2) {
              ["opacity", "visibility"].forEach(function(g2) {
                a3[g2 + "Setter"] = function(f, y, r) {
                  const l = a3.div ? a3.div.style : e2;
                  A.prototype[g2 + "Setter"].call(this, f, y, r);
                  l && (l[y] = f);
                };
              });
              a3.addedSetters = true;
            };
            h.textSetter = function(e2) {
              e2 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a2.setElementHTML(this.element, B(e2, "")), this.textStr = e2, h.doTransform = true);
            };
            x(h, h.element.style);
            h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function(a3, e2) {
              "align" === e2 ? h.alignValue = h.textAlign = a3 : h[e2] = a3;
              h.doTransform = true;
            };
            h.afterSetters = function() {
              this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
            };
            h.attr({ text: m, x: Math.round(p), y: Math.round(n) }).css({ position: "absolute" });
            e.styledMode || h.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });
            g.style.whiteSpace = "nowrap";
            h.css = h.htmlCss;
            h.add = function(a3) {
              const n2 = e.box.parentNode, m2 = [];
              let f;
              if (this.parentGroup = a3) {
                if (f = a3.div, !f) {
                  for (; a3; )
                    m2.push(a3), a3 = a3.parentGroup;
                  m2.reverse().forEach(function(a4) {
                    function e2(b, c) {
                      a4[c] = b;
                      "translateX" === c ? d.left = b + "px" : d.top = b + "px";
                      a4.doTransform = true;
                    }
                    const l = u(a4.element, "class"), v = a4.styles || {};
                    f = a4.div = a4.div || D("div", l ? { className: l } : void 0, { position: "absolute", left: (a4.translateX || 0) + "px", top: (a4.translateY || 0) + "px", display: a4.display, opacity: a4.opacity, visibility: a4.visibility }, f || n2);
                    const d = f.style;
                    E(a4, { classSetter: function(b) {
                      return function(c) {
                        this.element.setAttribute("class", c);
                        b.className = c;
                      };
                    }(f), css: function(b) {
                      h.css.call(a4, b);
                      ["cursor", "pointerEvents"].forEach((c) => {
                        b[c] && (d[c] = b[c]);
                      });
                      return a4;
                    }, on: function() {
                      m2[0].div && h.on.apply({ element: m2[0].div, onEvents: a4.onEvents }, arguments);
                      return a4;
                    }, translateXSetter: e2, translateYSetter: e2 });
                    a4.addedSetters || x(a4);
                    a4.css(v);
                  });
                }
              } else
                f = n2;
              f.appendChild(g);
              h.added = true;
              h.alignOnAdd && h.htmlUpdateTransform();
              return h;
            };
            return h;
          }
        }
        return q;
      });
      L(a, "Core/Axis/AxisDefaults.js", [], function() {
        var a2;
        (function(a3) {
          a3.defaultXAxisOptions = {
            alignTicks: true,
            allowDecimals: void 0,
            panningEnabled: true,
            zIndex: 2,
            zoomEnabled: true,
            dateTimeLabelFormats: { millisecond: { main: "%H:%M:%S.%L", range: false }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } },
            endOnTick: false,
            gridLineDashStyle: "Solid",
            gridZIndex: 1,
            labels: { autoRotation: void 0, autoRotationLimit: 80, distance: 15, enabled: true, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } },
            maxPadding: 0.01,
            minorGridLineDashStyle: "Solid",
            minorTickLength: 2,
            minorTickPosition: "outside",
            minorTicksPerMajor: 5,
            minPadding: 0.01,
            offset: void 0,
            opposite: false,
            reversed: void 0,
            reversedStacks: false,
            showEmpty: true,
            showFirstLabel: true,
            showLastLabel: true,
            startOfWeek: 1,
            startOnTick: false,
            tickLength: 10,
            tickPixelInterval: 100,
            tickmarkPlacement: "between",
            tickPosition: "outside",
            title: { align: "middle", rotation: 0, useHTML: false, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } },
            type: "linear",
            uniqueNames: true,
            visible: true,
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#333333",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            gridLineWidth: void 0,
            tickColor: "#333333"
          };
          a3.defaultYAxisOptions = {
            reversedStacks: true,
            endOnTick: true,
            maxPadding: 0.05,
            minPadding: 0.05,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: { x: void 0 },
            startOnTick: true,
            title: { rotation: 270, text: "Values" },
            stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
              const { numberFormatter: a4 } = this.axis.chart;
              return a4(this.total || 0, -1);
            }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } },
            gridLineWidth: 1,
            lineWidth: 0
          };
          a3.defaultLeftAxisOptions = { title: { rotation: 270 } };
          a3.defaultRightAxisOptions = { title: { rotation: 90 } };
          a3.defaultBottomAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
          a3.defaultTopAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
        })(a2 || (a2 = {}));
        return a2;
      });
      L(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: u, isFunction: J, objectEach: K, removeEvent: G } = a2;
        var D;
        (function(a3) {
          a3.registerEventOptions = function(a4, t) {
            a4.eventOptions = a4.eventOptions || {};
            K(t.events, function(q, m) {
              a4.eventOptions[m] !== q && (a4.eventOptions[m] && (G(a4, m, a4.eventOptions[m]), delete a4.eventOptions[m]), J(q) && (a4.eventOptions[m] = q, u(a4, m, q, { order: 0 })));
            });
          };
        })(D || (D = {}));
        return D;
      });
      L(a, "Core/Axis/Tick.js", [a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { deg2rad: u } = A, { clamp: G, correctFloat: D, defined: E, destroyObjectProperties: B, extend: t, fireEvent: q, isNumber: m, merge: p, objectEach: n, pick: h } = J;
        class g {
          constructor(a3, g2, h2, n2, m2) {
            this.isNewLabel = this.isNew = true;
            this.axis = a3;
            this.pos = g2;
            this.type = h2 || "";
            this.parameters = m2 || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            q(this, "init");
            h2 || n2 || this.addLabel();
          }
          addLabel() {
            const e = this, g2 = e.axis;
            var n2 = g2.options;
            const p2 = g2.chart;
            var C = g2.categories;
            const f = g2.logarithmic, y = g2.names, r = e.pos, l = h(e.options && e.options.labels, n2.labels);
            var v = g2.tickPositions;
            const d = r === v[0], b = r === v[v.length - 1], c = (!l.step || 1 === l.step) && 1 === g2.tickInterval;
            v = v.info;
            let k = e.label, w, z, F;
            C = this.parameters.category || (C ? h(C[r], y[r], r) : r);
            f && m(C) && (C = D(f.lin2log(C)));
            g2.dateTime && (v ? (z = p2.time.resolveDTLFormat(n2.dateTimeLabelFormats[!n2.grid && v.higherRanks[r] || v.unitName]), w = z.main) : m(C) && (w = g2.dateTime.getXDateFormat(C, n2.dateTimeLabelFormats || {})));
            e.isFirst = d;
            e.isLast = b;
            const O = { axis: g2, chart: p2, dateTimeLabelFormat: w, isFirst: d, isLast: b, pos: r, tick: e, tickPositionInfo: v, value: C };
            q(this, "labelFormat", O);
            const P = (b2) => l.formatter ? l.formatter.call(b2, b2) : l.format ? (b2.text = g2.defaultLabelFormatter.call(b2, b2), a2.format(l.format, b2, p2)) : g2.defaultLabelFormatter.call(b2, b2);
            n2 = P.call(O, O);
            const T = z && z.list;
            e.shortenLabel = T ? function() {
              for (F = 0; F < T.length; F++)
                if (t(
                  O,
                  { dateTimeLabelFormat: T[F] }
                ), k.attr({ text: P.call(O, O) }), k.getBBox().width < g2.getSlotWidth(e) - 2 * l.padding)
                  return;
              k.attr({ text: "" });
            } : void 0;
            c && g2._addedPlotLB && e.moveLabel(n2, l);
            E(k) || e.movedLabel ? k && k.textStr !== n2 && !c && (!k.textWidth || l.style.width || k.styles.width || k.css({ width: null }), k.attr({ text: n2 }), k.textPxLength = k.getBBox().width) : (e.label = k = e.createLabel({ x: 0, y: 0 }, n2, l), e.rotation = 0);
          }
          createLabel(a3, g2, h2) {
            const e = this.axis, n2 = e.chart;
            if (a3 = E(g2) && h2.enabled ? n2.renderer.text(g2, a3.x, a3.y, h2.useHTML).add(e.labelGroup) : null)
              n2.styledMode || a3.css(p(h2.style)), a3.textPxLength = a3.getBBox().width;
            return a3;
          }
          destroy() {
            B(this, this.axis);
          }
          getPosition(a3, g2, h2, n2) {
            const e = this.axis, f = e.chart, y = n2 && f.oldChartHeight || f.chartHeight;
            a3 = { x: a3 ? D(e.translate(g2 + h2, void 0, void 0, n2) + e.transB) : e.left + e.offset + (e.opposite ? (n2 && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0), y: a3 ? y - e.bottom + e.offset - (e.opposite ? e.height : 0) : D(y - e.translate(g2 + h2, void 0, void 0, n2) - e.transB) };
            a3.y = G(a3.y, -1e5, 1e5);
            q(this, "afterGetPosition", { pos: a3 });
            return a3;
          }
          getLabelPosition(a3, g2, n2, m2, p2, f, y, r) {
            const l = this.axis, e = l.transA, d = l.isLinked && l.linkedParent ? l.linkedParent.reversed : l.reversed, b = l.staggerLines, c = l.tickRotCorr || { x: 0, y: 0 }, k = m2 || l.reserveSpaceDefault ? 0 : -l.labelOffset * ("center" === l.labelAlign ? 0.5 : 1), w = p2.distance, z = {};
            n2 = 0 === l.side ? n2.rotation ? -w : -n2.getBBox().height : 2 === l.side ? c.y + w : Math.cos(n2.rotation * u) * (c.y - n2.getBBox(false, 0).height / 2);
            E(p2.y) && (n2 = 0 === l.side && l.horiz ? p2.y + n2 : p2.y);
            a3 = a3 + h(p2.x, [0, 1, 0, -1][l.side] * w) + k + c.x - (f && m2 ? f * e * (d ? -1 : 1) : 0);
            g2 = g2 + n2 - (f && !m2 ? f * e * (d ? 1 : -1) : 0);
            b && (m2 = y / (r || 1) % b, l.opposite && (m2 = b - m2 - 1), g2 += l.labelOffset / b * m2);
            z.x = a3;
            z.y = Math.round(g2);
            q(this, "afterGetLabelPosition", { pos: z, tickmarkOffset: f, index: y });
            return z;
          }
          getLabelSize() {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
          }
          getMarkPath(a3, g2, h2, n2, m2, f) {
            return f.crispLine([["M", a3, g2], ["L", a3 + (m2 ? 0 : -h2), g2 + (m2 ? h2 : 0)]], n2);
          }
          handleOverflow(a3) {
            const e = this.axis, g2 = e.options.labels, n2 = a3.x;
            var m2 = e.chart.chartWidth, f = e.chart.spacing;
            const y = h(e.labelLeft, Math.min(e.pos, f[3]));
            f = h(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, m2 - f[1]));
            const r = this.label, l = this.rotation, v = { left: 0, center: 0.5, right: 1 }[e.labelAlign || r.attr("align")], d = r.getBBox().width, b = e.getSlotWidth(this), c = {};
            let k = b, w = 1, z;
            if (l || "justify" !== g2.overflow)
              0 > l && n2 - v * d < y ? z = Math.round(n2 / Math.cos(l * u) - y) : 0 < l && n2 + v * d > f && (z = Math.round((m2 - n2) / Math.cos(l * u)));
            else if (m2 = n2 + (1 - v) * d, n2 - v * d < y ? k = a3.x + k * (1 - v) - y : m2 > f && (k = f - a3.x + k * v, w = -1), k = Math.min(b, k), k < b && "center" === e.labelAlign && (a3.x += w * (b - k - v * (b - Math.min(d, k)))), d > k || e.autoRotation && (r.styles || {}).width)
              z = k;
            z && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(z) + "px", (g2.style || {}).textOverflow || (c.textOverflow = "ellipsis"), r.css(c)));
          }
          moveLabel(a3, g2) {
            const e = this;
            var h2 = e.label;
            const m2 = e.axis;
            let f = false;
            h2 && h2.textStr === a3 ? (e.movedLabel = h2, f = true, delete e.label) : n(m2.ticks, function(g3) {
              f || g3.isNew || g3 === e || !g3.label || g3.label.textStr !== a3 || (e.movedLabel = g3.label, f = true, g3.labelPos = e.movedLabel.xy, delete g3.label);
            });
            f || !e.labelPos && !h2 || (h2 = e.labelPos || h2.xy, e.movedLabel = e.createLabel(h2, a3, g2), e.movedLabel && e.movedLabel.attr({ opacity: 0 }));
          }
          render(a3, g2, n2) {
            var e = this.axis, m2 = e.horiz, f = this.pos, y = h(this.tickmarkOffset, e.tickmarkOffset);
            f = this.getPosition(m2, f, y, g2);
            y = f.x;
            const r = f.y;
            e = m2 && y === e.pos + e.len || !m2 && r === e.pos ? -1 : 1;
            m2 = h(n2, this.label && this.label.newOpacity, 1);
            n2 = h(n2, 1);
            this.isActive = true;
            this.renderGridLine(g2, n2, e);
            this.renderMark(f, n2, e);
            this.renderLabel(f, g2, m2, a3);
            this.isNew = false;
            q(this, "afterRender");
          }
          renderGridLine(a3, g2, n2) {
            const e = this.axis, m2 = e.options, f = {}, y = this.pos, r = this.type, l = h(this.tickmarkOffset, e.tickmarkOffset), v = e.chart.renderer;
            let d = this.gridLine, b = m2.gridLineWidth, c = m2.gridLineColor, k = m2.gridLineDashStyle;
            "minor" === this.type && (b = m2.minorGridLineWidth, c = m2.minorGridLineColor, k = m2.minorGridLineDashStyle);
            d || (e.chart.styledMode || (f.stroke = c, f["stroke-width"] = b || 0, f.dashstyle = k), r || (f.zIndex = 1), a3 && (g2 = 0), this.gridLine = d = v.path().attr(f).addClass("highcharts-" + (r ? r + "-" : "") + "grid-line").add(e.gridGroup));
            if (d && (n2 = e.getPlotLinePath({ value: y + l, lineWidth: d.strokeWidth() * n2, force: "pass", old: a3, acrossPanes: false })))
              d[a3 || this.isNew ? "attr" : "animate"]({ d: n2, opacity: g2 });
          }
          renderMark(a3, g2, n2) {
            const e = this.axis;
            var m2 = e.options;
            const f = e.chart.renderer, y = this.type, r = e.tickSize(y ? y + "Tick" : "tick"), l = a3.x;
            a3 = a3.y;
            const v = h(m2["minor" !== y ? "tickWidth" : "minorTickWidth"], !y && e.isXAxis ? 1 : 0);
            m2 = m2["minor" !== y ? "tickColor" : "minorTickColor"];
            let d = this.mark;
            const b = !d;
            r && (e.opposite && (r[0] = -r[0]), d || (this.mark = d = f.path().addClass("highcharts-" + (y ? y + "-" : "") + "tick").add(e.axisGroup), e.chart.styledMode || d.attr({ stroke: m2, "stroke-width": v })), d[b ? "attr" : "animate"]({ d: this.getMarkPath(l, a3, r[0], d.strokeWidth() * n2, e.horiz, f), opacity: g2 }));
          }
          renderLabel(a3, g2, n2, p2) {
            var e = this.axis;
            const f = e.horiz, y = e.options, r = this.label, l = y.labels, v = l.step;
            e = h(this.tickmarkOffset, e.tickmarkOffset);
            const d = a3.x;
            a3 = a3.y;
            let b = true;
            r && m(d) && (r.xy = a3 = this.getLabelPosition(d, a3, r, f, l, e, p2, v), this.isFirst && !this.isLast && !y.showFirstLabel || this.isLast && !this.isFirst && !y.showLastLabel ? b = false : !f || l.step || l.rotation || g2 || 0 === n2 || this.handleOverflow(a3), v && p2 % v && (b = false), b && m(a3.y) ? (a3.opacity = n2, r[this.isNewLabel ? "attr" : "animate"](a3).show(true), this.isNewLabel = false) : (r.hide(), this.isNewLabel = true));
          }
          replaceMovedLabel() {
            const a3 = this.label, g2 = this.axis;
            a3 && !this.isNew && (a3.animate({ opacity: 0 }, void 0, a3.destroy), delete this.label);
            g2.isDirty = true;
            this.label = this.movedLabel;
            delete this.movedLabel;
          }
        }
        "";
        return g;
      });
      L(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Defaults.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D, E, B) {
        const { animObject: t } = a2, { defaultOptions: q } = K, { registerEventOptions: m } = G, { deg2rad: p } = D, { arrayMax: n, arrayMin: h, clamp: g, correctFloat: e, defined: x, destroyObjectProperties: I, erase: u, error: C, extend: f, fireEvent: y, getClosestDistance: r, insertItem: l, isArray: v, isNumber: d, isString: b, merge: c, normalizeTickInterval: k, objectEach: w, pick: z, relativeLength: F, removeEvent: O, splat: P, syncTimeout: T } = B, U = (b2, c2) => k(c2, void 0, void 0, z(b2.options.allowDecimals, 0.5 > c2 || void 0 !== b2.tickAmount), !!b2.tickAmount);
        class W {
          constructor(b2, c2, d2) {
            this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.index = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
            this.init(b2, c2, d2);
          }
          init(b2, c2, k2 = this.coll) {
            const a3 = "xAxis" === k2;
            this.chart = b2;
            this.horiz = this.isZAxis || (b2.inverted ? !a3 : a3);
            this.isXAxis = a3;
            this.coll = k2;
            y(this, "init", { userOptions: c2 });
            this.opposite = z(c2.opposite, this.opposite);
            this.side = z(c2.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
            this.setOptions(c2);
            k2 = this.options;
            const f2 = k2.labels, e2 = k2.type;
            this.userOptions = c2;
            this.minPixelPadding = 0;
            this.reversed = z(k2.reversed, this.reversed);
            this.visible = k2.visible;
            this.zoomEnabled = k2.zoomEnabled;
            this.hasNames = "category" === e2 || true === k2.categories;
            this.categories = k2.categories || (this.hasNames ? [] : void 0);
            this.names || (this.names = [], this.names.keys = {});
            this.plotLinesAndBandsGroups = {};
            this.positiveValuesOnly = !!this.logarithmic;
            this.isLinked = x(k2.linkedTo);
            this.ticks = {};
            this.labelEdge = [];
            this.minorTicks = {};
            this.plotLinesAndBands = [];
            this.alternateBands = {};
            this.len = 0;
            this.minRange = this.userMinRange = k2.minRange || k2.maxZoom;
            this.range = k2.range;
            this.offset = k2.offset || 0;
            this.min = this.max = null;
            c2 = z(k2.crosshair, P(b2.options.tooltip.crosshairs)[a3 ? 0 : 1]);
            this.crosshair = true === c2 ? {} : c2;
            -1 === b2.axes.indexOf(this) && (a3 ? b2.axes.splice(b2.xAxis.length, 0, this) : b2.axes.push(this), l(this, b2[this.coll]));
            b2.orderItems(this.coll);
            this.series = this.series || [];
            b2.inverted && !this.isZAxis && a3 && "undefined" === typeof this.reversed && (this.reversed = true);
            this.labelRotation = d(f2.rotation) ? f2.rotation : void 0;
            m(this, k2);
            y(this, "afterInit");
          }
          setOptions(b2) {
            this.options = c(A.defaultXAxisOptions, "yAxis" === this.coll && A.defaultYAxisOptions, [A.defaultTopAxisOptions, A.defaultRightAxisOptions, A.defaultBottomAxisOptions, A.defaultLeftAxisOptions][this.side], c(q[this.coll], b2));
            y(this, "afterSetOptions", { userOptions: b2 });
          }
          defaultLabelFormatter(b2) {
            var c2 = this.axis;
            ({ numberFormatter: b2 } = this.chart);
            const k2 = d(this.value) ? this.value : NaN, a3 = c2.chart.time, f2 = this.dateTimeLabelFormat;
            var e2 = q.lang;
            const l2 = e2.numericSymbols;
            e2 = e2.numericSymbolMagnitude || 1e3;
            const H = c2.logarithmic ? Math.abs(k2) : c2.tickInterval;
            let w2 = l2 && l2.length, g2;
            if (c2.categories)
              g2 = `${this.value}`;
            else if (f2)
              g2 = a3.dateFormat(f2, k2);
            else if (w2 && 1e3 <= H)
              for (; w2-- && "undefined" === typeof g2; )
                c2 = Math.pow(e2, w2 + 1), H >= c2 && 0 === 10 * k2 % c2 && null !== l2[w2] && 0 !== k2 && (g2 = b2(k2 / c2, -1) + l2[w2]);
            "undefined" === typeof g2 && (g2 = 1e4 <= Math.abs(k2) ? b2(k2, -1) : b2(k2, -1, void 0, ""));
            return g2;
          }
          getSeriesExtremes() {
            const b2 = this, c2 = b2.chart;
            let k2;
            y(this, "getSeriesExtremes", null, function() {
              b2.hasVisibleSeries = false;
              b2.dataMin = b2.dataMax = b2.threshold = null;
              b2.softThreshold = !b2.isXAxis;
              b2.series.forEach(function(a3) {
                if (a3.visible || !c2.options.chart.ignoreHiddenSeries) {
                  var f2 = a3.options;
                  let c3 = f2.threshold, e2, l2;
                  b2.hasVisibleSeries = true;
                  b2.positiveValuesOnly && 0 >= c3 && (c3 = null);
                  if (b2.isXAxis)
                    (f2 = a3.xData) && f2.length && (f2 = b2.logarithmic ? f2.filter((b3) => 0 < b3) : f2, k2 = a3.getXExtremes(f2), e2 = k2.min, l2 = k2.max, d(e2) || e2 instanceof Date || (f2 = f2.filter(d), k2 = a3.getXExtremes(f2), e2 = k2.min, l2 = k2.max), f2.length && (b2.dataMin = Math.min(z(b2.dataMin, e2), e2), b2.dataMax = Math.max(z(
                      b2.dataMax,
                      l2
                    ), l2)));
                  else if (a3 = a3.applyExtremes(), d(a3.dataMin) && (e2 = a3.dataMin, b2.dataMin = Math.min(z(b2.dataMin, e2), e2)), d(a3.dataMax) && (l2 = a3.dataMax, b2.dataMax = Math.max(z(b2.dataMax, l2), l2)), x(c3) && (b2.threshold = c3), !f2.softThreshold || b2.positiveValuesOnly)
                    b2.softThreshold = false;
                }
              });
            });
            y(this, "afterGetSeriesExtremes");
          }
          translate(b2, c2, k2, a3, f2, l2) {
            const w2 = this.linkedParent || this, H = a3 && w2.old ? w2.old.min : w2.min;
            if (!d(H))
              return NaN;
            const g2 = w2.minPixelPadding;
            f2 = (w2.isOrdinal || w2.brokenAxis && w2.brokenAxis.hasBreaks || w2.logarithmic && f2) && w2.lin2val;
            let r2 = 1, z2 = 0;
            a3 = a3 && w2.old ? w2.old.transA : w2.transA;
            a3 || (a3 = w2.transA);
            k2 && (r2 *= -1, z2 = w2.len);
            w2.reversed && (r2 *= -1, z2 -= r2 * (w2.sector || w2.len));
            c2 ? (l2 = (b2 * r2 + z2 - g2) / a3 + H, f2 && (l2 = w2.lin2val(l2))) : (f2 && (b2 = w2.val2lin(b2)), b2 = r2 * (b2 - H) * a3, l2 = (w2.isRadial ? b2 : e(b2)) + z2 + r2 * g2 + (d(l2) ? a3 * l2 : 0));
            return l2;
          }
          toPixels(b2, c2) {
            return this.translate(b2, false, !this.horiz, void 0, true) + (c2 ? 0 : this.pos);
          }
          toValue(b2, c2) {
            return this.translate(b2 - (c2 ? 0 : this.pos), true, !this.horiz, void 0, true);
          }
          getPlotLinePath(b2) {
            function c2(b3, c3, d2) {
              "pass" !== n2 && (b3 < c3 || b3 > d2) && (n2 ? b3 = g(b3, c3, d2) : O2 = true);
              return b3;
            }
            const k2 = this, a3 = k2.chart, f2 = k2.left, e2 = k2.top, l2 = b2.old, w2 = b2.value, H = b2.lineWidth, r2 = l2 && a3.oldChartHeight || a3.chartHeight, v2 = l2 && a3.oldChartWidth || a3.chartWidth, F2 = k2.transB;
            let h2 = b2.translatedValue, n2 = b2.force, m2, x2, p2, q2, O2;
            b2 = { value: w2, lineWidth: H, old: l2, force: n2, acrossPanes: b2.acrossPanes, translatedValue: h2 };
            y(this, "getPlotLinePath", b2, function(b3) {
              h2 = z(h2, k2.translate(w2, void 0, void 0, l2));
              h2 = g(h2, -1e5, 1e5);
              m2 = p2 = Math.round(h2 + F2);
              x2 = q2 = Math.round(r2 - h2 - F2);
              d(h2) ? k2.horiz ? (x2 = e2, q2 = r2 - k2.bottom, m2 = p2 = c2(m2, f2, f2 + k2.width)) : (m2 = f2, p2 = v2 - k2.right, x2 = q2 = c2(x2, e2, e2 + k2.height)) : (O2 = true, n2 = false);
              b3.path = O2 && !n2 ? null : a3.renderer.crispLine([["M", m2, x2], ["L", p2, q2]], H || 1);
            });
            return b2.path;
          }
          getLinearTickPositions(b2, c2, d2) {
            const k2 = e(Math.floor(c2 / b2) * b2);
            d2 = e(Math.ceil(d2 / b2) * b2);
            const a3 = [];
            let f2, l2;
            e(k2 + b2) === k2 && (l2 = 20);
            if (this.single)
              return [c2];
            for (c2 = k2; c2 <= d2; ) {
              a3.push(c2);
              c2 = e(c2 + b2, l2);
              if (c2 === f2)
                break;
              f2 = c2;
            }
            return a3;
          }
          getMinorTickInterval() {
            const b2 = this.options;
            return true === b2.minorTicks ? z(b2.minorTickInterval, "auto") : false === b2.minorTicks ? null : b2.minorTickInterval;
          }
          getMinorTickPositions() {
            var b2 = this.options;
            const c2 = this.tickPositions, d2 = this.minorTickInterval;
            var k2 = this.pointRangePadding || 0;
            const a3 = this.min - k2;
            k2 = this.max + k2;
            const f2 = k2 - a3;
            let l2 = [];
            if (f2 && f2 / d2 < this.len / 3) {
              const f3 = this.logarithmic;
              if (f3)
                this.paddedTicks.forEach(function(b3, c3, k3) {
                  c3 && l2.push.apply(l2, f3.getLogTickPositions(d2, k3[c3 - 1], k3[c3], true));
                });
              else if (this.dateTime && "auto" === this.getMinorTickInterval())
                l2 = l2.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(d2), a3, k2, b2.startOfWeek));
              else
                for (b2 = a3 + (c2[0] - a3) % d2; b2 <= k2 && b2 !== l2[0]; b2 += d2)
                  l2.push(b2);
            }
            0 !== l2.length && this.trimTicks(l2);
            return l2;
          }
          adjustForMinRange() {
            const b2 = this.options, c2 = this.logarithmic;
            let d2 = this.min;
            var k2 = this.max;
            let a3, f2;
            if (this.isXAxis && "undefined" === typeof this.minRange && !c2)
              if (x(b2.min) || x(b2.max) || x(b2.floor) || x(b2.ceiling))
                this.minRange = null;
              else {
                var l2 = r(this.series.map((b3) => {
                  var c3;
                  return (b3.xIncrement ? null === (c3 = b3.xData) || void 0 === c3 ? void 0 : c3.slice(0, 2) : b3.xData) || [];
                })) || 0;
                this.minRange = Math.min(5 * l2, this.dataMax - this.dataMin);
              }
            k2 - d2 < this.minRange && (l2 = this.dataMax - this.dataMin >= this.minRange, f2 = this.minRange, k2 = (f2 - k2 + d2) / 2, a3 = [d2 - k2, z(b2.min, d2 - k2)], l2 && (a3[2] = c2 ? c2.log2lin(this.dataMin) : this.dataMin), d2 = n(a3), k2 = [d2 + f2, z(b2.max, d2 + f2)], l2 && (k2[2] = c2 ? c2.log2lin(this.dataMax) : this.dataMax), k2 = h(k2), k2 - d2 < f2 && (a3[0] = k2 - f2, a3[1] = z(b2.min, k2 - f2), d2 = n(a3)));
            this.min = d2;
            this.max = k2;
          }
          getClosest() {
            let b2, c2;
            if (this.categories)
              c2 = 1;
            else {
              const d2 = [];
              this.series.forEach(function(b3) {
                var k2;
                const a3 = b3.closestPointRange, f2 = b3.visible || !b3.chart.options.chart.ignoreHiddenSeries;
                1 === (null === (k2 = b3.xData) || void 0 === k2 ? void 0 : k2.length) ? d2.push(b3.xData[0]) : !b3.noSharedTooltip && x(a3) && f2 && (c2 = x(c2) ? Math.min(c2, a3) : a3);
              });
              d2.length && (d2.sort((b3, c3) => b3 - c3), b2 = r([d2]));
            }
            return b2 && c2 ? Math.min(b2, c2) : b2 || c2;
          }
          nameToX(b2) {
            const c2 = v(this.options.categories), d2 = c2 ? this.categories : this.names;
            let k2 = b2.options.x, a3;
            b2.series.requireSorting = false;
            x(k2) || (k2 = this.options.uniqueNames && d2 ? c2 ? d2.indexOf(b2.name) : z(d2.keys[b2.name], -1) : b2.series.autoIncrement());
            -1 === k2 ? !c2 && d2 && (a3 = d2.length) : a3 = k2;
            "undefined" !== typeof a3 ? (this.names[a3] = b2.name, this.names.keys[b2.name] = a3) : b2.x && (a3 = b2.x);
            return a3;
          }
          updateNames() {
            const b2 = this, c2 = this.names;
            0 < c2.length && (Object.keys(c2.keys).forEach(function(b3) {
              delete c2.keys[b3];
            }), c2.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(c3) {
              c3.xIncrement = null;
              if (!c3.points || c3.isDirtyData)
                b2.max = Math.max(b2.max, c3.xData.length - 1), c3.processData(), c3.generatePoints();
              c3.data.forEach(function(d2, k2) {
                let a3;
                d2 && d2.options && "undefined" !== typeof d2.name && (a3 = b2.nameToX(d2), "undefined" !== typeof a3 && a3 !== d2.x && (d2.x = a3, c3.xData[k2] = a3));
              });
            }));
          }
          setAxisTranslation() {
            const c2 = this, d2 = c2.max - c2.min;
            var k2 = c2.linkedParent;
            const a3 = !!c2.categories, f2 = c2.isXAxis;
            let l2 = c2.axisPointRange || 0, e2, w2 = 0, g2 = 0, r2 = c2.transA;
            if (f2 || a3 || l2)
              e2 = c2.getClosest(), k2 ? (w2 = k2.minPointOffset, g2 = k2.pointRangePadding) : c2.series.forEach(function(d3) {
                const k3 = a3 ? 1 : f2 ? z(d3.options.pointRange, e2, 0) : c2.axisPointRange || 0, r3 = d3.options.pointPlacement;
                l2 = Math.max(l2, k3);
                if (!c2.single || a3)
                  d3 = d3.is("xrange") ? !f2 : f2, w2 = Math.max(w2, d3 && b(r3) ? 0 : k3 / 2), g2 = Math.max(g2, d3 && "on" === r3 ? 0 : k3);
              }), k2 = c2.ordinal && c2.ordinal.slope && e2 ? c2.ordinal.slope / e2 : 1, c2.minPointOffset = w2 *= k2, c2.pointRangePadding = g2 *= k2, c2.pointRange = Math.min(l2, c2.single && a3 ? 1 : d2), f2 && e2 && (c2.closestPointRange = e2);
            c2.translationSlope = c2.transA = r2 = c2.staticScale || c2.len / (d2 + g2 || 1);
            c2.transB = c2.horiz ? c2.left : c2.bottom;
            c2.minPixelPadding = r2 * w2;
            y(this, "afterSetAxisTranslation");
          }
          minFromRange() {
            return this.max - this.range;
          }
          setTickInterval(b2) {
            var c2 = this.chart;
            const k2 = this.logarithmic, a3 = this.options, f2 = this.isXAxis, l2 = this.isLinked, w2 = a3.tickPixelInterval, g2 = this.categories, r2 = this.softThreshold;
            let v2 = a3.maxPadding, F2 = a3.minPadding;
            let h2 = d(a3.tickInterval) && 0 <= a3.tickInterval ? a3.tickInterval : void 0, H = d(this.threshold) ? this.threshold : null, n2, m2, p2;
            this.dateTime || g2 || l2 || this.getTickAmount();
            m2 = z(this.userMin, a3.min);
            p2 = z(this.userMax, a3.max);
            if (l2) {
              this.linkedParent = c2[this.coll][a3.linkedTo];
              var q2 = this.linkedParent.getExtremes();
              this.min = z(q2.min, q2.dataMin);
              this.max = z(q2.max, q2.dataMax);
              a3.type !== this.linkedParent.options.type && C(11, 1, c2);
            } else
              r2 && x(H) && (this.dataMin >= H ? (q2 = H, F2 = 0) : this.dataMax <= H && (n2 = H, v2 = 0)), this.min = z(m2, q2, this.dataMin), this.max = z(p2, n2, this.dataMax);
            k2 && (this.positiveValuesOnly && !b2 && 0 >= Math.min(this.min, z(
              this.dataMin,
              this.min
            )) && C(10, 1, c2), this.min = e(k2.log2lin(this.min), 16), this.max = e(k2.log2lin(this.max), 16));
            this.range && x(this.max) && (this.userMin = this.min = m2 = Math.max(this.dataMin, this.minFromRange()), this.userMax = p2 = this.max, this.range = null);
            y(this, "foundExtremes");
            this.beforePadding && this.beforePadding();
            this.adjustForMinRange();
            !d(this.userMin) && d(a3.softMin) && a3.softMin < this.min && (this.min = m2 = a3.softMin);
            !d(this.userMax) && d(a3.softMax) && a3.softMax > this.max && (this.max = p2 = a3.softMax);
            !(g2 || this.axisPointRange || this.stacking && this.stacking.usePercentage || l2) && x(this.min) && x(this.max) && (c2 = this.max - this.min) && (!x(m2) && F2 && (this.min -= c2 * F2), !x(p2) && v2 && (this.max += c2 * v2));
            !d(this.userMin) && d(a3.floor) && (this.min = Math.max(this.min, a3.floor));
            !d(this.userMax) && d(a3.ceiling) && (this.max = Math.min(this.max, a3.ceiling));
            r2 && x(this.dataMin) && (H = H || 0, !x(m2) && this.min < H && this.dataMin >= H ? this.min = this.options.minRange ? Math.min(H, this.max - this.minRange) : H : !x(p2) && this.max > H && this.dataMax <= H && (this.max = this.options.minRange ? Math.max(H, this.min + this.minRange) : H));
            d(this.min) && d(this.max) && !this.chart.polar && this.min > this.max && (x(this.options.min) ? this.max = this.min : x(this.options.max) && (this.min = this.max));
            this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : l2 && this.linkedParent && !h2 && w2 === this.linkedParent.options.tickPixelInterval ? h2 = this.linkedParent.tickInterval : z(h2, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, g2 ? 1 : (this.max - this.min) * w2 / Math.max(this.len, w2));
            if (f2 && !b2) {
              const b3 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
              this.series.forEach(function(c3) {
                c3.forceCrop = c3.forceCropping && c3.forceCropping();
                c3.processData(b3);
              });
              y(this, "postProcessData", { hasExtremesChanged: b3 });
            }
            this.setAxisTranslation();
            y(this, "initialAxisTranslation");
            this.pointRange && !h2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
            b2 = z(a3.minTickInterval, this.dateTime && !this.series.some((b3) => b3.noSharedTooltip) ? this.closestPointRange : 0);
            !h2 && this.tickInterval < b2 && (this.tickInterval = b2);
            this.dateTime || this.logarithmic || h2 || (this.tickInterval = U(this, this.tickInterval));
            this.tickAmount || (this.tickInterval = this.unsquish());
            this.setTickPositions();
          }
          setTickPositions() {
            var b2 = this.options;
            const c2 = b2.tickPositions, k2 = b2.tickPositioner;
            var a3 = this.getMinorTickInterval(), f2 = this.hasVerticalPanning(), l2 = "colorAxis" === this.coll;
            const e2 = (l2 || !f2) && b2.startOnTick;
            f2 = (l2 || !f2) && b2.endOnTick;
            l2 = [];
            let w2;
            this.tickmarkOffset = this.categories && "between" === b2.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0;
            this.minorTickInterval = "auto" === a3 && this.tickInterval ? this.tickInterval / b2.minorTicksPerMajor : a3;
            this.single = this.min === this.max && x(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || false !== b2.allowDecimals);
            if (c2)
              l2 = c2.slice();
            else if (d(this.min) && d(this.max)) {
              if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)))
                if (this.dateTime)
                  l2 = this.getTimeTicks(
                    this.dateTime.normalizeTimeTickInterval(this.tickInterval, b2.units),
                    this.min,
                    this.max,
                    b2.startOfWeek,
                    this.ordinal && this.ordinal.positions,
                    this.closestPointRange,
                    true
                  );
                else if (this.logarithmic)
                  l2 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                else
                  for (a3 = b2 = this.tickInterval; a3 <= 2 * b2; )
                    if (l2 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && l2.length > this.tickAmount)
                      this.tickInterval = U(this, a3 *= 1.1);
                    else
                      break;
              else
                l2 = [this.min, this.max], C(19, false, this.chart);
              l2.length > this.len && (l2 = [l2[0], l2[l2.length - 1]], l2[0] === l2[1] && (l2.length = 1));
              k2 && (this.tickPositions = l2, (w2 = k2.apply(this, [this.min, this.max])) && (l2 = w2));
            }
            this.tickPositions = l2;
            this.paddedTicks = l2.slice(0);
            this.trimTicks(l2, e2, f2);
            !this.isLinked && d(this.min) && d(this.max) && (this.single && 2 > l2.length && !this.categories && !this.series.some((b3) => b3.is("heatmap") && "between" === b3.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), c2 || w2 || this.adjustTickAmount());
            y(this, "afterSetTickPositions");
          }
          trimTicks(b2, c2, d2) {
            const k2 = b2[0], a3 = b2[b2.length - 1], f2 = !this.isOrdinal && this.minPointOffset || 0;
            y(this, "trimTicks");
            if (!this.isLinked) {
              if (c2 && -Infinity !== k2)
                this.min = k2;
              else
                for (; this.min - f2 > b2[0]; )
                  b2.shift();
              if (d2)
                this.max = a3;
              else
                for (; this.max + f2 < b2[b2.length - 1]; )
                  b2.pop();
              0 === b2.length && x(k2) && !this.options.tickPositions && b2.push((a3 + k2) / 2);
            }
          }
          alignToOthers() {
            const b2 = this, c2 = [this], k2 = b2.options, a3 = "yAxis" === this.coll && this.chart.options.chart.alignThresholds, f2 = [];
            let l2;
            b2.thresholdAlignment = void 0;
            if ((false !== this.chart.options.chart.alignTicks && k2.alignTicks || a3) && false !== k2.startOnTick && false !== k2.endOnTick && !b2.logarithmic) {
              const d2 = (b3) => {
                const { horiz: c3, options: d3 } = b3;
                return [c3 ? d3.left : d3.top, d3.width, d3.height, d3.pane].join();
              }, k3 = d2(this);
              this.chart[this.coll].forEach(function(a4) {
                const { series: f3 } = a4;
                f3.length && f3.some((b3) => b3.visible) && a4 !== b2 && d2(a4) === k3 && (l2 = true, c2.push(a4));
              });
            }
            if (l2 && a3) {
              c2.forEach((c3) => {
                c3 = c3.getThresholdAlignment(b2);
                d(c3) && f2.push(c3);
              });
              const k3 = 1 < f2.length ? f2.reduce((b3, c3) => b3 + c3, 0) / f2.length : void 0;
              c2.forEach((b3) => {
                b3.thresholdAlignment = k3;
              });
            }
            return l2;
          }
          getThresholdAlignment(b2) {
            (!d(this.dataMin) || this !== b2 && this.series.some((b3) => b3.isDirty || b3.isDirtyData)) && this.getSeriesExtremes();
            if (d(this.threshold))
              return b2 = g((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b2 = 1 - b2), b2;
          }
          getTickAmount() {
            const b2 = this.options, c2 = b2.tickPixelInterval;
            let d2 = b2.tickAmount;
            !x(b2.tickInterval) && !d2 && this.len < c2 && !this.isRadial && !this.logarithmic && b2.startOnTick && b2.endOnTick && (d2 = 2);
            !d2 && this.alignToOthers() && (d2 = Math.ceil(this.len / c2) + 1);
            4 > d2 && (this.finalTickAmt = d2, d2 = 5);
            this.tickAmount = d2;
          }
          adjustTickAmount() {
            const b2 = this, { finalTickAmt: c2, max: k2, min: a3, options: f2, tickPositions: l2, tickAmount: w2, thresholdAlignment: g2 } = b2, r2 = l2 && l2.length;
            var v2 = z(b2.threshold, b2.softThreshold ? 0 : null);
            var F2 = b2.tickInterval;
            let h2;
            d(g2) && (h2 = 0.5 > g2 ? Math.ceil(g2 * (w2 - 1)) : Math.floor(g2 * (w2 - 1)), f2.reversed && (h2 = w2 - 1 - h2));
            if (b2.hasData() && d(a3) && d(k2)) {
              const g3 = () => {
                b2.transA *= (r2 - 1) / (w2 - 1);
                b2.min = f2.startOnTick ? l2[0] : Math.min(a3, l2[0]);
                b2.max = f2.endOnTick ? l2[l2.length - 1] : Math.max(k2, l2[l2.length - 1]);
              };
              if (d(h2) && d(b2.threshold)) {
                for (; l2[h2] !== v2 || l2.length !== w2 || l2[0] > a3 || l2[l2.length - 1] < k2; ) {
                  l2.length = 0;
                  for (l2.push(b2.threshold); l2.length < w2; )
                    void 0 === l2[h2] || l2[h2] > b2.threshold ? l2.unshift(e(l2[0] - F2)) : l2.push(e(l2[l2.length - 1] + F2));
                  if (F2 > 8 * b2.tickInterval)
                    break;
                  F2 *= 2;
                }
                g3();
              } else if (r2 < w2) {
                for (; l2.length < w2; )
                  l2.length % 2 || a3 === v2 ? l2.push(e(l2[l2.length - 1] + F2)) : l2.unshift(e(l2[0] - F2));
                g3();
              }
              if (x(c2)) {
                for (F2 = v2 = l2.length; F2--; )
                  (3 === c2 && 1 === F2 % 2 || 2 >= c2 && 0 < F2 && F2 < v2 - 1) && l2.splice(F2, 1);
                b2.finalTickAmt = void 0;
              }
            }
          }
          setScale() {
            let b2 = false, c2 = false;
            this.series.forEach(function(d3) {
              b2 = b2 || d3.isDirtyData || d3.isDirty;
              c2 = c2 || d3.xAxis && d3.xAxis.isDirty || false;
            });
            this.setAxisSize();
            const d2 = this.len !== (this.old && this.old.len);
            d2 || b2 || c2 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = d2 || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
            b2 && this.panningState && (this.panningState.isDirty = true);
            y(this, "afterSetScale");
          }
          setExtremes(b2, c2, d2, k2, a3) {
            const l2 = this, e2 = l2.chart;
            d2 = z(d2, true);
            l2.series.forEach(function(b3) {
              delete b3.kdTree;
            });
            a3 = f(a3, { min: b2, max: c2 });
            y(l2, "setExtremes", a3, function() {
              l2.userMin = b2;
              l2.userMax = c2;
              l2.eventArgs = a3;
              d2 && e2.redraw(k2);
            });
          }
          zoom(b2, c2) {
            const d2 = this, k2 = this.dataMin, a3 = this.dataMax, f2 = this.options, l2 = Math.min(k2, z(f2.min, k2)), e2 = Math.max(a3, z(f2.max, a3));
            b2 = { newMin: b2, newMax: c2 };
            y(this, "zoom", b2, function(b3) {
              let c3 = b3.newMin, f3 = b3.newMax;
              if (c3 !== d2.min || f3 !== d2.max)
                d2.allowZoomOutside || (x(k2) && (c3 < l2 && (c3 = l2), c3 > e2 && (c3 = e2)), x(a3) && (f3 < l2 && (f3 = l2), f3 > e2 && (f3 = e2))), d2.displayBtn = "undefined" !== typeof c3 || "undefined" !== typeof f3, d2.setExtremes(c3, f3, false, void 0, { trigger: "zoom" });
              b3.zoomed = true;
            });
            return b2.zoomed;
          }
          setAxisSize() {
            const b2 = this.chart;
            var c2 = this.options;
            const d2 = c2.offsets || [0, 0, 0, 0], k2 = this.horiz, a3 = this.width = Math.round(F(z(c2.width, b2.plotWidth - d2[3] + d2[1]), b2.plotWidth)), f2 = this.height = Math.round(F(z(c2.height, b2.plotHeight - d2[0] + d2[2]), b2.plotHeight)), l2 = this.top = Math.round(F(z(c2.top, b2.plotTop + d2[0]), b2.plotHeight, b2.plotTop));
            c2 = this.left = Math.round(F(
              z(c2.left, b2.plotLeft + d2[3]),
              b2.plotWidth,
              b2.plotLeft
            ));
            this.bottom = b2.chartHeight - f2 - l2;
            this.right = b2.chartWidth - a3 - c2;
            this.len = Math.max(k2 ? a3 : f2, 0);
            this.pos = k2 ? c2 : l2;
          }
          getExtremes() {
            const b2 = this.logarithmic;
            return { min: b2 ? e(b2.lin2log(this.min)) : this.min, max: b2 ? e(b2.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
          }
          getThreshold(b2) {
            var c2 = this.logarithmic;
            const d2 = c2 ? c2.lin2log(this.min) : this.min;
            c2 = c2 ? c2.lin2log(this.max) : this.max;
            null === b2 || -Infinity === b2 ? b2 = d2 : Infinity === b2 ? b2 = c2 : d2 > b2 ? b2 = d2 : c2 < b2 && (b2 = c2);
            return this.translate(
              b2,
              0,
              1,
              0,
              1
            );
          }
          autoLabelAlign(b2) {
            const c2 = (z(b2, 0) - 90 * this.side + 720) % 360;
            b2 = { align: "center" };
            y(this, "autoLabelAlign", b2, function(b3) {
              15 < c2 && 165 > c2 ? b3.align = "right" : 195 < c2 && 345 > c2 && (b3.align = "left");
            });
            return b2.align;
          }
          tickSize(b2) {
            const c2 = this.options, d2 = z(c2["tick" === b2 ? "tickWidth" : "minorTickWidth"], "tick" === b2 && this.isXAxis && !this.categories ? 1 : 0);
            let k2 = c2["tick" === b2 ? "tickLength" : "minorTickLength"], a3;
            d2 && k2 && ("inside" === c2[b2 + "Position"] && (k2 = -k2), a3 = [k2, d2]);
            b2 = { tickSize: a3 };
            y(this, "afterTickSize", b2);
            return b2.tickSize;
          }
          labelMetrics() {
            const b2 = this.chart.renderer;
            var c2 = this.ticks;
            c2 = c2[Object.keys(c2)[0]] || {};
            return this.chart.renderer.fontMetrics(c2.label || c2.movedLabel || b2.box);
          }
          unsquish() {
            const b2 = this.options.labels;
            var c2 = this.horiz;
            const k2 = this.tickInterval, a3 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / k2), f2 = b2.rotation, l2 = 0.75 * this.labelMetrics().h, w2 = Math.max(this.max - this.min, 0), g2 = function(b3) {
              let c3 = b3 / (a3 || 1);
              c3 = 1 < c3 ? Math.ceil(c3) : 1;
              c3 * k2 > w2 && Infinity !== b3 && Infinity !== a3 && w2 && (c3 = Math.ceil(w2 / k2));
              return e(c3 * k2);
            };
            let r2 = k2, v2, F2 = Number.MAX_VALUE, h2;
            if (c2) {
              if (b2.staggerLines || (d(f2) ? h2 = [f2] : a3 < b2.autoRotationLimit && (h2 = b2.autoRotation)), h2) {
                let b3;
                for (const d2 of h2)
                  if (d2 === f2 || d2 && -90 <= d2 && 90 >= d2)
                    c2 = g2(Math.abs(l2 / Math.sin(p * d2))), b3 = c2 + Math.abs(d2 / 360), b3 < F2 && (F2 = b3, v2 = d2, r2 = c2);
              }
            } else
              r2 = g2(l2);
            this.autoRotation = h2;
            this.labelRotation = z(v2, d(f2) ? f2 : 0);
            return b2.step ? k2 : r2;
          }
          getSlotWidth(b2) {
            const c2 = this.chart, k2 = this.horiz, a3 = this.options.labels, f2 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), l2 = c2.margin[3];
            if (b2 && d(b2.slotWidth))
              return b2.slotWidth;
            if (k2 && 2 > a3.step)
              return a3.rotation ? 0 : (this.staggerLines || 1) * this.len / f2;
            if (!k2) {
              b2 = a3.style.width;
              if (void 0 !== b2)
                return parseInt(String(b2), 10);
              if (l2)
                return l2 - c2.spacing[3];
            }
            return 0.33 * c2.chartWidth;
          }
          renderUnsquish() {
            const c2 = this.chart, d2 = c2.renderer, k2 = this.tickPositions, a3 = this.ticks, f2 = this.options.labels, l2 = f2.style, e2 = this.horiz, w2 = this.getSlotWidth();
            var g2 = Math.max(1, Math.round(w2 - 2 * f2.padding));
            const r2 = {}, z2 = this.labelMetrics(), v2 = l2.textOverflow;
            let F2, h2, y2 = 0;
            b(f2.rotation) || (r2.rotation = f2.rotation || 0);
            k2.forEach(function(b2) {
              b2 = a3[b2];
              b2.movedLabel && b2.replaceMovedLabel();
              b2 && b2.label && b2.label.textPxLength > y2 && (y2 = b2.label.textPxLength);
            });
            this.maxLabelLength = y2;
            if (this.autoRotation)
              y2 > g2 && y2 > z2.h ? r2.rotation = this.labelRotation : this.labelRotation = 0;
            else if (w2 && (F2 = g2, !v2))
              for (h2 = "clip", g2 = k2.length; !e2 && g2--; ) {
                var n2 = k2[g2];
                if (n2 = a3[n2].label)
                  n2.styles && "ellipsis" === n2.styles.textOverflow ? n2.css({ textOverflow: "clip" }) : n2.textPxLength > w2 && n2.css({ width: w2 + "px" }), n2.getBBox().height > this.len / k2.length - (z2.h - z2.f) && (n2.specificTextOverflow = "ellipsis");
              }
            r2.rotation && (F2 = y2 > 0.5 * c2.chartHeight ? 0.33 * c2.chartHeight : y2, v2 || (h2 = "ellipsis"));
            if (this.labelAlign = f2.align || this.autoLabelAlign(this.labelRotation))
              r2.align = this.labelAlign;
            k2.forEach(function(b2) {
              const c3 = (b2 = a3[b2]) && b2.label, d3 = l2.width, k3 = {};
              c3 && (c3.attr(r2), b2.shortenLabel ? b2.shortenLabel() : F2 && !d3 && "nowrap" !== l2.whiteSpace && (F2 < c3.textPxLength || "SPAN" === c3.element.tagName) ? (k3.width = F2 + "px", v2 || (k3.textOverflow = c3.specificTextOverflow || h2), c3.css(k3)) : c3.styles && c3.styles.width && !k3.width && !d3 && c3.css({ width: null }), delete c3.specificTextOverflow, b2.rotation = r2.rotation);
            }, this);
            this.tickRotCorr = d2.rotCorr(
              z2.b,
              this.labelRotation || 0,
              0 !== this.side
            );
          }
          hasData() {
            return this.series.some(function(b2) {
              return b2.hasData();
            }) || this.options.showEmpty && x(this.min) && x(this.max);
          }
          addTitle(b2) {
            const d2 = this.chart.renderer, k2 = this.horiz, a3 = this.opposite, f2 = this.options.title, l2 = this.chart.styledMode;
            let e2;
            this.axisTitle || ((e2 = f2.textAlign) || (e2 = (k2 ? { low: "left", middle: "center", high: "right" } : { low: a3 ? "right" : "left", middle: "center", high: a3 ? "left" : "right" })[f2.align]), this.axisTitle = d2.text(f2.text || "", 0, 0, f2.useHTML).attr({
              zIndex: 7,
              rotation: f2.rotation,
              align: e2
            }).addClass("highcharts-axis-title"), l2 || this.axisTitle.css(c(f2.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true);
            l2 || f2.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" });
            this.axisTitle[b2 ? "show" : "hide"](b2);
          }
          generateTick(b2) {
            const c2 = this.ticks;
            c2[b2] ? c2[b2].addLabel() : c2[b2] = new E(this, b2);
          }
          getOffset() {
            const b2 = this, { chart: c2, horiz: k2, options: a3, side: f2, ticks: l2, tickPositions: e2, coll: g2, axisParent: r2 } = b2, v2 = c2.renderer, F2 = c2.inverted && !b2.isZAxis ? [1, 0, 3, 2][f2] : f2;
            var h2 = b2.hasData();
            const n2 = a3.title;
            var m2 = a3.labels;
            const p2 = d(a3.crossing);
            var q2 = c2.axisOffset;
            const O2 = c2.clipOffset, I2 = [-1, 1, 1, -1][f2], t2 = a3.className;
            let P2, T2 = 0, u2;
            var C2 = 0;
            let M = 0;
            b2.showAxis = P2 = h2 || a3.showEmpty;
            b2.staggerLines = b2.horiz && m2.staggerLines || void 0;
            if (!b2.axisGroup) {
              const c3 = (b3, c4, d2) => v2.g(b3).attr({ zIndex: d2 }).addClass(`highcharts-${g2.toLowerCase()}${c4} ` + (this.isRadial ? `highcharts-radial-axis${c4} ` : "") + (t2 || "")).add(r2);
              b2.gridGroup = c3("grid", "-grid", a3.gridZIndex);
              b2.axisGroup = c3("axis", "", a3.zIndex);
              b2.labelGroup = c3(
                "axis-labels",
                "-labels",
                m2.zIndex
              );
            }
            h2 || b2.isLinked ? (e2.forEach(function(c3) {
              b2.generateTick(c3);
            }), b2.renderUnsquish(), b2.reserveSpaceDefault = 0 === f2 || 2 === f2 || { 1: "left", 3: "right" }[f2] === b2.labelAlign, z(m2.reserveSpace, p2 ? false : null, "center" === b2.labelAlign ? true : null, b2.reserveSpaceDefault) && e2.forEach(function(b3) {
              M = Math.max(l2[b3].getLabelSize(), M);
            }), b2.staggerLines && (M *= b2.staggerLines), b2.labelOffset = M * (b2.opposite ? -1 : 1)) : w(l2, function(b3, c3) {
              b3.destroy();
              delete l2[c3];
            });
            n2 && n2.text && false !== n2.enabled && (b2.addTitle(P2), P2 && !p2 && false !== n2.reserveSpace && (b2.titleOffset = T2 = b2.axisTitle.getBBox()[k2 ? "height" : "width"], u2 = n2.offset, C2 = x(u2) ? 0 : z(n2.margin, k2 ? 5 : 10)));
            b2.renderLine();
            b2.offset = I2 * z(a3.offset, q2[f2] ? q2[f2] + (a3.margin || 0) : 0);
            b2.tickRotCorr = b2.tickRotCorr || { x: 0, y: 0 };
            h2 = 0 === f2 ? -b2.labelMetrics().h : 2 === f2 ? b2.tickRotCorr.y : 0;
            C2 = Math.abs(M) + C2;
            M && (C2 = C2 - h2 + I2 * (k2 ? z(m2.y, b2.tickRotCorr.y + I2 * m2.distance) : z(m2.x, I2 * m2.distance)));
            b2.axisTitleMargin = z(u2, C2);
            b2.getMaxLabelDimensions && (b2.maxLabelDimensions = b2.getMaxLabelDimensions(l2, e2));
            "colorAxis" !== g2 && (m2 = this.tickSize("tick"), q2[f2] = Math.max(q2[f2], (b2.axisTitleMargin || 0) + T2 + I2 * b2.offset, C2, e2 && e2.length && m2 ? m2[0] + I2 * b2.offset : 0), q2 = !b2.axisLine || a3.offset ? 0 : 2 * Math.floor(b2.axisLine.strokeWidth() / 2), O2[F2] = Math.max(O2[F2], q2));
            y(this, "afterGetOffset");
          }
          getLinePath(b2) {
            const c2 = this.chart, d2 = this.opposite;
            var k2 = this.offset;
            const a3 = this.horiz, f2 = this.left + (d2 ? this.width : 0) + k2;
            k2 = c2.chartHeight - this.bottom - (d2 ? this.height : 0) + k2;
            d2 && (b2 *= -1);
            return c2.renderer.crispLine([["M", a3 ? this.left : f2, a3 ? k2 : this.top], ["L", a3 ? c2.chartWidth - this.right : f2, a3 ? k2 : c2.chartHeight - this.bottom]], b2);
          }
          renderLine() {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
          }
          getTitlePosition(b2) {
            var c2 = this.horiz, d2 = this.left;
            const k2 = this.top;
            var a3 = this.len;
            const f2 = this.options.title, l2 = c2 ? d2 : k2, e2 = this.opposite, w2 = this.offset, g2 = f2.x, r2 = f2.y, z2 = this.chart.renderer.fontMetrics(b2);
            b2 = b2 ? Math.max(b2.getBBox(false, 0).height - z2.h - 1, 0) : 0;
            a3 = { low: l2 + (c2 ? 0 : a3), middle: l2 + a3 / 2, high: l2 + (c2 ? a3 : 0) }[f2.align];
            d2 = (c2 ? k2 + this.height : d2) + (c2 ? 1 : -1) * (e2 ? -1 : 1) * (this.axisTitleMargin || 0) + [-b2, b2, z2.f, -b2][this.side];
            c2 = { x: c2 ? a3 + g2 : d2 + (e2 ? this.width : 0) + w2 + g2, y: c2 ? d2 + r2 - (e2 ? this.height : 0) + w2 : a3 + r2 };
            y(this, "afterGetTitlePosition", { titlePosition: c2 });
            return c2;
          }
          renderMinorTick(b2, c2) {
            const d2 = this.minorTicks;
            d2[b2] || (d2[b2] = new E(this, b2, "minor"));
            c2 && d2[b2].isNew && d2[b2].render(null, true);
            d2[b2].render(null, false, 1);
          }
          renderTick(b2, c2, d2) {
            const k2 = this.ticks;
            if (!this.isLinked || b2 >= this.min && b2 <= this.max || this.grid && this.grid.isColumn)
              k2[b2] || (k2[b2] = new E(
                this,
                b2
              )), d2 && k2[b2].isNew && k2[b2].render(c2, true, -1), k2[b2].render(c2);
          }
          render() {
            const b2 = this, c2 = b2.chart, k2 = b2.logarithmic, a3 = b2.options, f2 = b2.isLinked, l2 = b2.tickPositions, e2 = b2.axisTitle, g2 = b2.ticks, r2 = b2.minorTicks, z2 = b2.alternateBands, v2 = a3.stackLabels, F2 = a3.alternateGridColor;
            var h2 = a3.crossing;
            const n2 = b2.tickmarkOffset, m2 = b2.axisLine, x2 = b2.showAxis, p2 = t(c2.renderer.globalAnimation);
            let q2, O2;
            b2.labelEdge.length = 0;
            b2.overlap = false;
            [g2, r2, z2].forEach(function(b3) {
              w(b3, function(b4) {
                b4.isActive = false;
              });
            });
            if (d(h2)) {
              const d2 = this.isXAxis ? c2.yAxis[0] : c2.xAxis[0], k3 = [1, -1, -1, 1][this.side];
              d2 && (h2 = d2.toPixels(h2, true), b2.horiz && (h2 = d2.len - h2), b2.offset = k3 * h2);
            }
            if (b2.hasData() || f2) {
              const f3 = b2.chart.hasRendered && b2.old && d(b2.old.min);
              b2.minorTickInterval && !b2.categories && b2.getMinorTickPositions().forEach(function(c3) {
                b2.renderMinorTick(c3, f3);
              });
              l2.length && (l2.forEach(function(c3, d2) {
                b2.renderTick(c3, d2, f3);
              }), n2 && (0 === b2.min || b2.single) && (g2[-1] || (g2[-1] = new E(b2, -1, null, true)), g2[-1].render(-1)));
              F2 && l2.forEach(function(d2, a4) {
                O2 = "undefined" !== typeof l2[a4 + 1] ? l2[a4 + 1] + n2 : b2.max - n2;
                0 === a4 % 2 && d2 < b2.max && O2 <= b2.max + (c2.polar ? -n2 : n2) && (z2[d2] || (z2[d2] = new D.PlotLineOrBand(b2)), q2 = d2 + n2, z2[d2].options = { from: k2 ? k2.lin2log(q2) : q2, to: k2 ? k2.lin2log(O2) : O2, color: F2, className: "highcharts-alternate-grid" }, z2[d2].render(), z2[d2].isActive = true);
              });
              b2._addedPlotLB || (b2._addedPlotLB = true, (a3.plotLines || []).concat(a3.plotBands || []).forEach(function(c3) {
                b2.addPlotBandOrLine(c3);
              }));
            }
            [g2, r2, z2].forEach(function(b3) {
              const d2 = [], k3 = p2.duration;
              w(b3, function(b4, c3) {
                b4.isActive || (b4.render(c3, false, 0), b4.isActive = false, d2.push(c3));
              });
              T(function() {
                let c3 = d2.length;
                for (; c3--; )
                  b3[d2[c3]] && !b3[d2[c3]].isActive && (b3[d2[c3]].destroy(), delete b3[d2[c3]]);
              }, b3 !== z2 && c2.hasRendered && k3 ? k3 : 0);
            });
            m2 && (m2[m2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(m2.strokeWidth()) }), m2.isPlaced = true, m2[x2 ? "show" : "hide"](x2));
            e2 && x2 && (e2[e2.isNew ? "attr" : "animate"](b2.getTitlePosition(e2)), e2.isNew = false);
            v2 && v2.enabled && b2.stacking && b2.stacking.renderStackTotals();
            b2.old = { len: b2.len, max: b2.max, min: b2.min, transA: b2.transA, userMax: b2.userMax, userMin: b2.userMin };
            b2.isDirty = false;
            y(this, "afterRender");
          }
          redraw() {
            this.visible && (this.render(), this.plotLinesAndBands.forEach(function(b2) {
              b2.render();
            }));
            this.series.forEach(function(b2) {
              b2.isDirty = true;
            });
          }
          getKeepProps() {
            return this.keepProps || W.keepProps;
          }
          destroy(b2) {
            const c2 = this, d2 = c2.plotLinesAndBands, k2 = this.eventOptions;
            y(this, "destroy", { keepEvents: b2 });
            b2 || O(c2);
            [c2.ticks, c2.minorTicks, c2.alternateBands].forEach(function(b3) {
              I(b3);
            });
            if (d2)
              for (b2 = d2.length; b2--; )
                d2[b2].destroy();
            "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b3) {
              c2[b3] && (c2[b3] = c2[b3].destroy());
            });
            for (const b3 in c2.plotLinesAndBandsGroups)
              c2.plotLinesAndBandsGroups[b3] = c2.plotLinesAndBandsGroups[b3].destroy();
            w(c2, function(b3, d3) {
              -1 === c2.getKeepProps().indexOf(d3) && delete c2[d3];
            });
            this.eventOptions = k2;
          }
          drawCrosshair(b2, c2) {
            const d2 = this.crosshair;
            var k2 = z(d2 && d2.snap, true);
            const a3 = this.chart;
            let l2, e2 = this.cross;
            y(this, "drawCrosshair", { e: b2, point: c2 });
            b2 || (b2 = this.cross && this.cross.e);
            if (d2 && false !== (x(c2) || !k2)) {
              k2 ? x(c2) && (l2 = z("colorAxis" !== this.coll ? c2.crosshairPos : null, this.isXAxis ? c2.plotX : this.len - c2.plotY)) : l2 = b2 && (this.horiz ? b2.chartX - this.pos : this.len - b2.chartY + this.pos);
              if (x(l2)) {
                var w2 = { value: c2 && (this.isXAxis ? c2.x : z(c2.stackY, c2.y)), translatedValue: l2 };
                a3.polar && f(w2, { isCrosshair: true, chartX: b2 && b2.chartX, chartY: b2 && b2.chartY, point: c2 });
                w2 = this.getPlotLinePath(w2) || null;
              }
              if (!x(w2)) {
                this.hideCrosshair();
                return;
              }
              k2 = this.categories && !this.isRadial;
              e2 || (this.cross = e2 = a3.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (k2 ? "category " : "thin ") + (d2.className || "")).attr({ zIndex: z(d2.zIndex, 2) }).add(), a3.styledMode || (e2.attr({ stroke: d2.color || (k2 ? J.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": z(
                d2.width,
                1
              ) }).css({ "pointer-events": "none" }), d2.dashStyle && e2.attr({ dashstyle: d2.dashStyle })));
              e2.show().attr({ d: w2 });
              k2 && !d2.width && e2.attr({ "stroke-width": this.transA });
              this.cross.e = b2;
            } else
              this.hideCrosshair();
            y(this, "afterDrawCrosshair", { e: b2, point: c2 });
          }
          hideCrosshair() {
            this.cross && this.cross.hide();
            y(this, "afterHideCrosshair");
          }
          hasVerticalPanning() {
            const b2 = this.chart.options.chart.panning;
            return !!(b2 && b2.enabled && /y/.test(b2.type));
          }
          update(b2, d2) {
            const k2 = this.chart;
            b2 = c(this.userOptions, b2);
            this.destroy(true);
            this.init(k2, b2);
            k2.isDirtyBox = true;
            z(d2, true) && k2.redraw();
          }
          remove(b2) {
            const c2 = this.chart, d2 = this.coll, k2 = this.series;
            let a3 = k2.length;
            for (; a3--; )
              k2[a3] && k2[a3].remove(false);
            u(c2.axes, this);
            u(c2[d2] || [], this);
            c2.orderItems(d2);
            this.destroy();
            c2.isDirtyBox = true;
            z(b2, true) && c2.redraw();
          }
          setTitle(b2, c2) {
            this.update({ title: b2 }, c2);
          }
          setCategories(b2, c2) {
            this.update({ categories: b2 }, c2);
          }
        }
        W.defaultOptions = A.defaultXAxisOptions;
        W.keepProps = "coll extKey hcEvents names series userMax userMin".split(" ");
        "";
        return W;
      });
      L(
        a,
        "Core/Axis/DateTimeAxis.js",
        [a["Core/Utilities.js"]],
        function(a2) {
          const { addEvent: u, getMagnitude: J, normalizeTickInterval: K, timeUnits: G } = a2;
          var D;
          (function(E) {
            function B() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function t(a3) {
              "datetime" !== a3.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new m(this));
            }
            const q = [];
            E.compose = function(m2) {
              a2.pushUnique(q, m2) && (m2.keepProps.push("dateTime"), m2.prototype.getTimeTicks = B, u(m2, "init", t));
              return m2;
            };
            class m {
              constructor(a3) {
                this.axis = a3;
              }
              normalizeTimeTickInterval(a3, n) {
                const h = n || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                n = h[h.length - 1];
                let g = G[n[0]], e = n[1], m2;
                for (m2 = 0; m2 < h.length && !(n = h[m2], g = G[n[0]], e = n[1], h[m2 + 1] && a3 <= (g * e[e.length - 1] + G[h[m2 + 1][0]]) / 2); m2++)
                  ;
                g === G.year && a3 < 5 * g && (e = [1, 2, 5]);
                a3 = K(a3 / g, e, "year" === n[0] ? Math.max(J(a3 / g), 1) : 1);
                return { unitRange: g, count: a3, unitName: n[0] };
              }
              getXDateFormat(a3, n) {
                const { axis: h } = this, g = h.chart.time;
                return h.closestPointRange ? g.getDateFormat(h.closestPointRange, a3, h.options.startOfWeek, n) || g.resolveDTLFormat(n.year).main : g.resolveDTLFormat(n.day).main;
              }
            }
            E.Additions = m;
          })(D || (D = {}));
          return D;
        }
      );
      L(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: u, normalizeTickInterval: J, pick: K } = a2;
        var G;
        (function(A) {
          function E(a3) {
            let m = this.logarithmic;
            "logarithmic" !== a3.userOptions.type ? this.logarithmic = void 0 : m || (this.logarithmic = new q(this));
          }
          function B() {
            const a3 = this.logarithmic;
            a3 && (this.lin2val = function(m) {
              return a3.lin2log(m);
            }, this.val2lin = function(m) {
              return a3.log2lin(m);
            });
          }
          const t = [];
          A.compose = function(m) {
            a2.pushUnique(t, m) && (m.keepProps.push("logarithmic"), u(m, "init", E), u(m, "afterInit", B));
            return m;
          };
          class q {
            constructor(a3) {
              this.axis = a3;
            }
            getLogTickPositions(a3, p, n, h) {
              const g = this.axis;
              var e = g.len, m = g.options;
              let q2 = [];
              h || (this.minorAutoInterval = void 0);
              if (0.5 <= a3)
                a3 = Math.round(a3), q2 = g.getLinearTickPositions(a3, p, n);
              else if (0.08 <= a3) {
                m = Math.floor(p);
                let g2, x, f, y, r;
                for (e = 0.3 < a3 ? [1, 2, 4] : 0.15 < a3 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; m < n + 1 && !r; m++)
                  for (x = e.length, g2 = 0; g2 < x && !r; g2++)
                    f = this.log2lin(this.lin2log(m) * e[g2]), f > p && (!h || y <= n) && "undefined" !== typeof y && q2.push(y), y > n && (r = true), y = f;
              } else
                p = this.lin2log(p), n = this.lin2log(n), a3 = h ? g.getMinorTickInterval() : m.tickInterval, a3 = K("auto" === a3 ? null : a3, this.minorAutoInterval, m.tickPixelInterval / (h ? 5 : 1) * (n - p) / ((h ? e / g.tickPositions.length : e) || 1)), a3 = J(a3), q2 = g.getLinearTickPositions(a3, p, n).map(this.log2lin), h || (this.minorAutoInterval = a3 / 5);
              h || (g.tickInterval = a3);
              return q2;
            }
            lin2log(a3) {
              return Math.pow(
                10,
                a3
              );
            }
            log2lin(a3) {
              return Math.log(a3) / Math.LN10;
            }
          }
          A.Additions = q;
        })(G || (G = {}));
        return G;
      });
      L(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { erase: u, extend: J, isNumber: K } = a2;
        var G;
        (function(A) {
          function E(a3) {
            return this.addPlotBandOrLine(a3, "plotBands");
          }
          function B(a3, h2) {
            const e = this.userOptions;
            let n2 = new g(this, a3);
            this.visible && (n2 = n2.render());
            if (n2) {
              this._addedPlotLB || (this._addedPlotLB = true, (e.plotLines || []).concat(e.plotBands || []).forEach((a4) => {
                this.addPlotBandOrLine(a4);
              }));
              if (h2) {
                const g2 = e[h2] || [];
                g2.push(a3);
                e[h2] = g2;
              }
              this.plotLinesAndBands.push(n2);
            }
            return n2;
          }
          function t(a3) {
            return this.addPlotBandOrLine(a3, "plotLines");
          }
          function q(a3, g2, h2 = this.options) {
            const e = this.getPlotLinePath({ value: g2, force: true, acrossPanes: h2.acrossPanes }), n2 = [], f = this.horiz;
            g2 = !K(this.min) || !K(this.max) || a3 < this.min && g2 < this.min || a3 > this.max && g2 > this.max;
            a3 = this.getPlotLinePath({ value: a3, force: true, acrossPanes: h2.acrossPanes });
            h2 = 1;
            let y;
            if (a3 && e)
              for (g2 && (y = a3.toString() === e.toString(), h2 = 0), g2 = 0; g2 < a3.length; g2 += 2) {
                const r = a3[g2], l = a3[g2 + 1], v = e[g2], d = e[g2 + 1];
                "M" !== r[0] && "L" !== r[0] || "M" !== l[0] && "L" !== l[0] || "M" !== v[0] && "L" !== v[0] || "M" !== d[0] && "L" !== d[0] || (f && v[1] === r[1] ? (v[1] += h2, d[1] += h2) : f || v[2] !== r[2] || (v[2] += h2, d[2] += h2), n2.push(["M", r[1], r[2]], ["L", l[1], l[2]], ["L", d[1], d[2]], ["L", v[1], v[2]], ["Z"]));
                n2.isFlat = y;
              }
            return n2;
          }
          function m(a3) {
            this.removePlotBandOrLine(a3);
          }
          function p(a3) {
            const e = this.plotLinesAndBands, g2 = this.options, h2 = this.userOptions;
            if (e) {
              let n2 = e.length;
              for (; n2--; )
                e[n2].id === a3 && e[n2].destroy();
              [
                g2.plotLines || [],
                h2.plotLines || [],
                g2.plotBands || [],
                h2.plotBands || []
              ].forEach(function(f) {
                for (n2 = f.length; n2--; )
                  (f[n2] || {}).id === a3 && u(f, f[n2]);
              });
            }
          }
          function n(a3) {
            this.removePlotBandOrLine(a3);
          }
          const h = [];
          let g;
          A.compose = function(e, x) {
            g || (g = e);
            a2.pushUnique(h, x) && J(x.prototype, { addPlotBand: E, addPlotLine: t, addPlotBandOrLine: B, getPlotBandPath: q, removePlotBand: m, removePlotLine: n, removePlotBandOrLine: p });
            return x;
          };
        })(G || (G = {}));
        return G;
      });
      L(
        a,
        "Core/Axis/PlotLineOrBand/PlotLineOrBand.js",
        [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]],
        function(a2, A) {
          const { arrayMax: u, arrayMin: K, defined: G, destroyObjectProperties: D, erase: E, fireEvent: B, merge: t, objectEach: q, pick: m } = A;
          class p {
            static compose(n) {
              return a2.compose(p, n);
            }
            constructor(a3, h) {
              this.axis = a3;
              h && (this.options = h, this.id = h.id);
            }
            render() {
              B(this, "render");
              const a3 = this, h = a3.axis, g = h.horiz;
              var e = h.logarithmic;
              const x = a3.options, p2 = x.color, u2 = m(x.zIndex, 0), C = x.events, f = {}, y = h.chart.renderer;
              let r = x.label, l = a3.label, v = x.to, d = x.from, b = x.value, c = a3.svgElem;
              var k = [];
              const w = G(d) && G(v);
              k = G(b);
              const z = !c, F = { "class": "highcharts-plot-" + (w ? "band " : "line ") + (x.className || "") };
              let O = w ? "bands" : "lines";
              e && (d = e.log2lin(d), v = e.log2lin(v), b = e.log2lin(b));
              h.chart.styledMode || (k ? (F.stroke = p2 || "#999999", F["stroke-width"] = m(x.width, 1), x.dashStyle && (F.dashstyle = x.dashStyle)) : w && (F.fill = p2 || "#e6e9ff", x.borderWidth && (F.stroke = x.borderColor, F["stroke-width"] = x.borderWidth)));
              f.zIndex = u2;
              O += "-" + u2;
              (e = h.plotLinesAndBandsGroups[O]) || (h.plotLinesAndBandsGroups[O] = e = y.g("plot-" + O).attr(f).add());
              z && (a3.svgElem = c = y.path().attr(F).add(e));
              if (k)
                k = h.getPlotLinePath({ value: b, lineWidth: c.strokeWidth(), acrossPanes: x.acrossPanes });
              else if (w)
                k = h.getPlotBandPath(d, v, x);
              else
                return;
              !a3.eventsAdded && C && (q(C, function(b2, d2) {
                c.on(d2, function(b3) {
                  C[d2].apply(a3, [b3]);
                });
              }), a3.eventsAdded = true);
              (z || !c.d) && k && k.length ? c.attr({ d: k }) : c && (k ? (c.show(), c.animate({ d: k })) : c.d && (c.hide(), l && (a3.label = l = l.destroy())));
              r && (G(r.text) || G(r.formatter)) && k && k.length && 0 < h.width && 0 < h.height && !k.isFlat ? (r = t({ align: g && w && "center", x: g ? !w && 4 : 10, verticalAlign: !g && w && "middle", y: g ? w ? 16 : 10 : w ? 6 : -4, rotation: g && !w && 90 }, r), this.renderLabel(r, k, w, u2)) : l && l.hide();
              return a3;
            }
            renderLabel(a3, h, g, e) {
              const n = this.axis;
              var m2 = n.chart.renderer;
              let p2 = this.label;
              p2 || (this.label = p2 = m2.text(this.getLabelText(a3), 0, 0, a3.useHTML).attr({ align: a3.textAlign || a3.align, rotation: a3.rotation, "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (a3.className || ""), zIndex: e }).add(), n.chart.styledMode || p2.css(t({ fontSize: "0.8em", textOverflow: "ellipsis" }, a3.style)));
              e = h.xBounds || [h[0][1], h[1][1], g ? h[2][1] : h[0][1]];
              h = h.yBounds || [h[0][2], h[1][2], g ? h[2][2] : h[0][2]];
              g = K(e);
              m2 = K(h);
              p2.align(a3, false, { x: g, y: m2, width: u(e) - g, height: u(h) - m2 });
              p2.alignValue && "left" !== p2.alignValue || (a3 = a3.clip ? n.width : n.chart.chartWidth, p2.css({ width: (90 === p2.rotation ? n.height - (p2.alignAttr.y - n.top) : a3 - (p2.alignAttr.x - n.left)) + "px" }));
              p2.show(true);
            }
            getLabelText(a3) {
              return G(a3.formatter) ? a3.formatter.call(this) : a3.text;
            }
            destroy() {
              E(this.axis.plotLinesAndBands, this);
              delete this.axis;
              D(this);
            }
          }
          "";
          "";
          return p;
        }
      );
      L(a, "Core/Tooltip.js", [
        a["Core/Templating.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G) {
        const { format: u } = a2, { doc: E, isSafari: B } = A, { distribute: t } = J, { addEvent: q, clamp: m, css: p, discardElement: n, extend: h, fireEvent: g, isArray: e, isNumber: x, isString: I, merge: M, pick: C, splat: f, syncTimeout: y } = G;
        class r {
          constructor(a3, f2) {
            this.allowShared = true;
            this.container = void 0;
            this.crosshairs = [];
            this.distance = 0;
            this.isHidden = true;
            this.isSticky = false;
            this.now = {};
            this.options = {};
            this.outside = false;
            this.chart = a3;
            this.init(a3, f2);
          }
          bodyFormatter(a3) {
            return a3.map(function(a4) {
              const d = a4.series.tooltipOptions;
              return (d[(a4.point.formatPrefix || "point") + "Formatter"] || a4.point.tooltipFormatter).call(a4.point, d[(a4.point.formatPrefix || "point") + "Format"] || "");
            });
          }
          cleanSplit(a3) {
            this.chart.series.forEach(function(f2) {
              const d = f2 && f2.tt;
              d && (!d.isActive || a3 ? f2.tt = d.destroy() : d.isActive = false);
            });
          }
          defaultFormatter(a3) {
            const l = this.points || f(this);
            let d;
            d = [a3.tooltipFooterHeaderFormatter(l[0])];
            d = d.concat(a3.bodyFormatter(l));
            d.push(a3.tooltipFooterHeaderFormatter(
              l[0],
              true
            ));
            return d;
          }
          destroy() {
            this.label && (this.label = this.label.destroy());
            this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy()));
            this.renderer && (this.renderer = this.renderer.destroy(), n(this.container));
            G.clearTimeout(this.hideTimer);
            G.clearTimeout(this.tooltipTimeout);
          }
          getAnchor(a3, e2) {
            var d = this.chart;
            const b = d.pointer, c = d.inverted, k = d.plotTop;
            d = d.plotLeft;
            a3 = f(a3);
            a3[0].series && a3[0].series.yAxis && !a3[0].series.yAxis.options.reversedStacks && (a3 = a3.slice().reverse());
            if (this.followPointer && e2)
              "undefined" === typeof e2.chartX && (e2 = b.normalize(e2)), a3 = [e2.chartX - d, e2.chartY - k];
            else if (a3[0].tooltipPos)
              a3 = a3[0].tooltipPos;
            else {
              let b2 = 0, f2 = 0;
              a3.forEach(function(c2) {
                if (c2 = c2.pos(true))
                  b2 += c2[0], f2 += c2[1];
              });
              b2 /= a3.length;
              f2 /= a3.length;
              this.shared && 1 < a3.length && e2 && (c ? b2 = e2.chartX : f2 = e2.chartY);
              a3 = [b2 - d, f2 - k];
            }
            return a3.map(Math.round);
          }
          getClassName(a3, f2, d) {
            const b = a3.series, c = b.options;
            return [this.options.className, "highcharts-label", d && "highcharts-tooltip-header", f2 ? "highcharts-tooltip-box" : "highcharts-tooltip", !d && "highcharts-color-" + C(
              a3.colorIndex,
              b.colorIndex
            ), c && c.className].filter(I).join(" ");
          }
          getLabel() {
            const a3 = this, f2 = this.chart.styledMode, d = this.options, b = this.split && this.allowShared, c = d.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none");
            let k, e2 = this.chart.renderer;
            if (this.label) {
              var g2 = !this.label.hasClass("highcharts-label");
              (!b && g2 || b && !g2) && this.destroy();
            }
            if (!this.label) {
              if (this.outside) {
                g2 = this.chart.options.chart.style;
                const b2 = K.getRendererType();
                this.container = k = A.doc.createElement("div");
                k.className = "highcharts-tooltip-container";
                p(k, { position: "absolute", top: "1px", pointerEvents: c, zIndex: Math.max(this.options.style.zIndex || 0, (g2 && g2.zIndex || 0) + 3) });
                A.doc.body.appendChild(k);
                this.renderer = e2 = new b2(k, 0, 0, g2, void 0, void 0, e2.styledMode);
              }
              b ? this.label = e2.g("tooltip") : (this.label = e2.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, "tooltip").attr({ padding: d.padding, r: d.borderRadius }), f2 || this.label.attr({ fill: d.backgroundColor, "stroke-width": d.borderWidth || 0 }).css(d.style).css({ pointerEvents: c }));
              if (a3.outside) {
                const b2 = this.label, {
                  xSetter: c2,
                  ySetter: d2
                } = b2;
                b2.xSetter = function(d3) {
                  c2.call(b2, a3.distance);
                  k.style.left = d3 + "px";
                };
                b2.ySetter = function(c3) {
                  d2.call(b2, a3.distance);
                  k.style.top = c3 + "px";
                };
              }
              this.label.attr({ zIndex: 8 }).shadow(d.shadow).add();
            }
            return this.label;
          }
          getPlayingField() {
            const { body: a3, documentElement: f2 } = E, { chart: d, distance: b, outside: c } = this;
            return { width: c ? Math.max(a3.scrollWidth, f2.scrollWidth, a3.offsetWidth, f2.offsetWidth, f2.clientWidth) - 2 * b : d.chartWidth, height: c ? Math.max(a3.scrollHeight, f2.scrollHeight, a3.offsetHeight, f2.offsetHeight, f2.clientHeight) : d.chartHeight };
          }
          getPosition(a3, f2, d) {
            const b = this.chart, c = this.distance, k = {}, l = b.inverted && d.h || 0, e2 = this.outside;
            var g2 = this.getPlayingField();
            const r2 = g2.width, h2 = g2.height, v = b.pointer.getChartPosition();
            g2 = (k2) => {
              const l2 = "x" === k2;
              return [k2, l2 ? r2 : h2, l2 ? a3 : f2].concat(e2 ? [l2 ? a3 * v.scaleX : f2 * v.scaleY, l2 ? v.left - c + (d.plotX + b.plotLeft) * v.scaleX : v.top - c + (d.plotY + b.plotTop) * v.scaleY, 0, l2 ? r2 : h2] : [l2 ? a3 : f2, l2 ? d.plotX + b.plotLeft : d.plotY + b.plotTop, l2 ? b.plotLeft : b.plotTop, l2 ? b.plotLeft + b.plotWidth : b.plotTop + b.plotHeight]);
            };
            let y2 = g2("y"), n2 = g2("x"), m2;
            g2 = !!d.negative;
            !b.polar && b.hoverSeries && b.hoverSeries.yAxis && b.hoverSeries.yAxis.reversed && (g2 = !g2);
            const p2 = !this.followPointer && C(d.ttBelow, !b.inverted === g2), x2 = function(b2, d2, a4, f3, w, g3, r3) {
              const z = e2 ? "y" === b2 ? c * v.scaleY : c * v.scaleX : c, h3 = (a4 - f3) / 2, F = f3 < w - c, y3 = w + c + f3 < d2, n3 = w - z - a4 + h3;
              w = w + z - h3;
              if (p2 && y3)
                k[b2] = w;
              else if (!p2 && F)
                k[b2] = n3;
              else if (F)
                k[b2] = Math.min(r3 - f3, 0 > n3 - l ? n3 : n3 - l);
              else if (y3)
                k[b2] = Math.max(g3, w + l + a4 > d2 ? w : w + l);
              else
                return false;
            }, q2 = function(b2, d2, a4, f3, l2) {
              let e3;
              l2 < c || l2 > d2 - c ? e3 = false : k[b2] = l2 < a4 / 2 ? 1 : l2 > d2 - f3 / 2 ? d2 - f3 - 2 : l2 - a4 / 2;
              return e3;
            }, t2 = function(b2) {
              const c2 = y2;
              y2 = n2;
              n2 = c2;
              m2 = b2;
            }, N = function() {
              false !== x2.apply(0, y2) ? false !== q2.apply(0, n2) || m2 || (t2(true), N()) : m2 ? k.x = k.y = 0 : (t2(true), N());
            };
            (b.inverted || 1 < this.len) && t2();
            N();
            return k;
          }
          hide(a3) {
            const f2 = this;
            G.clearTimeout(this.hideTimer);
            a3 = C(a3, this.options.hideDelay);
            this.isHidden || (this.hideTimer = y(function() {
              f2.getLabel().fadeOut(a3 ? void 0 : a3);
              f2.isHidden = true;
            }, a3));
          }
          init(a3, f2) {
            this.chart = a3;
            this.options = f2;
            this.crosshairs = [];
            this.now = { x: 0, y: 0 };
            this.isHidden = true;
            this.split = f2.split && !a3.inverted && !a3.polar;
            this.shared = f2.shared || this.split;
            this.outside = C(f2.outside, !(!a3.scrollablePixelsX && !a3.scrollablePixelsY));
          }
          shouldStickOnContact(a3) {
            return !(this.followPointer || !this.options.stickOnContact || a3 && !this.chart.pointer.inClass(a3.target, "highcharts-tooltip"));
          }
          move(a3, f2, d, b) {
            const c = this, k = c.now, l = false !== c.options.animation && !c.isHidden && (1 < Math.abs(a3 - k.x) || 1 < Math.abs(f2 - k.y)), e2 = c.followPointer || 1 < c.len;
            h(k, { x: l ? (2 * k.x + a3) / 3 : a3, y: l ? (k.y + f2) / 2 : f2, anchorX: e2 ? void 0 : l ? (2 * k.anchorX + d) / 3 : d, anchorY: e2 ? void 0 : l ? (k.anchorY + b) / 2 : b });
            c.getLabel().attr(k);
            c.drawTracker();
            l && (G.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
              c && c.move(a3, f2, d, b);
            }, 32));
          }
          refresh(a3, r2) {
            const d = this.chart, b = this.options, c = d.pointer, k = f(a3), l = k[0], z = [];
            var h2 = b.format, y2 = b.formatter || this.defaultFormatter;
            const n2 = this.shared, v = d.styledMode;
            let m2 = {};
            if (b.enabled && l.series) {
              G.clearTimeout(this.hideTimer);
              this.allowShared = !(!e(a3) && a3.series && a3.series.noSharedTooltip);
              this.followPointer = !this.split && l.series.tooltipOptions.followPointer;
              a3 = this.getAnchor(a3, r2);
              var p2 = a3[0], x2 = a3[1];
              n2 && this.allowShared ? (c.applyInactiveState(k), k.forEach(function(b2) {
                b2.setState("hover");
                z.push(b2.getLabelConfig());
              }), m2 = l.getLabelConfig(), m2.points = z) : m2 = l.getLabelConfig();
              this.len = z.length;
              h2 = I(h2) ? u(h2, m2, d) : y2.call(m2, this);
              y2 = l.series;
              this.distance = C(y2.tooltipOptions.distance, 16);
              if (false === h2)
                this.hide();
              else {
                if (this.split && this.allowShared)
                  this.renderSplit(h2, k);
                else {
                  let f2 = p2, e2 = x2;
                  r2 && c.isDirectTouch && (f2 = r2.chartX - d.plotLeft, e2 = r2.chartY - d.plotTop);
                  if (d.polar || false === y2.options.clip || k.some((b2) => c.isDirectTouch || b2.series.shouldShowTooltip(
                    f2,
                    e2
                  )))
                    r2 = this.getLabel(), b.style.width && !v || r2.css({ width: (this.outside ? this.getPlayingField() : d.spacingBox).width + "px" }), r2.attr({ text: h2 && h2.join ? h2.join("") : h2 }), r2.addClass(this.getClassName(l), true), v || r2.attr({ stroke: b.borderColor || l.color || y2.color || "#666666" }), this.updatePosition({ plotX: p2, plotY: x2, negative: l.negative, ttBelow: l.ttBelow, h: a3[2] || 0 });
                  else {
                    this.hide();
                    return;
                  }
                }
                this.isHidden && this.label && this.label.attr({ opacity: 1 }).show();
                this.isHidden = false;
              }
              g(this, "refresh");
            }
          }
          renderSplit(a3, f2) {
            function d(c2, d2, a4, k2, f3 = true) {
              a4 ? (d2 = R ? 0 : J2, c2 = m(c2 - k2 / 2, N.left, N.right - k2 - (b.outside ? V : 0))) : (d2 -= D, c2 = f3 ? c2 - k2 - u2 : c2 + u2, c2 = m(c2, f3 ? c2 : N.left, N.right));
              return { x: c2, y: d2 };
            }
            const b = this, { chart: c, chart: { chartWidth: k, chartHeight: l, plotHeight: e2, plotLeft: g2, plotTop: r2, pointer: y2, scrollablePixelsY: n2 = 0, scrollablePixelsX: v, scrollingContainer: { scrollLeft: p2, scrollTop: x2 } = { scrollLeft: 0, scrollTop: 0 }, styledMode: q2 }, distance: u2, options: M2, options: { positioner: A2 } } = b, N = b.outside && "number" !== typeof v ? E.documentElement.getBoundingClientRect() : { left: p2, right: p2 + k, top: x2, bottom: x2 + l }, X = b.getLabel(), Q = this.renderer || c.renderer, R = !(!c.xAxis[0] || !c.xAxis[0].opposite), { left: V, top: G2 } = y2.getChartPosition();
            let D = r2 + x2, K2 = 0, J2 = e2 - n2;
            I(a3) && (a3 = [false, a3]);
            a3 = a3.slice(0, f2.length + 1).reduce(function(c2, a4, k2) {
              if (false !== a4 && "" !== a4) {
                k2 = f2[k2 - 1] || { isHeader: true, plotX: f2[0].plotX, plotY: e2, series: {} };
                const n3 = k2.isHeader;
                var l2 = n3 ? b : k2.series, w;
                {
                  var h2 = k2;
                  a4 = a4.toString();
                  var z = l2.tt;
                  const { isHeader: c3, series: d2 } = h2;
                  z || (z = { padding: M2.padding, r: M2.borderRadius }, q2 || (z.fill = M2.backgroundColor, z["stroke-width"] = null !== (w = M2.borderWidth) && void 0 !== w ? w : 1), z = Q.label("", 0, 0, M2[c3 ? "headerShape" : "shape"], void 0, void 0, M2.useHTML).addClass(b.getClassName(h2, true, c3)).attr(z).add(X));
                  z.isActive = true;
                  z.attr({ text: a4 });
                  q2 || z.css(M2.style).attr({ stroke: M2.borderColor || h2.color || d2.color || "#333333" });
                  w = z;
                }
                w = l2.tt = w;
                h2 = w.getBBox();
                l2 = h2.width + w.strokeWidth();
                n3 && (K2 = h2.height, J2 += K2, R && (D -= K2));
                {
                  const { isHeader: b2, plotX: c3 = 0, plotY: d2 = 0, series: f3 } = k2;
                  if (b2) {
                    a4 = g2 + c3;
                    var y3 = r2 + e2 / 2;
                  } else {
                    const { xAxis: b3, yAxis: k3 } = f3;
                    a4 = b3.pos + m(c3, -u2, b3.len + u2);
                    f3.shouldShowTooltip(0, k3.pos - r2 + d2, { ignoreX: true }) && (y3 = k3.pos + d2);
                  }
                  a4 = m(a4, N.left - u2, N.right + u2);
                  y3 = { anchorX: a4, anchorY: y3 };
                }
                const { anchorX: v2, anchorY: F } = y3;
                "number" === typeof F ? (y3 = h2.height + 1, h2 = A2 ? A2.call(b, l2, y3, k2) : d(v2, F, n3, l2), c2.push({ align: A2 ? 0 : void 0, anchorX: v2, anchorY: F, boxWidth: l2, point: k2, rank: C(h2.rank, n3 ? 1 : 0), size: y3, target: h2.y, tt: w, x: h2.x })) : w.isActive = false;
              }
              return c2;
            }, []);
            !A2 && a3.some((c2) => {
              var { outside: d2 } = b;
              d2 = (d2 ? V : 0) + c2.anchorX;
              return d2 < N.left && d2 + c2.boxWidth < N.right ? true : d2 < V - N.left + c2.boxWidth && N.right - d2 > d2;
            }) && (a3 = a3.map((b2) => {
              const { x: c2, y: a4 } = d(
                b2.anchorX,
                b2.anchorY,
                b2.point.isHeader,
                b2.boxWidth,
                false
              );
              return h(b2, { target: a4, x: c2 });
            }));
            b.cleanSplit();
            t(a3, J2);
            var ba = V, L2 = V;
            a3.forEach(function(c2) {
              const { x: d2, boxWidth: a4, isHeader: k2 } = c2;
              k2 || (b.outside && V + d2 < ba && (ba = V + d2), !k2 && b.outside && ba + a4 > L2 && (L2 = V + d2));
            });
            a3.forEach(function(c2) {
              const { x: d2, anchorX: a4, anchorY: k2, pos: f3, point: { isHeader: l2 } } = c2, e3 = { visibility: "undefined" === typeof f3 ? "hidden" : "inherit", x: d2, y: (f3 || 0) + D, anchorX: a4, anchorY: k2 };
              if (b.outside && d2 < a4) {
                const b2 = V - ba;
                0 < b2 && (l2 || (e3.x = d2 + b2, e3.anchorX = a4 + b2), l2 && (e3.x = (L2 - ba) / 2, e3.anchorX = a4 + b2));
              }
              c2.tt.attr(e3);
            });
            const {
              container: fa,
              outside: ca,
              renderer: ka
            } = b;
            if (ca && fa && ka) {
              const { width: b2, height: c2, x: d2, y: a4 } = X.getBBox();
              ka.setSize(b2 + d2, c2 + a4, false);
              fa.style.left = ba + "px";
              fa.style.top = G2 + "px";
            }
            B && X.attr({ opacity: 1 === X.opacity ? 0.999 : 1 });
          }
          drawTracker() {
            if (this.shouldStickOnContact()) {
              var a3 = this.chart, f2 = this.label, d = this.shared ? a3.hoverPoints : a3.hoverPoint;
              if (f2 && d) {
                var b = { x: 0, y: 0, width: 0, height: 0 };
                d = this.getAnchor(d);
                var c = f2.getBBox();
                d[0] += a3.plotLeft - f2.translateX;
                d[1] += a3.plotTop - f2.translateY;
                b.x = Math.min(0, d[0]);
                b.y = Math.min(0, d[1]);
                b.width = 0 > d[0] ? Math.max(Math.abs(d[0]), c.width - d[0]) : Math.max(Math.abs(d[0]), c.width);
                b.height = 0 > d[1] ? Math.max(Math.abs(d[1]), c.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), c.height);
                this.tracker ? this.tracker.attr(b) : (this.tracker = f2.renderer.rect(b).addClass("highcharts-tracker").add(f2), a3.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
              }
            } else
              this.tracker && (this.tracker = this.tracker.destroy());
          }
          styledModeFormat(a3) {
            return a3.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(
              /style="color:{(point|series)\.color}"/g,
              'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"'
            );
          }
          tooltipFooterHeaderFormatter(a3, f2) {
            const d = a3.series, b = d.tooltipOptions;
            var c = d.xAxis;
            const k = c && c.dateTime;
            c = { isFooter: f2, labelConfig: a3 };
            let l = b.xDateFormat, e2 = b[f2 ? "footerFormat" : "headerFormat"];
            g(this, "headerFormatter", c, function(c2) {
              k && !l && x(a3.key) && (l = k.getXDateFormat(a3.key, b.dateTimeLabelFormats));
              k && l && (a3.point && a3.point.tooltipDateKeys || ["key"]).forEach(function(b2) {
                e2 = e2.replace("{point." + b2 + "}", "{point." + b2 + ":" + l + "}");
              });
              d.chart.styledMode && (e2 = this.styledModeFormat(e2));
              c2.text = u(e2, { point: a3, series: d }, this.chart);
            });
            return c.text;
          }
          update(a3) {
            this.destroy();
            this.init(this.chart, M(true, this.options, a3));
          }
          updatePosition(a3) {
            const { chart: f2, distance: d, options: b } = this;
            var c = f2.pointer;
            const k = this.getLabel(), { left: l, top: e2, scaleX: g2, scaleY: r2 } = c.getChartPosition();
            c = (b.positioner || this.getPosition).call(this, k.width, k.height, a3);
            let h2 = (a3.plotX || 0) + f2.plotLeft;
            a3 = (a3.plotY || 0) + f2.plotTop;
            let y2;
            if (this.outside) {
              b.positioner && (c.x += l - d, c.y += e2 - d);
              y2 = (b.borderWidth || 0) + 2 * d;
              this.renderer.setSize(k.width + y2, k.height + y2, false);
              if (1 !== g2 || 1 !== r2)
                p(this.container, { transform: `scale(${g2}, ${r2})` }), h2 *= g2, a3 *= r2;
              h2 += l - c.x;
              a3 += e2 - c.y;
            }
            this.move(Math.round(c.x), Math.round(c.y || 0), h2, a3);
          }
        }
        (function(a3) {
          const f2 = [];
          a3.compose = function(d) {
            G.pushUnique(f2, d) && q(d, "afterInit", function() {
              const b = this.chart;
              b.options.tooltip && (b.tooltip = new a3(b, b.options.tooltip));
            });
          };
        })(r || (r = {}));
        "";
        return r;
      });
      L(a, "Core/Series/Point.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G) {
        const { animObject: u } = A, { defaultOptions: E } = J, { format: B } = K, { addEvent: t, defined: q, erase: m, extend: p, fireEvent: n, getNestedProperty: h, isArray: g, isFunction: e, isNumber: x, isObject: I, merge: M, objectEach: C, pick: f, syncTimeout: y, removeEvent: r, uniqueKey: l } = G;
        class v {
          constructor() {
            this.category = void 0;
            this.destroyed = false;
            this.formatPrefix = "point";
            this.id = void 0;
            this.isNull = false;
            this.percentage = this.options = this.name = void 0;
            this.selected = false;
            this.total = this.shapeArgs = this.series = void 0;
            this.visible = true;
            this.x = void 0;
          }
          animateBeforeDestroy() {
            const d = this, b = { x: d.startXPos, opacity: 0 }, c = d.getGraphicalProps();
            c.singular.forEach(function(c2) {
              d[c2] = d[c2].animate("dataLabel" === c2 ? { x: d[c2].startXPos, y: d[c2].startYPos, opacity: 0 } : b);
            });
            c.plural.forEach(function(b2) {
              d[b2].forEach(function(b3) {
                b3.element && b3.animate(p({ x: d.startXPos }, b3.startYPos ? { x: b3.startXPos, y: b3.startYPos } : {}));
              });
            });
          }
          applyOptions(d, b) {
            const c = this.series, a3 = c.options.pointValKey || c.pointValKey;
            d = v.prototype.optionsToObject.call(this, d);
            p(this, d);
            this.options = this.options ? p(this.options, d) : d;
            d.group && delete this.group;
            d.dataLabels && delete this.dataLabels;
            a3 && (this.y = v.prototype.getNestedProperty.call(this, a3));
            this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? "null" : "point";
            this.selected && (this.state = "select");
            "name" in this && "undefined" === typeof b && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));
            "undefined" === typeof this.x && c ? this.x = "undefined" === typeof b ? c.autoIncrement() : b : x(d.x) && c.options.relativeXValue && (this.x = c.autoIncrement(d.x));
            return this;
          }
          destroy() {
            if (!this.destroyed) {
              const b = this;
              var d = b.series;
              const c = d.chart;
              d = d.options.dataSorting;
              const a3 = c.hoverPoints, f2 = u(b.series.chart.renderer.globalAnimation), l2 = () => {
                if (b.graphic || b.graphics || b.dataLabel || b.dataLabels)
                  r(b), b.destroyElements();
                for (const c2 in b)
                  delete b[c2];
              };
              b.legendItem && c.legend.destroyItem(b);
              a3 && (b.setState(), m(a3, b), a3.length || (c.hoverPoints = null));
              if (b === c.hoverPoint)
                b.onMouseOut();
              d && d.enabled ? (this.animateBeforeDestroy(), y(l2, f2.duration)) : l2();
              c.pointCount--;
            }
            this.destroyed = true;
          }
          destroyElements(d) {
            const b = this;
            d = b.getGraphicalProps(d);
            d.singular.forEach(function(c) {
              b[c] = b[c].destroy();
            });
            d.plural.forEach(function(c) {
              b[c].forEach(function(b2) {
                b2 && b2.element && b2.destroy();
              });
              delete b[c];
            });
          }
          firePointEvent(d, b, c) {
            const a3 = this, f2 = this.series.options;
            (f2.point.events[d] || a3.options && a3.options.events && a3.options.events[d]) && a3.importEvents();
            "click" === d && f2.allowPointSelect && (c = function(b2) {
              a3.select && a3.select(null, b2.ctrlKey || b2.metaKey || b2.shiftKey);
            });
            n(a3, d, b, c);
          }
          getClassName() {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
          }
          getGraphicalProps(d) {
            const b = this, c = [], a3 = { singular: [], plural: [] };
            let f2, l2;
            d = d || { graphic: 1, dataLabel: 1 };
            d.graphic && c.push("graphic");
            d.dataLabel && c.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
            for (l2 = c.length; l2--; )
              f2 = c[l2], b[f2] && a3.singular.push(f2);
            ["graphic", "dataLabel", "connector"].forEach(function(c2) {
              const k = c2 + "s";
              d[c2] && b[k] && a3.plural.push(k);
            });
            return a3;
          }
          getLabelConfig() {
            return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
          }
          getNestedProperty(d) {
            if (d)
              return 0 === d.indexOf("custom.") ? h(d, this.options) : this[d];
          }
          getZone() {
            var d = this.series;
            const b = d.zones;
            d = d.zoneAxis || "y";
            let c, a3 = 0;
            for (c = b[a3]; this[d] >= c.value; )
              c = b[++a3];
            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
            return c;
          }
          hasNewShapeType() {
            return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
          }
          init(d, b, c) {
            this.series = d;
            this.applyOptions(b, c);
            this.id = q(this.id) ? this.id : l();
            this.resolveColor();
            d.chart.pointCount++;
            n(this, "afterInit");
            return this;
          }
          isValid() {
            return null !== this.x && x(this.y);
          }
          optionsToObject(d) {
            var b = this.series;
            const c = b.options.keys, a3 = c || b.pointArrayMap || ["y"], f2 = a3.length;
            let l2 = {}, e2 = 0, r2 = 0;
            if (x(d) || null === d)
              l2[a3[0]] = d;
            else if (g(d))
              for (!c && d.length > f2 && (b = typeof d[0], "string" === b ? l2.name = d[0] : "number" === b && (l2.x = d[0]), e2++); r2 < f2; )
                c && "undefined" === typeof d[e2] || (0 < a3[r2].indexOf(".") ? v.prototype.setNestedProperty(l2, d[e2], a3[r2]) : l2[a3[r2]] = d[e2]), e2++, r2++;
            else
              "object" === typeof d && (l2 = d, d.dataLabels && (b._hasPointLabels = true), d.marker && (b._hasPointMarkers = true));
            return l2;
          }
          pos(d, b = this.plotY) {
            if (!this.destroyed) {
              const { plotX: c, series: a3 } = this, { chart: f2, xAxis: l2, yAxis: e2 } = a3;
              let g2 = 0, r2 = 0;
              if (x(c) && x(b))
                return d && (g2 = l2 ? l2.pos : f2.plotLeft, r2 = e2 ? e2.pos : f2.plotTop), f2.inverted && l2 && e2 ? [e2.len - b + r2, l2.len - c + g2] : [c + g2, b + r2];
            }
          }
          resolveColor() {
            const d = this.series;
            var b = d.chart.styledMode;
            let c;
            var a3 = d.chart.options.chart.colorCount;
            delete this.nonZonedColor;
            d.options.colorByPoint ? (b || (a3 = d.options.colors || d.chart.options.colors, c = a3[d.colorCounter], a3 = a3.length), b = d.colorCounter, d.colorCounter++, d.colorCounter === a3 && (d.colorCounter = 0)) : (b || (c = d.color), b = d.colorIndex);
            this.colorIndex = f(this.options.colorIndex, b);
            this.color = f(this.options.color, c);
          }
          setNestedProperty(d, b, c) {
            c.split(".").reduce(function(c2, d2, a3, f2) {
              c2[d2] = f2.length - 1 === a3 ? b : I(c2[d2], true) ? c2[d2] : {};
              return c2[d2];
            }, d);
            return d;
          }
          shouldDraw() {
            return !this.isNull;
          }
          tooltipFormatter(d) {
            const b = this.series, c = b.tooltipOptions, a3 = f(c.valueDecimals, ""), l2 = c.valuePrefix || "", e2 = c.valueSuffix || "";
            b.chart.styledMode && (d = b.chart.tooltip.styledModeFormat(d));
            (b.pointArrayMap || ["y"]).forEach(function(b2) {
              b2 = "{point." + b2;
              if (l2 || e2)
                d = d.replace(RegExp(b2 + "}", "g"), l2 + b2 + "}" + e2);
              d = d.replace(RegExp(b2 + "}", "g"), b2 + ":,." + a3 + "f}");
            });
            return B(d, { point: this, series: this.series }, b.chart);
          }
          update(d, b, c, a3) {
            function k() {
              l2.applyOptions(d);
              var a4 = g2 && l2.hasMockGraphic;
              a4 = null === l2.y ? !a4 : a4;
              g2 && a4 && (l2.graphic = g2.destroy(), delete l2.hasMockGraphic);
              I(d, true) && (g2 && g2.element && d && d.marker && "undefined" !== typeof d.marker.symbol && (l2.graphic = g2.destroy()), d && d.dataLabels && l2.dataLabel && (l2.dataLabel = l2.dataLabel.destroy()), l2.connector && (l2.connector = l2.connector.destroy()));
              y2 = l2.index;
              e2.updateParallelArrays(l2, y2);
              h2.data[y2] = I(h2.data[y2], true) || I(d, true) ? l2.options : f(d, h2.data[y2]);
              e2.isDirty = e2.isDirtyData = true;
              !e2.fixedBox && e2.hasCartesianSeries && (r2.isDirtyBox = true);
              "point" === h2.legendType && (r2.isDirtyLegend = true);
              b && r2.redraw(c);
            }
            const l2 = this, e2 = l2.series, g2 = l2.graphic, r2 = e2.chart, h2 = e2.options;
            let y2;
            b = f(b, true);
            false === a3 ? k() : l2.firePointEvent("update", { options: d }, k);
          }
          remove(d, b) {
            this.series.removePoint(
              this.series.data.indexOf(this),
              d,
              b
            );
          }
          select(d, b) {
            const c = this, a3 = c.series, l2 = a3.chart;
            this.selectedStaging = d = f(d, !c.selected);
            c.firePointEvent(d ? "select" : "unselect", { accumulate: b }, function() {
              c.selected = c.options.selected = d;
              a3.options.data[a3.data.indexOf(c)] = c.options;
              c.setState(d && "select");
              b || l2.getSelectedPoints().forEach(function(b2) {
                const d2 = b2.series;
                b2.selected && b2 !== c && (b2.selected = b2.options.selected = false, d2.options.data[d2.data.indexOf(b2)] = b2.options, b2.setState(l2.hoverPoints && d2.options.inactiveOtherPoints ? "inactive" : ""), b2.firePointEvent("unselect"));
              });
            });
            delete this.selectedStaging;
          }
          onMouseOver(d) {
            const b = this.series.chart, c = b.pointer;
            d = d ? c.normalize(d) : c.getChartCoordinatesFromPoint(this, b.inverted);
            c.runPointActions(d, this);
          }
          onMouseOut() {
            const d = this.series.chart;
            this.firePointEvent("mouseOut");
            this.series.options.inactiveOtherPoints || (d.hoverPoints || []).forEach(function(b) {
              b.setState();
            });
            d.hoverPoints = d.hoverPoint = null;
          }
          importEvents() {
            if (!this.hasImportedEvents) {
              const d = this, b = M(d.series.options.point, d.options).events;
              d.events = b;
              C(b, function(b2, a3) {
                e(b2) && t(d, a3, b2);
              });
              this.hasImportedEvents = true;
            }
          }
          setState(d, b) {
            const c = this.series;
            var k = this.state, l2 = c.options.states[d || "normal"] || {}, e2 = E.plotOptions[c.type].marker && c.options.marker;
            const g2 = e2 && false === e2.enabled, r2 = e2 && e2.states && e2.states[d || "normal"] || {}, h2 = false === r2.enabled, y2 = this.marker || {}, v2 = c.chart, m2 = e2 && c.markerAttribs;
            let q2 = c.halo;
            var t2;
            let I2;
            var u2 = c.stateMarkerGraphic;
            d = d || "";
            if (!(d === this.state && !b || this.selected && "select" !== d || false === l2.enabled || d && (h2 || g2 && false === r2.enabled) || d && y2.states && y2.states[d] && false === y2.states[d].enabled)) {
              this.state = d;
              m2 && (t2 = c.markerAttribs(this, d));
              if (this.graphic && !this.hasMockGraphic) {
                k && this.graphic.removeClass("highcharts-point-" + k);
                d && this.graphic.addClass("highcharts-point-" + d);
                if (!v2.styledMode) {
                  k = c.pointAttribs(this, d);
                  I2 = f(v2.options.chart.animation, l2.animation);
                  const b2 = k.opacity;
                  c.options.inactiveOtherPoints && x(b2) && ((this.dataLabels || []).forEach(function(c2) {
                    c2 && !c2.hasClass("highcharts-data-label-hidden") && c2.animate({ opacity: b2 }, I2);
                  }), this.connector && this.connector.animate({ opacity: b2 }, I2));
                  this.graphic.animate(
                    k,
                    I2
                  );
                }
                t2 && this.graphic.animate(t2, f(v2.options.chart.animation, r2.animation, e2.animation));
                u2 && u2.hide();
              } else {
                if (d && r2) {
                  e2 = y2.symbol || c.symbol;
                  u2 && u2.currentSymbol !== e2 && (u2 = u2.destroy());
                  if (t2)
                    if (u2)
                      u2[b ? "animate" : "attr"]({ x: t2.x, y: t2.y });
                    else
                      e2 && (c.stateMarkerGraphic = u2 = v2.renderer.symbol(e2, t2.x, t2.y, t2.width, t2.height).add(c.markerGroup), u2.currentSymbol = e2);
                  !v2.styledMode && u2 && "inactive" !== this.state && u2.attr(c.pointAttribs(this, d));
                }
                u2 && (u2[d && this.isInside ? "show" : "hide"](), u2.element.point = this, u2.addClass(this.getClassName(), true));
              }
              l2 = l2.halo;
              t2 = (u2 = this.graphic || u2) && u2.visibility || "inherit";
              l2 && l2.size && u2 && "hidden" !== t2 && !this.isCluster ? (q2 || (c.halo = q2 = v2.renderer.path().add(u2.parentGroup)), q2.show()[b ? "animate" : "attr"]({ d: this.haloPath(l2.size) }), q2.attr({ "class": "highcharts-halo highcharts-color-" + f(this.colorIndex, c.colorIndex) + (this.className ? " " + this.className : ""), visibility: t2, zIndex: -1 }), q2.point = this, v2.styledMode || q2.attr(p({ fill: this.color || c.color, "fill-opacity": l2.opacity }, a2.filterUserAttributes(l2.attributes || {})))) : q2 && q2.point && q2.point.haloPath && q2.animate({ d: q2.point.haloPath(0) }, null, q2.hide);
              n(this, "afterSetState", { state: d });
            }
          }
          haloPath(d) {
            const b = this.pos();
            return b ? this.series.chart.renderer.symbols.circle(Math.floor(b[0]) - d, b[1] - d, 2 * d, 2 * d) : [];
          }
        }
        "";
        return v;
      });
      L(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { parse: u } = a2, { charts: G, noop: D } = A, { addEvent: E, attr: B, css: t, defined: q, extend: m, find: p, fireEvent: n, isNumber: h, isObject: g, objectEach: e, offset: x, pick: I, splat: M } = J;
        class C {
          constructor(a3, e2) {
            this.lastValidTouch = {};
            this.pinchDown = [];
            this.runChartClick = false;
            this.eventsToUnbind = [];
            this.chart = a3;
            this.hasDragged = false;
            this.options = e2;
            this.init(a3, e2);
          }
          applyInactiveState(a3) {
            let f = [], e2;
            (a3 || []).forEach(function(a4) {
              e2 = a4.series;
              f.push(e2);
              e2.linkedParent && f.push(e2.linkedParent);
              e2.linkedSeries && (f = f.concat(e2.linkedSeries));
              e2.navigatorSeries && f.push(e2.navigatorSeries);
            });
            this.chart.series.forEach(function(a4) {
              -1 === f.indexOf(a4) ? a4.setState("inactive", true) : a4.options.inactiveOtherPoints && a4.setAllPointsToState("inactive");
            });
          }
          destroy() {
            const a3 = this;
            this.eventsToUnbind.forEach((a4) => a4());
            this.eventsToUnbind = [];
            A.chartCount || (C.unbindDocumentMouseUp && (C.unbindDocumentMouseUp = C.unbindDocumentMouseUp()), C.unbindDocumentTouchEnd && (C.unbindDocumentTouchEnd = C.unbindDocumentTouchEnd()));
            clearInterval(a3.tooltipTimeout);
            e(a3, function(f, e2) {
              a3[e2] = void 0;
            });
          }
          getSelectionMarkerAttrs(a3, e2) {
            const f = { args: { chartX: a3, chartY: e2 }, attrs: {}, shapeType: "rect" };
            n(this, "getSelectionMarkerAttrs", f, (f2) => {
              const { chart: l, mouseDownX: d = 0, mouseDownY: b = 0, zoomHor: c, zoomVert: k } = this;
              f2 = f2.attrs;
              let g2;
              f2.x = l.plotLeft;
              f2.y = l.plotTop;
              f2.width = c ? 1 : l.plotWidth;
              f2.height = k ? 1 : l.plotHeight;
              c && (g2 = a3 - d, f2.width = Math.abs(g2), f2.x = (0 < g2 ? 0 : g2) + d);
              k && (g2 = e2 - b, f2.height = Math.abs(g2), f2.y = (0 < g2 ? 0 : g2) + b);
            });
            return f;
          }
          drag(a3) {
            const f = this.chart, e2 = f.options.chart;
            var l = f.plotLeft;
            const h2 = f.plotTop, d = f.plotWidth, b = f.plotHeight, c = this.mouseDownX || 0, k = this.mouseDownY || 0, w = g(e2.panning) ? e2.panning && e2.panning.enabled : e2.panning, n2 = e2.panKey && a3[e2.panKey + "Key"];
            let m2 = a3.chartX, p2 = a3.chartY, q2 = this.selectionMarker;
            if (!q2 || !q2.touch) {
              if (m2 < l ? m2 = l : m2 > l + d && (m2 = l + d), p2 < h2 ? p2 = h2 : p2 > h2 + b && (p2 = h2 + b), this.hasDragged = Math.sqrt(Math.pow(c - m2, 2) + Math.pow(k - p2, 2)), 10 < this.hasDragged) {
                l = f.isInsidePlot(c - l, k - h2, { visiblePlotOnly: true });
                const { shapeType: b2, attrs: d2 } = this.getSelectionMarkerAttrs(m2, p2);
                !f.hasCartesianSeries && !f.mapView || !this.zoomX && !this.zoomY || !l || n2 || q2 || (this.selectionMarker = q2 = f.renderer[b2](), q2.attr({ "class": "highcharts-selection-marker", zIndex: 7 }).add(), f.styledMode || q2.attr({ fill: e2.selectionMarkerFill || u("#334eff").setOpacity(0.25).get() }));
                q2 && q2.attr(d2);
                l && !q2 && w && f.pan(a3, e2.panning);
              }
            }
          }
          dragStart(a3) {
            const f = this.chart;
            f.mouseIsDown = a3.type;
            f.cancelClick = false;
            f.mouseDownX = this.mouseDownX = a3.chartX;
            f.mouseDownY = this.mouseDownY = a3.chartY;
          }
          getSelectionBox(a3) {
            const f = { args: { marker: a3 }, result: {} };
            n(this, "getSelectionBox", f, (f2) => {
              f2.result = { x: a3.attr ? +a3.attr("x") : a3.x, y: a3.attr ? +a3.attr("y") : a3.y, width: a3.attr ? a3.attr("width") : a3.width, height: a3.attr ? a3.attr("height") : a3.height };
            });
            return f.result;
          }
          drop(a3) {
            const f = this, e2 = this.chart, l = this.hasPinched;
            if (this.selectionMarker) {
              const {
                x: g2,
                y: d,
                width: b,
                height: c
              } = this.getSelectionBox(this.selectionMarker), k = { originalEvent: a3, xAxis: [], yAxis: [], x: g2, y: d, width: b, height: c };
              let r = !!e2.mapView;
              if (this.hasDragged || l)
                e2.axes.forEach(function(e3) {
                  if (e3.zoomEnabled && q(e3.min) && (l || f[{ xAxis: "zoomX", yAxis: "zoomY" }[e3.coll]]) && h(g2) && h(d) && h(b) && h(c)) {
                    var w = e3.horiz;
                    const f2 = "touchend" === a3.type ? e3.minPixelPadding : 0, l2 = e3.toValue((w ? g2 : d) + f2);
                    w = e3.toValue((w ? g2 + b : d + c) - f2);
                    k[e3.coll].push({ axis: e3, min: Math.min(l2, w), max: Math.max(l2, w) });
                    r = true;
                  }
                }), r && n(e2, "selection", k, function(b2) {
                  e2.zoom(m(
                    b2,
                    l ? { animation: false } : null
                  ));
                });
              h(e2.index) && (this.selectionMarker = this.selectionMarker.destroy());
              l && this.scaleGroups();
            }
            e2 && h(e2.index) && (t(e2.container, { cursor: e2._cursor }), e2.cancelClick = 10 < this.hasDragged, e2.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
          }
          findNearestKDPoint(a3, e2, r) {
            let f;
            a3.forEach(function(a4) {
              var d = !(a4.noSharedTooltip && e2) && 0 > a4.options.findNearestPointBy.indexOf("y");
              a4 = a4.searchPoint(r, d);
              if ((d = g(a4, true) && a4.series) && !(d = !g(f, true))) {
                {
                  d = f.distX - a4.distX;
                  const b = f.dist - a4.dist, c = (a4.series.group && a4.series.group.zIndex) - (f.series.group && f.series.group.zIndex);
                  d = 0 !== d && e2 ? d : 0 !== b ? b : 0 !== c ? c : f.series.index > a4.series.index ? -1 : 1;
                }
                d = 0 < d;
              }
              d && (f = a4);
            });
            return f;
          }
          getChartCoordinatesFromPoint(a3, e2) {
            var f = a3.series;
            const l = f.xAxis;
            f = f.yAxis;
            const g2 = a3.shapeArgs;
            if (l && f) {
              let d = I(a3.clientX, a3.plotX), b = a3.plotY || 0;
              a3.isNode && g2 && h(g2.x) && h(g2.y) && (d = g2.x, b = g2.y);
              return e2 ? { chartX: f.len + f.pos - b, chartY: l.len + l.pos - d } : { chartX: d + l.pos, chartY: b + f.pos };
            }
            if (g2 && g2.x && g2.y)
              return { chartX: g2.x, chartY: g2.y };
          }
          getChartPosition() {
            if (this.chartPosition)
              return this.chartPosition;
            var { container: a3 } = this.chart;
            const e2 = x(a3);
            this.chartPosition = { left: e2.left, top: e2.top, scaleX: 1, scaleY: 1 };
            const g2 = a3.offsetWidth;
            a3 = a3.offsetHeight;
            2 < g2 && 2 < a3 && (this.chartPosition.scaleX = e2.width / g2, this.chartPosition.scaleY = e2.height / a3);
            return this.chartPosition;
          }
          getCoordinates(a3) {
            const f = { xAxis: [], yAxis: [] };
            this.chart.axes.forEach(function(e2) {
              f[e2.isXAxis ? "xAxis" : "yAxis"].push({ axis: e2, value: e2.toValue(a3[e2.horiz ? "chartX" : "chartY"]) });
            });
            return f;
          }
          getHoverData(a3, e2, h2, l, m2, d) {
            const b = [];
            l = !(!l || !a3);
            const c = function(b2) {
              return b2.visible && !(!m2 && b2.directTouch) && I(b2.options.enableMouseTracking, true);
            };
            let k, f = { chartX: d ? d.chartX : void 0, chartY: d ? d.chartY : void 0, shared: m2 };
            n(this, "beforeGetHoverData", f);
            k = e2 && !e2.stickyTracking ? [e2] : h2.filter((b2) => b2.stickyTracking && (f.filter || c)(b2));
            const r = l || !d ? a3 : this.findNearestKDPoint(k, m2, d);
            e2 = r && r.series;
            r && (m2 && !e2.noSharedTooltip ? (k = h2.filter(function(b2) {
              return f.filter ? f.filter(b2) : c(b2) && !b2.noSharedTooltip;
            }), k.forEach(function(c2) {
              let a4 = p(c2.points, function(b2) {
                return b2.x === r.x && !b2.isNull;
              });
              g(a4) && (c2.boosted && c2.boost && (a4 = c2.boost.getPoint(a4)), b.push(a4));
            })) : b.push(r));
            f = { hoverPoint: r };
            n(this, "afterGetHoverData", f);
            return { hoverPoint: f.hoverPoint, hoverSeries: e2, hoverPoints: b };
          }
          getPointFromEvent(a3) {
            a3 = a3.target;
            let f;
            for (; a3 && !f; )
              f = a3.point, a3 = a3.parentNode;
            return f;
          }
          onTrackerMouseOut(a3) {
            a3 = a3.relatedTarget;
            const f = this.chart.hoverSeries;
            this.isDirectTouch = false;
            if (!(!f || !a3 || f.stickyTracking || this.inClass(a3, "highcharts-tooltip") || this.inClass(a3, "highcharts-series-" + f.index) && this.inClass(a3, "highcharts-tracker")))
              f.onMouseOut();
          }
          inClass(a3, e2) {
            let f;
            for (; a3; ) {
              if (f = B(a3, "class")) {
                if (-1 !== f.indexOf(e2))
                  return true;
                if (-1 !== f.indexOf("highcharts-container"))
                  return false;
              }
              a3 = a3.parentElement;
            }
          }
          init(a3, e2) {
            this.options = e2;
            this.chart = a3;
            this.runChartClick = !(!e2.chart.events || !e2.chart.events.click);
            this.pinchDown = [];
            this.lastValidTouch = {};
            this.setDOMEvents();
            n(this, "afterInit");
          }
          normalize(a3, e2) {
            var f = a3.touches, l = f ? f.length ? f.item(0) : I(f.changedTouches, a3.changedTouches)[0] : a3;
            e2 || (e2 = this.getChartPosition());
            f = l.pageX - e2.left;
            l = l.pageY - e2.top;
            f /= e2.scaleX;
            l /= e2.scaleY;
            return m(a3, { chartX: Math.round(f), chartY: Math.round(l) });
          }
          onContainerClick(a3) {
            const f = this.chart, e2 = f.hoverPoint;
            a3 = this.normalize(a3);
            const l = f.plotLeft, g2 = f.plotTop;
            f.cancelClick || (e2 && this.inClass(a3.target, "highcharts-tracker") ? (n(e2.series, "click", m(a3, { point: e2 })), f.hoverPoint && e2.firePointEvent("click", a3)) : (m(a3, this.getCoordinates(a3)), f.isInsidePlot(a3.chartX - l, a3.chartY - g2, { visiblePlotOnly: true }) && n(f, "click", a3)));
          }
          onContainerMouseDown(a3) {
            const f = 1 === ((a3.buttons || a3.button) & 1);
            a3 = this.normalize(a3);
            if (A.isFirefox && 0 !== a3.button)
              this.onContainerMouseMove(a3);
            if ("undefined" === typeof a3.button || f)
              this.zoomOption(a3), f && a3.preventDefault && a3.preventDefault(), this.dragStart(a3);
          }
          onContainerMouseLeave(a3) {
            const f = G[I(C.hoverChartIndex, -1)];
            a3 = this.normalize(a3);
            f && a3.relatedTarget && !this.inClass(a3.relatedTarget, "highcharts-tooltip") && (f.pointer.reset(), f.pointer.chartPosition = void 0);
          }
          onContainerMouseEnter(a3) {
            delete this.chartPosition;
          }
          onContainerMouseMove(a3) {
            const f = this.chart, e2 = f.tooltip;
            a3 = this.normalize(a3);
            this.setHoverChartIndex();
            ("mousedown" === f.mouseIsDown || this.touchSelect(a3)) && this.drag(a3);
            f.openMenu || !this.inClass(a3.target, "highcharts-tracker") && !f.isInsidePlot(a3.chartX - f.plotLeft, a3.chartY - f.plotTop, { visiblePlotOnly: true }) || e2 && e2.shouldStickOnContact(a3) || (this.inClass(a3.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(a3));
          }
          onDocumentTouchEnd(a3) {
            const f = G[I(C.hoverChartIndex, -1)];
            f && f.pointer.drop(a3);
          }
          onContainerTouchMove(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseMove(a3);
            else
              this.touch(a3);
          }
          onContainerTouchStart(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseDown(a3);
            else
              this.zoomOption(a3), this.touch(a3, true);
          }
          onDocumentMouseMove(a3) {
            const f = this.chart, e2 = f.tooltip, l = this.chartPosition;
            a3 = this.normalize(a3, l);
            !l || f.isInsidePlot(a3.chartX - f.plotLeft, a3.chartY - f.plotTop, { visiblePlotOnly: true }) || e2 && e2.shouldStickOnContact(a3) || this.inClass(a3.target, "highcharts-tracker") || this.reset();
          }
          onDocumentMouseUp(a3) {
            const f = G[I(C.hoverChartIndex, -1)];
            f && f.pointer.drop(a3);
          }
          pinch(a3) {
            const f = this, e2 = f.chart, l = f.pinchDown, g2 = a3.touches || [], d = g2.length, b = f.lastValidTouch, c = f.hasZoom, k = {}, h2 = 1 === d && (f.inClass(a3.target, "highcharts-tracker") && e2.runTrackerClick || f.runChartClick), z = {};
            var F = f.chart.tooltip;
            F = 1 === d && I(F && F.options.followTouchMove, true);
            let p2 = f.selectionMarker;
            1 < d ? f.initiated = true : F && (f.initiated = false);
            c && f.initiated && !h2 && false !== a3.cancelable && a3.preventDefault();
            [].map.call(g2, function(b2) {
              return f.normalize(b2);
            });
            "touchstart" === a3.type ? ([].forEach.call(g2, function(b2, c2) {
              l[c2] = { chartX: b2.chartX, chartY: b2.chartY };
            }), b.x = [l[0].chartX, l[1] && l[1].chartX], b.y = [l[0].chartY, l[1] && l[1].chartY], e2.axes.forEach(function(b2) {
              if (b2.zoomEnabled) {
                const c2 = e2.bounds[b2.horiz ? "h" : "v"], a4 = b2.minPixelPadding, d2 = b2.toPixels(Math.min(I(b2.options.min, b2.dataMin), b2.dataMin)), k2 = b2.toPixels(Math.max(I(b2.options.max, b2.dataMax), b2.dataMax)), f2 = Math.max(d2, k2);
                c2.min = Math.min(b2.pos, Math.min(d2, k2) - a4);
                c2.max = Math.max(b2.pos + b2.len, f2 + a4);
              }
            }), f.res = true) : F ? this.runPointActions(f.normalize(a3)) : l.length && (n(e2, "touchpan", { originalEvent: a3 }, () => {
              p2 || (f.selectionMarker = p2 = m({ destroy: D, touch: true }, e2.plotBox));
              f.pinchTranslate(l, g2, k, p2, z, b);
              f.hasPinched = c;
              f.scaleGroups(k, z);
            }), f.res && (f.res = false, this.reset(
              false,
              0
            )));
          }
          pinchTranslate(a3, e2, g2, l, h2, d) {
            this.zoomHor && this.pinchTranslateDirection(true, a3, e2, g2, l, h2, d);
            this.zoomVert && this.pinchTranslateDirection(false, a3, e2, g2, l, h2, d);
          }
          pinchTranslateDirection(a3, e2, g2, l, h2, d, b, c) {
            const k = this.chart, f = a3 ? "x" : "y", r = a3 ? "X" : "Y", n2 = "chart" + r, m2 = a3 ? "width" : "height", v = k["plot" + (a3 ? "Left" : "Top")], y = k.inverted, p2 = k.bounds[a3 ? "h" : "v"], q2 = 1 === e2.length, x2 = e2[0][n2], t2 = !q2 && e2[1][n2];
            e2 = function() {
              "number" === typeof X && 20 < Math.abs(x2 - t2) && (C2 = c || Math.abs(N - X) / Math.abs(x2 - t2));
              I2 = (v - N) / C2 + x2;
              u2 = k["plot" + (a3 ? "Width" : "Height")] / C2;
            };
            let u2, I2, C2 = c || 1, N = g2[0][n2], X = !q2 && g2[1][n2], Q;
            e2();
            g2 = I2;
            g2 < p2.min ? (g2 = p2.min, Q = true) : g2 + u2 > p2.max && (g2 = p2.max - u2, Q = true);
            Q ? (N -= 0.8 * (N - b[f][0]), "number" === typeof X && (X -= 0.8 * (X - b[f][1])), e2()) : b[f] = [N, X];
            y || (d[f] = I2 - v, d[m2] = u2);
            d = y ? 1 / C2 : C2;
            h2[m2] = u2;
            h2[f] = g2;
            l[y ? a3 ? "scaleY" : "scaleX" : "scale" + r] = C2;
            l["translate" + r] = d * v + (N - d * x2);
          }
          reset(a3, e2) {
            const f = this.chart, l = f.hoverSeries, g2 = f.hoverPoint, d = f.hoverPoints, b = f.tooltip, c = b && b.shared ? d : g2;
            a3 && c && M(c).forEach(function(b2) {
              b2.series.isCartesian && "undefined" === typeof b2.plotX && (a3 = false);
            });
            if (a3)
              b && c && M(c).length && (b.refresh(c), b.shared && d ? d.forEach(function(b2) {
                b2.setState(b2.state, true);
                b2.series.isCartesian && (b2.series.xAxis.crosshair && b2.series.xAxis.drawCrosshair(null, b2), b2.series.yAxis.crosshair && b2.series.yAxis.drawCrosshair(null, b2));
              }) : g2 && (g2.setState(g2.state, true), f.axes.forEach(function(b2) {
                b2.crosshair && g2.series[b2.coll] === b2 && b2.drawCrosshair(null, g2);
              })));
            else {
              if (g2)
                g2.onMouseOut();
              d && d.forEach(function(b2) {
                b2.setState();
              });
              if (l)
                l.onMouseOut();
              b && b.hide(e2);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              f.axes.forEach(function(b2) {
                b2.hideCrosshair();
              });
              this.hoverX = f.hoverPoints = f.hoverPoint = null;
            }
          }
          runPointActions(a3, e2, g2) {
            const f = this.chart, h2 = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0, d = h2 ? h2.shared : false;
            let b = e2 || f.hoverPoint, c = b && b.series || f.hoverSeries;
            e2 = this.getHoverData(b, c, f.series, (!a3 || "touchmove" !== a3.type) && (!!e2 || c && c.directTouch && this.isDirectTouch), d, a3);
            b = e2.hoverPoint;
            c = e2.hoverSeries;
            const k = e2.hoverPoints;
            e2 = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;
            const w = d && c && !c.noSharedTooltip;
            if (b && (g2 || b !== f.hoverPoint || h2 && h2.isHidden)) {
              (f.hoverPoints || []).forEach(function(b2) {
                -1 === k.indexOf(b2) && b2.setState();
              });
              if (f.hoverSeries !== c)
                c.onMouseOver();
              this.applyInactiveState(k);
              (k || []).forEach(function(b2) {
                b2.setState("hover");
              });
              f.hoverPoint && f.hoverPoint.firePointEvent("mouseOut");
              if (!b.series)
                return;
              f.hoverPoints = k;
              f.hoverPoint = b;
              b.firePointEvent("mouseOver", void 0, () => {
                h2 && b && h2.refresh(w ? k : b, a3);
              });
            } else
              e2 && h2 && !h2.isHidden && (g2 = h2.getAnchor([{}], a3), f.isInsidePlot(g2[0], g2[1], { visiblePlotOnly: true }) && h2.updatePosition({
                plotX: g2[0],
                plotY: g2[1]
              }));
            this.unDocMouseMove || (this.unDocMouseMove = E(f.container.ownerDocument, "mousemove", function(b2) {
              const c2 = G[C.hoverChartIndex];
              if (c2)
                c2.pointer.onDocumentMouseMove(b2);
            }), this.eventsToUnbind.push(this.unDocMouseMove));
            f.axes.forEach(function(b2) {
              const c2 = I((b2.crosshair || {}).snap, true);
              let d2;
              c2 && ((d2 = f.hoverPoint) && d2.series[b2.coll] === b2 || (d2 = p(k, (c3) => c3.series && c3.series[b2.coll] === b2)));
              d2 || !c2 ? b2.drawCrosshair(a3, d2) : b2.hideCrosshair();
            });
          }
          scaleGroups(a3, e2) {
            const f = this.chart;
            f.series.forEach(function(l) {
              const g2 = a3 || l.getPlotBox();
              l.group && (l.xAxis && l.xAxis.zoomEnabled || f.mapView) && (l.group.attr(g2), l.markerGroup && (l.markerGroup.attr(g2), l.markerGroup.clip(e2 ? f.clipRect : null)), l.dataLabelsGroup && l.dataLabelsGroup.attr(g2));
            });
            f.clipRect.attr(e2 || f.clipBox);
          }
          setDOMEvents() {
            const a3 = this.chart.container, e2 = a3.ownerDocument;
            a3.onmousedown = this.onContainerMouseDown.bind(this);
            a3.onmousemove = this.onContainerMouseMove.bind(this);
            a3.onclick = this.onContainerClick.bind(this);
            this.eventsToUnbind.push(E(a3, "mouseenter", this.onContainerMouseEnter.bind(this)));
            this.eventsToUnbind.push(E(a3, "mouseleave", this.onContainerMouseLeave.bind(this)));
            C.unbindDocumentMouseUp || (C.unbindDocumentMouseUp = E(e2, "mouseup", this.onDocumentMouseUp.bind(this)));
            let g2 = this.chart.renderTo.parentElement;
            for (; g2 && "BODY" !== g2.tagName; )
              this.eventsToUnbind.push(E(g2, "scroll", () => {
                delete this.chartPosition;
              })), g2 = g2.parentElement;
            A.hasTouch && (this.eventsToUnbind.push(E(a3, "touchstart", this.onContainerTouchStart.bind(this), { passive: false })), this.eventsToUnbind.push(E(
              a3,
              "touchmove",
              this.onContainerTouchMove.bind(this),
              { passive: false }
            )), C.unbindDocumentTouchEnd || (C.unbindDocumentTouchEnd = E(e2, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })));
          }
          setHoverChartIndex() {
            const a3 = this.chart, e2 = A.charts[I(C.hoverChartIndex, -1)];
            if (e2 && e2 !== a3)
              e2.pointer.onContainerMouseLeave({ relatedTarget: a3.container });
            e2 && e2.mouseIsDown || (C.hoverChartIndex = a3.index);
          }
          touch(a3, e2) {
            const f = this.chart;
            let l, g2;
            this.setHoverChartIndex();
            1 === a3.touches.length ? (a3 = this.normalize(a3), (g2 = f.isInsidePlot(a3.chartX - f.plotLeft, a3.chartY - f.plotTop, { visiblePlotOnly: true })) && !f.openMenu ? (e2 && this.runPointActions(a3), "touchmove" === a3.type && (e2 = this.pinchDown, l = e2[0] ? 4 <= Math.sqrt(Math.pow(e2[0].chartX - a3.chartX, 2) + Math.pow(e2[0].chartY - a3.chartY, 2)) : false), I(l, true) && this.pinch(a3)) : e2 && this.reset()) : 2 === a3.touches.length && this.pinch(a3);
          }
          touchSelect(a3) {
            return !(!this.chart.zooming.singleTouch || !a3.touches || 1 !== a3.touches.length);
          }
          zoomOption(a3) {
            const f = this.chart, e2 = f.inverted;
            var l = f.zooming.type || "";
            /touch/.test(a3.type) && (l = I(f.zooming.pinchType, l));
            this.zoomX = a3 = /x/.test(l);
            this.zoomY = l = /y/.test(l);
            this.zoomHor = a3 && !e2 || l && e2;
            this.zoomVert = l && !e2 || a3 && e2;
            this.hasZoom = a3 || l;
          }
        }
        (function(a3) {
          const f = [], e2 = [];
          a3.compose = function(f2) {
            J.pushUnique(e2, f2) && E(f2, "beforeRender", function() {
              this.pointer = new a3(this, this.options);
            });
          };
          a3.dissolve = function() {
            for (let a4 = 0, e3 = f.length; a4 < e3; ++a4)
              f[a4]();
            f.length = 0;
          };
        })(C || (C = {}));
        "";
        return C;
      });
      L(
        a,
        "Core/Legend/Legend.js",
        [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]],
        function(a2, A, J, K, G, D) {
          const { animObject: u, setAnimation: B } = a2, { format: t } = A, { marginNames: q } = J, { distribute: m } = G, { addEvent: p, createElement: n, css: h, defined: g, discardElement: e, find: x, fireEvent: I, isNumber: M, merge: C, pick: f, relativeLength: y, stableSort: r, syncTimeout: l } = D;
          class v {
            constructor(a3, b) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = false;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = void 0;
              this.padding = 0;
              this.pages = [];
              this.proximate = false;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = a3;
              this.init(a3, b);
            }
            init(a3, b) {
              this.chart = a3;
              this.setOptions(b);
              b.enabled && (this.render(), p(this.chart, "endResize", function() {
                this.legend.positionCheckboxes();
              }), p(this.chart, "render", () => {
                this.proximate && (this.proximatePositions(), this.positionItems());
              }));
            }
            setOptions(a3) {
              const b = f(a3.padding, 8);
              this.options = a3;
              this.chart.styledMode || (this.itemStyle = a3.itemStyle, this.itemHiddenStyle = C(this.itemStyle, a3.itemHiddenStyle));
              this.itemMarginTop = a3.itemMarginTop;
              this.itemMarginBottom = a3.itemMarginBottom;
              this.padding = b;
              this.initialItemY = b - 5;
              this.symbolWidth = f(a3.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === a3.layout && !this.chart.inverted;
              this.baseline = void 0;
            }
            update(a3, b) {
              const c = this.chart;
              this.setOptions(C(true, this.options, a3));
              this.destroy();
              c.isDirtyLegend = c.isDirtyBox = true;
              f(b, true) && c.redraw();
              I(this, "afterUpdate");
            }
            colorizeItem(a3, b) {
              const { group: c, label: d, line: f2, symbol: e2 } = a3.legendItem || {};
              if (c)
                c[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
              if (!this.chart.styledMode) {
                const { itemHiddenStyle: c2 } = this, k = c2.color, l2 = b ? a3.color || k : k, g2 = a3.options && a3.options.marker;
                let h2 = { fill: l2 };
                null === d || void 0 === d ? void 0 : d.css(C(b ? this.itemStyle : c2));
                null === f2 || void 0 === f2 ? void 0 : f2.attr({ stroke: l2 });
                e2 && (g2 && e2.isMarker && (h2 = a3.pointAttribs(), b || (h2.stroke = h2.fill = k)), e2.attr(h2));
              }
              I(this, "afterColorizeItem", { item: a3, visible: b });
            }
            positionItems() {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(a3) {
              const { group: b, x: c = 0, y: d = 0 } = a3.legendItem || {};
              var f2 = this.options, e2 = f2.symbolPadding;
              const l2 = !f2.rtl;
              f2 = a3.checkbox;
              b && b.element && (e2 = { translateX: l2 ? c : this.legendWidth - c - 2 * e2 - 4, translateY: d }, b[g(b.translateY) ? "animate" : "attr"](e2, void 0, () => {
                I(this, "afterPositionItem", { item: a3 });
              }));
              f2 && (f2.x = c, f2.y = d);
            }
            destroyItem(a3) {
              const b = a3.checkbox, c = a3.legendItem || {};
              for (const b2 of ["group", "label", "line", "symbol"])
                c[b2] && (c[b2] = c[b2].destroy());
              b && e(b);
              a3.legendItem = void 0;
            }
            destroy() {
              for (const a3 of this.getAllItems())
                this.destroyItem(a3);
              for (const a3 of "clipRect up down pager nav box title group".split(" "))
                this[a3] && (this[a3] = this[a3].destroy());
              this.display = null;
            }
            positionCheckboxes() {
              const a3 = this.group && this.group.alignAttr, b = this.clipHeight || this.legendHeight, c = this.titleHeight;
              let k;
              a3 && (k = a3.translateY, this.allItems.forEach(function(d) {
                const f2 = d.checkbox;
                let e2;
                f2 && (e2 = k + c + f2.y + (this.scrollOffset || 0) + 3, h(f2, { left: a3.translateX + d.checkboxOffset + f2.x - 20 + "px", top: e2 + "px", display: this.proximate || e2 > k - 6 && e2 < k + b - 6 ? "" : "none" }));
              }, this));
            }
            renderTitle() {
              var a3 = this.options;
              const b = this.padding, c = a3.title;
              let k = 0;
              c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, void 0, void 0, void 0, a3.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({ width: this.maxLegendWidth + "px" }), a3 = this.title.getBBox(), k = a3.height, this.offsetWidth = a3.width, this.contentGroup.attr({ translateY: k }));
              this.titleHeight = k;
            }
            setText(a3) {
              const b = this.options;
              a3.legendItem.label.attr({ text: b.labelFormat ? t(b.labelFormat, a3, this.chart) : b.labelFormatter.call(a3) });
            }
            renderItem(a3) {
              const b = a3.legendItem = a3.legendItem || {};
              var c = this.chart, d = c.renderer;
              const e2 = this.options, l2 = this.symbolWidth, g2 = e2.symbolPadding || 0, h2 = this.itemStyle, n2 = this.itemHiddenStyle, r2 = "horizontal" === e2.layout ? f(e2.itemDistance, 20) : 0, m2 = !e2.rtl, v2 = !a3.series, p2 = !v2 && a3.series.drawLegendSymbol ? a3.series : a3;
              var q2 = p2.options;
              const y2 = this.createCheckboxForItem && q2 && q2.showCheckbox, x2 = e2.useHTML, t2 = a3.options.className;
              let N = b.label;
              q2 = l2 + g2 + r2 + (y2 ? 20 : 0);
              N || (b.group = d.g("legend-item").addClass("highcharts-" + p2.type + "-series highcharts-color-" + a3.colorIndex + (t2 ? " " + t2 : "") + (v2 ? " highcharts-series-" + a3.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), b.label = N = d.text("", m2 ? l2 + g2 : -g2, this.baseline || 0, x2), c.styledMode || N.css(C(a3.visible ? h2 : n2)), N.attr({ align: m2 ? "left" : "right", zIndex: 2 }).add(b.group), this.baseline || (this.fontMetrics = d.fontMetrics(N), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, N.attr("y", this.baseline), this.symbolHeight = f(e2.symbolHeight, this.fontMetrics.f), e2.squareSymbol && (this.symbolWidth = f(e2.symbolWidth, Math.max(this.symbolHeight, 16)), q2 = this.symbolWidth + g2 + r2 + (y2 ? 20 : 0), m2 && N.attr("x", this.symbolWidth + g2))), p2.drawLegendSymbol(this, a3), this.setItemEvents && this.setItemEvents(a3, N, x2));
              y2 && !a3.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a3);
              this.colorizeItem(
                a3,
                a3.visible
              );
              !c.styledMode && h2.width || N.css({ width: (e2.itemWidth || this.widthOption || c.spacingBox.width) - q2 + "px" });
              this.setText(a3);
              c = N.getBBox();
              d = this.fontMetrics && this.fontMetrics.h || 0;
              a3.itemWidth = a3.checkboxOffset = e2.itemWidth || b.labelWidth || c.width + q2;
              this.maxItemWidth = Math.max(this.maxItemWidth, a3.itemWidth);
              this.totalItemWidth += a3.itemWidth;
              this.itemHeight = a3.itemHeight = Math.round(b.labelHeight || (c.height > 1.5 * d ? c.height : d));
            }
            layoutItem(a3) {
              var b = this.options;
              const c = this.padding, d = "horizontal" === b.layout, e2 = a3.itemHeight, l2 = this.itemMarginBottom, g2 = this.itemMarginTop, h2 = d ? f(b.itemDistance, 20) : 0, n2 = this.maxLegendWidth;
              b = b.alignColumns && this.totalItemWidth > n2 ? this.maxItemWidth : a3.itemWidth;
              const r2 = a3.legendItem || {};
              d && this.itemX - c + b > n2 && (this.itemX = c, this.lastLineHeight && (this.itemY += g2 + this.lastLineHeight + l2), this.lastLineHeight = 0);
              this.lastItemY = g2 + this.itemY + l2;
              this.lastLineHeight = Math.max(e2, this.lastLineHeight);
              r2.x = this.itemX;
              r2.y = this.itemY;
              d ? this.itemX += b : (this.itemY += g2 + e2 + l2, this.lastLineHeight = e2);
              this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (a3.checkbox ? 0 : h2) : b) + c, this.offsetWidth);
            }
            getAllItems() {
              let a3 = [];
              this.chart.series.forEach(function(b) {
                const c = b && b.options;
                b && f(c.showInLegend, g(c.linkedTo) ? false : void 0, true) && (a3 = a3.concat((b.legendItem || {}).labels || ("point" === c.legendType ? b.data : b)));
              });
              I(this, "afterGetAllItems", { allItems: a3 });
              return a3;
            }
            getAlignment() {
              const a3 = this.options;
              return this.proximate ? a3.align.charAt(0) + "tv" : a3.floating ? "" : a3.align.charAt(0) + a3.verticalAlign.charAt(0) + a3.layout.charAt(0);
            }
            adjustMargins(a3, b) {
              const c = this.chart, d = this.options, e2 = this.getAlignment();
              e2 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(k, l2) {
                k.test(e2) && !g(a3[l2]) && (c[q[l2]] = Math.max(c[q[l2]], c.legend[(l2 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l2] * d[l2 % 2 ? "x" : "y"] + f(d.margin, 12) + b[l2] + (c.titleOffset[l2] || 0)));
              });
            }
            proximatePositions() {
              const a3 = this.chart, b = [], c = "left" === this.options.align;
              this.allItems.forEach(function(d) {
                var k2;
                var f2 = c;
                let e2;
                d.yAxis && (d.xAxis.options.reversed && (f2 = !f2), d.points && (k2 = x(f2 ? d.points : d.points.slice(0).reverse(), function(b2) {
                  return M(b2.plotY);
                })), f2 = this.itemMarginTop + d.legendItem.label.getBBox().height + this.itemMarginBottom, e2 = d.yAxis.top - a3.plotTop, d.visible ? (k2 = k2 ? k2.plotY : d.yAxis.height, k2 += e2 - 0.3 * f2) : k2 = e2 + d.yAxis.height, b.push({ target: k2, size: f2, item: d }));
              }, this);
              let k;
              for (const c2 of m(b, a3.plotHeight))
                k = c2.item.legendItem || {}, M(c2.pos) && (k.y = a3.plotTop - a3.spacing[0] + c2.pos);
            }
            render() {
              const a3 = this.chart, b = a3.renderer, c = this.options, k = this.padding;
              var f2 = this.getAllItems();
              let e2, l2 = this.group, g2 = this.box;
              this.itemX = k;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = y(c.width, a3.spacingBox.width - k);
              var h2 = a3.spacingBox.width - 2 * k - c.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (h2 /= 2);
              this.maxLegendWidth = this.widthOption || h2;
              l2 || (this.group = l2 = b.g("legend").addClass(c.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = b.g().attr({ zIndex: 1 }).add(l2), this.scrollGroup = b.g().add(this.contentGroup));
              this.renderTitle();
              r(f2, (b2, c2) => (b2.options && b2.options.legendIndex || 0) - (c2.options && c2.options.legendIndex || 0));
              c.reversed && f2.reverse();
              this.allItems = f2;
              this.display = h2 = !!f2.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              f2.forEach(this.renderItem, this);
              f2.forEach(this.layoutItem, this);
              f2 = (this.widthOption || this.offsetWidth) + k;
              e2 = this.lastItemY + this.lastLineHeight + this.titleHeight;
              e2 = this.handleOverflow(e2);
              e2 += k;
              g2 || (this.box = g2 = b.rect().addClass("highcharts-legend-box").attr({ r: c.borderRadius }).add(l2));
              a3.styledMode || g2.attr({
                stroke: c.borderColor,
                "stroke-width": c.borderWidth || 0,
                fill: c.backgroundColor || "none"
              }).shadow(c.shadow);
              if (0 < f2 && 0 < e2)
                g2[g2.placed ? "animate" : "attr"](g2.crisp.call({}, { x: 0, y: 0, width: f2, height: e2 }, g2.strokeWidth()));
              l2[h2 ? "show" : "hide"]();
              a3.styledMode && "none" === l2.getStyle("display") && (f2 = e2 = 0);
              this.legendWidth = f2;
              this.legendHeight = e2;
              h2 && this.align();
              this.proximate || this.positionItems();
              I(this, "afterRender");
            }
            align(a3 = this.chart.spacingBox) {
              const b = this.chart, c = this.options;
              let d = a3.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d -= b.titleOffset[2]);
              d !== a3.y && (a3 = C(a3, { y: d }));
              b.hasRendered || (this.group.placed = false);
              this.group.align(C(c, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : c.verticalAlign }), true, a3);
            }
            handleOverflow(a3) {
              const b = this, c = this.chart, d = c.renderer, e2 = this.options;
              var l2 = e2.y;
              const g2 = "top" === e2.verticalAlign, h2 = this.padding, n2 = e2.maxHeight, r2 = e2.navigation, m2 = f(r2.animation, true), v2 = r2.arrowSize || 12, p2 = this.pages, q2 = this.allItems, y2 = function(c2) {
                "number" === typeof c2 ? I2.attr({ height: c2 }) : I2 && (b.clipRect = I2.destroy(), b.contentGroup.clip());
                b.contentGroup.div && (b.contentGroup.div.style.clip = c2 ? "rect(" + h2 + "px,9999px," + (h2 + c2) + "px,0)" : "auto");
              }, x2 = function(a4) {
                b[a4] = d.circle(0, 0, 1.3 * v2).translate(v2 / 2, v2 / 2).add(Q);
                c.styledMode || b[a4].attr("fill", "rgba(0,0,0,0.0001)");
                return b[a4];
              };
              let t2, N, u2;
              l2 = c.spacingBox.height + (g2 ? -l2 : l2) - h2;
              let Q = this.nav, I2 = this.clipRect;
              "horizontal" !== e2.layout || "middle" === e2.verticalAlign || e2.floating || (l2 /= 2);
              n2 && (l2 = Math.min(l2, n2));
              p2.length = 0;
              a3 && 0 < l2 && a3 > l2 && false !== r2.enabled ? (this.clipHeight = t2 = Math.max(l2 - 20 - this.titleHeight - h2, 0), this.currentPage = f(this.currentPage, 1), this.fullHeight = a3, q2.forEach((b2, c2) => {
                u2 = b2.legendItem || {};
                b2 = u2.y || 0;
                const a4 = Math.round(u2.label.getBBox().height);
                let d2 = p2.length;
                if (!d2 || b2 - p2[d2 - 1] > t2 && (N || b2) !== p2[d2 - 1])
                  p2.push(N || b2), d2++;
                u2.pageIx = d2 - 1;
                N && ((q2[c2 - 1].legendItem || {}).pageIx = d2 - 1);
                c2 === q2.length - 1 && b2 + a4 - p2[d2 - 1] > t2 && b2 > p2[d2 - 1] && (p2.push(b2), u2.pageIx = d2);
                b2 !== N && (N = b2);
              }), I2 || (I2 = b.clipRect = d.clipRect(0, h2 - 2, 9999, 0), b.contentGroup.clip(I2)), y2(t2), Q || (this.nav = Q = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol("triangle", 0, 0, v2, v2).add(Q), x2("upTracker").on("click", function() {
                b.scroll(-1, m2);
              }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && r2.style && this.pager.css(r2.style), this.pager.add(Q), this.down = d.symbol("triangle-down", 0, 0, v2, v2).add(Q), x2("downTracker").on("click", function() {
                b.scroll(1, m2);
              })), b.scroll(0), a3 = l2) : Q && (y2(), this.nav = Q.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
              return a3;
            }
            scroll(a3, b) {
              const c = this.chart, d = this.pages, e2 = d.length, g2 = this.clipHeight, h2 = this.options.navigation, n2 = this.pager, r2 = this.padding;
              let m2 = this.currentPage + a3;
              m2 > e2 && (m2 = e2);
              0 < m2 && ("undefined" !== typeof b && B(b, c), this.nav.attr({ translateX: r2, translateY: g2 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(b2) {
                b2.attr({ "class": 1 === m2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
              }), n2.attr({ text: m2 + "/" + e2 }), [this.down, this.downTracker].forEach(function(b2) {
                b2.attr({ x: 18 + this.pager.getBBox().width, "class": m2 === e2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
              }, this), c.styledMode || (this.up.attr({ fill: 1 === m2 ? h2.inactiveColor : h2.activeColor }), this.upTracker.css({ cursor: 1 === m2 ? "default" : "pointer" }), this.down.attr({ fill: m2 === e2 ? h2.inactiveColor : h2.activeColor }), this.downTracker.css({ cursor: m2 === e2 ? "default" : "pointer" })), this.scrollOffset = -d[m2 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = m2, this.positionCheckboxes(), a3 = u(f(b, c.renderer.globalAnimation, true)), l(() => {
                I(this, "afterScroll", { currentPage: m2 });
              }, a3.duration));
            }
            setItemEvents(a3, b, c) {
              const d = this, f2 = a3.legendItem || {}, e2 = d.chart.renderer.boxWrapper, l2 = a3 instanceof K, g2 = "highcharts-legend-" + (l2 ? "point" : "series") + "-active", h2 = d.chart.styledMode;
              c = c ? [b, f2.symbol] : [f2.group];
              const n2 = (b2) => {
                d.allItems.forEach((c2) => {
                  a3 !== c2 && [c2].concat(c2.linkedSeries || []).forEach((c3) => {
                    c3.setState(b2, !l2);
                  });
                });
              };
              for (const k of c)
                if (k)
                  k.on("mouseover", function() {
                    a3.visible && n2("inactive");
                    a3.setState("hover");
                    a3.visible && e2.addClass(g2);
                    h2 || b.css(d.options.itemHoverStyle);
                  }).on("mouseout", function() {
                    d.chart.styledMode || b.css(C(a3.visible ? d.itemStyle : d.itemHiddenStyle));
                    n2("");
                    e2.removeClass(g2);
                    a3.setState();
                  }).on("click", function(b2) {
                    const c2 = function() {
                      a3.setVisible && a3.setVisible();
                      n2(a3.visible ? "inactive" : "");
                    };
                    e2.removeClass(g2);
                    b2 = { browserEvent: b2 };
                    a3.firePointEvent ? a3.firePointEvent("legendItemClick", b2, c2) : I(a3, "legendItemClick", b2, c2);
                  });
            }
            createCheckboxForItem(a3) {
              a3.checkbox = n("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: a3.selected,
                defaultChecked: a3.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              p(a3.checkbox, "click", function(b) {
                I(a3.series || a3, "checkboxClick", { checked: b.target.checked, item: a3 }, function() {
                  a3.select();
                });
              });
            }
          }
          (function(a3) {
            const b = [];
            a3.compose = function(c) {
              D.pushUnique(b, c) && p(c, "beforeMargins", function() {
                this.legend = new a3(this, this.options.legend);
              });
            };
          })(v || (v = {}));
          "";
          return v;
        }
      );
      L(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function(a2) {
        const { extend: u, merge: J, pick: K } = a2;
        var G;
        (function(a3) {
          a3.lineMarker = function(a4, B) {
            B = this.legendItem = this.legendItem || {};
            var t = this.options;
            const q = a4.symbolWidth, m = a4.symbolHeight, p = m / 2, n = this.chart.renderer, h = B.group;
            a4 = a4.baseline - Math.round(0.3 * a4.fontMetrics.b);
            let g = {}, e = t.marker, x = 0;
            this.chart.styledMode || (g = { "stroke-width": Math.min(t.lineWidth || 0, 24) }, t.dashStyle ? g.dashstyle = t.dashStyle : "square" !== t.linecap && (g["stroke-linecap"] = "round"));
            B.line = n.path().addClass("highcharts-graph").attr(g).add(h);
            g["stroke-linecap"] && (x = Math.min(
              B.line.strokeWidth(),
              q
            ) / 2);
            q && B.line.attr({ d: [["M", x, a4], ["L", q - x, a4]] });
            e && false !== e.enabled && q && (t = Math.min(K(e.radius, p), p), 0 === this.symbol.indexOf("url") && (e = J(e, { width: m, height: m }), t = 0), B.symbol = B = n.symbol(this.symbol, q / 2 - t, a4 - t, 2 * t, 2 * t, u({ context: "legend" }, e)).addClass("highcharts-point").add(h), B.isMarker = true);
          };
          a3.rectangle = function(a4, u2) {
            u2 = u2.legendItem || {};
            const t = a4.symbolHeight, q = a4.options.squareSymbol;
            u2.symbol = this.chart.renderer.rect(q ? (a4.symbolWidth - t) / 2 : 0, a4.baseline - t + 1, q ? t : a4.symbolWidth, t, K(
              a4.options.symbolRadius,
              t / 2
            )).addClass("highcharts-point").attr({ zIndex: 3 }).add(u2.group);
          };
        })(G || (G = {}));
        return G;
      });
      L(a, "Core/Series/SeriesDefaults.js", [], function() {
        return {
          lineWidth: 1,
          allowPointSelect: false,
          crisp: true,
          showCheckbox: false,
          animation: { duration: 1e3 },
          enableMouseTracking: true,
          events: {},
          marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } },
          point: { events: {} },
          dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
            const { numberFormatter: a2 } = this.series.chart;
            return "number" !== typeof this.y ? "" : a2(this.y, -1);
          }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: true,
          states: {
            normal: { animation: true },
            hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } },
            select: { animation: { duration: 0 } },
            inactive: { animation: { duration: 150 }, opacity: 0.2 }
          },
          stickyTracking: true,
          turboThreshold: 1e3,
          findNearestPointBy: "x"
        };
      });
      L(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/Defaults.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, A, J, K) {
        const { defaultOptions: u } = A, { extendClass: D, merge: E } = K;
        var B;
        (function(t) {
          function q(a3, p) {
            const n = u.plotOptions || {}, h = p.defaultOptions, g = p.prototype;
            g.type = a3;
            g.pointClass || (g.pointClass = J);
            h && (n[a3] = h);
            t.seriesTypes[a3] = p;
          }
          t.seriesTypes = a2.seriesTypes;
          t.registerSeriesType = q;
          t.seriesType = function(a3, p, n, h, g) {
            const e = u.plotOptions || {};
            p = p || "";
            e[a3] = E(e[p], n);
            q(a3, D(t.seriesTypes[p] || function() {
            }, h));
            t.seriesTypes[a3].prototype.type = a3;
            g && (t.seriesTypes[a3].prototype.pointClass = D(J, g));
            return t.seriesTypes[a3];
          };
        })(B || (B = {}));
        return B;
      });
      L(a, "Core/Series/Series.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Legend/LegendSymbol.js"],
        a["Core/Series/Point.js"],
        a["Core/Series/SeriesDefaults.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G, D, E, B, t, q) {
        const { animObject: m, setAnimation: p } = a2, { defaultOptions: n } = A, { registerEventOptions: h } = J, { hasTouch: g, svg: e, win: x } = K, { seriesTypes: u } = B, {
          arrayMax: M,
          arrayMin: C,
          clamp: f,
          correctFloat: y,
          defined: r,
          diffObjects: l,
          erase: v,
          error: d,
          extend: b,
          find: c,
          fireEvent: k,
          getClosestDistance: w,
          getNestedProperty: z,
          insertItem: F,
          isArray: O,
          isNumber: P,
          isString: T,
          merge: U,
          objectEach: W,
          pick: H,
          removeEvent: Y,
          splat: ea,
          syncTimeout: aa
        } = q;
        class Z {
          constructor() {
            this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
          }
          init(c2, a3) {
            k(this, "init", { options: a3 });
            const d2 = this, f2 = c2.series;
            this.eventsToUnbind = [];
            d2.chart = c2;
            d2.options = d2.setOptions(a3);
            a3 = d2.options;
            d2.linkedSeries = [];
            d2.bindAxes();
            b(d2, { name: a3.name, state: "", visible: false !== a3.visible, selected: true === a3.selected });
            h(this, a3);
            const e2 = a3.events;
            if (e2 && e2.click || a3.point && a3.point.events && a3.point.events.click || a3.allowPointSelect)
              c2.runTrackerClick = true;
            d2.getColor();
            d2.getSymbol();
            d2.parallelArrays.forEach(function(b2) {
              d2[b2 + "Data"] || (d2[b2 + "Data"] = []);
            });
            d2.isCartesian && (c2.hasCartesianSeries = true);
            let l2;
            f2.length && (l2 = f2[f2.length - 1]);
            d2._i = H(l2 && l2._i, -1) + 1;
            d2.opacity = d2.options.opacity;
            c2.orderItems("series", F(this, f2));
            a3.dataSorting && a3.dataSorting.enabled ? d2.setDataSortingOptions() : d2.points || d2.data || d2.setData(a3.data, false);
            k(
              this,
              "afterInit"
            );
          }
          is(b2) {
            return u[b2] && this instanceof u[b2];
          }
          bindAxes() {
            const b2 = this, c2 = b2.options, a3 = b2.chart;
            let f2;
            k(this, "bindAxes", null, function() {
              (b2.axisTypes || []).forEach(function(k2) {
                a3[k2].forEach(function(a4) {
                  f2 = a4.options;
                  if (H(c2[k2], 0) === a4.index || "undefined" !== typeof c2[k2] && c2[k2] === f2.id)
                    F(b2, a4.series), b2[k2] = a4, a4.isDirty = true;
                });
                b2[k2] || b2.optionalAxis === k2 || d(18, true, a3);
              });
            });
            k(this, "afterBindAxes");
          }
          updateParallelArrays(b2, c2, a3) {
            const d2 = b2.series, k2 = P(c2) ? function(a4) {
              const k3 = "y" === a4 && d2.toYData ? d2.toYData(b2) : b2[a4];
              d2[a4 + "Data"][c2] = k3;
            } : function(b3) {
              Array.prototype[c2].apply(d2[b3 + "Data"], a3);
            };
            d2.parallelArrays.forEach(k2);
          }
          hasData() {
            return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
          }
          autoIncrement(b2) {
            var c2 = this.options;
            const a3 = c2.pointIntervalUnit, d2 = c2.relativeXValue, k2 = this.chart.time;
            let f2 = this.xIncrement, e2;
            f2 = H(f2, c2.pointStart, 0);
            this.pointInterval = e2 = H(this.pointInterval, c2.pointInterval, 1);
            d2 && P(b2) && (e2 *= b2);
            a3 && (c2 = new k2.Date(f2), "day" === a3 ? k2.set("Date", c2, k2.get(
              "Date",
              c2
            ) + e2) : "month" === a3 ? k2.set("Month", c2, k2.get("Month", c2) + e2) : "year" === a3 && k2.set("FullYear", c2, k2.get("FullYear", c2) + e2), e2 = c2.getTime() - f2);
            if (d2 && P(b2))
              return f2 + e2;
            this.xIncrement = f2 + e2;
            return f2;
          }
          setDataSortingOptions() {
            const c2 = this.options;
            b(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false });
            r(c2.pointRange) || (c2.pointRange = 1);
          }
          setOptions(b2) {
            var c2, a3;
            const d2 = this.chart;
            var f2 = d2.options.plotOptions, e2 = d2.userOptions || {};
            const l2 = U(b2);
            b2 = d2.styledMode;
            const g2 = { plotOptions: f2, userOptions: l2 };
            k(
              this,
              "setOptions",
              g2
            );
            const h2 = g2.plotOptions[this.type];
            e2 = e2.plotOptions || {};
            const m2 = e2.series || {}, w2 = n.plotOptions[this.type] || {}, v2 = e2[this.type] || {};
            this.userOptions = g2.userOptions;
            f2 = U(h2, f2.series, v2, l2);
            this.tooltipOptions = U(n.tooltip, null === (c2 = n.plotOptions.series) || void 0 === c2 ? void 0 : c2.tooltip, null === w2 || void 0 === w2 ? void 0 : w2.tooltip, d2.userOptions.tooltip, null === (a3 = e2.series) || void 0 === a3 ? void 0 : a3.tooltip, v2.tooltip, l2.tooltip);
            this.stickyTracking = H(l2.stickyTracking, v2.stickyTracking, m2.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : f2.stickyTracking);
            null === h2.marker && delete f2.marker;
            this.zoneAxis = f2.zoneAxis;
            a3 = this.zones = (f2.zones || []).slice();
            !f2.negativeColor && !f2.negativeFillColor || f2.zones || (c2 = { value: f2[this.zoneAxis + "Threshold"] || f2.threshold || 0, className: "highcharts-negative" }, b2 || (c2.color = f2.negativeColor, c2.fillColor = f2.negativeFillColor), a3.push(c2));
            a3.length && r(a3[a3.length - 1].value) && a3.push(b2 ? {} : { color: this.color, fillColor: this.fillColor });
            k(this, "afterSetOptions", { options: f2 });
            return f2;
          }
          getName() {
            return H(
              this.options.name,
              "Series " + (this.index + 1)
            );
          }
          getCyclic(b2, c2, a3) {
            const d2 = this.chart, k2 = `${b2}Index`, f2 = `${b2}Counter`, e2 = (null === a3 || void 0 === a3 ? void 0 : a3.length) || d2.options.chart.colorCount;
            if (!c2) {
              var l2 = H("color" === b2 ? this.options.colorIndex : void 0, this[k2]);
              r(l2) || (d2.series.length || (d2[f2] = 0), l2 = d2[f2] % e2, d2[f2] += 1);
              a3 && (c2 = a3[l2]);
            }
            "undefined" !== typeof l2 && (this[k2] = l2);
            this[b2] = c2;
          }
          getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic(
              "color",
              this.options.color || n.plotOptions[this.type].color,
              this.chart.options.colors
            );
          }
          getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          }
          getSymbol() {
            this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
          }
          findPointIndex(b2, a3) {
            const d2 = b2.id, k2 = b2.x, f2 = this.points;
            var e2 = this.options.dataSorting, l2;
            let g2, h2;
            if (d2)
              e2 = this.chart.get(d2), e2 instanceof D && (l2 = e2);
            else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
              if (l2 = (c2) => !c2.touched && c2.index === b2.index, e2 && e2.matchByName ? l2 = (c2) => !c2.touched && c2.name === b2.name : this.options.relativeXValue && (l2 = (c2) => !c2.touched && c2.options.x === b2.x), l2 = c(f2, l2), !l2)
                return;
            }
            l2 && (h2 = l2 && l2.index, "undefined" !== typeof h2 && (g2 = true));
            "undefined" === typeof h2 && P(k2) && (h2 = this.xData.indexOf(k2, a3));
            -1 !== h2 && "undefined" !== typeof h2 && this.cropped && (h2 = h2 >= this.cropStart ? h2 - this.cropStart : h2);
            !g2 && P(h2) && f2[h2] && f2[h2].touched && (h2 = void 0);
            return h2;
          }
          updateData(b2, c2) {
            const a3 = this.options, d2 = a3.dataSorting, k2 = this.points, f2 = [], e2 = this.requireSorting, l2 = b2.length === k2.length;
            let g2, h2, n2, m2 = true;
            this.xIncrement = null;
            b2.forEach(function(b3, c3) {
              var h3 = r(b3) && this.pointClass.prototype.optionsToObject.call({ series: this }, b3) || {};
              const m3 = h3.x;
              if (h3.id || P(m3)) {
                if (h3 = this.findPointIndex(h3, n2), -1 === h3 || "undefined" === typeof h3 ? f2.push(b3) : k2[h3] && b3 !== a3.data[h3] ? (k2[h3].update(b3, false, null, false), k2[h3].touched = true, e2 && (n2 = h3 + 1)) : k2[h3] && (k2[h3].touched = true), !l2 || c3 !== h3 || d2 && d2.enabled || this.hasDerivedData)
                  g2 = true;
              } else
                f2.push(b3);
            }, this);
            if (g2)
              for (b2 = k2.length; b2--; )
                (h2 = k2[b2]) && !h2.touched && h2.remove && h2.remove(false, c2);
            else
              !l2 || d2 && d2.enabled ? m2 = false : (b2.forEach(function(b3, c3) {
                b3 === k2[c3].y || k2[c3].destroyed || k2[c3].update(b3, false, null, false);
              }), f2.length = 0);
            k2.forEach(function(b3) {
              b3 && (b3.touched = false);
            });
            if (!m2)
              return false;
            f2.forEach(function(b3) {
              this.addPoint(b3, false, null, null, false);
            }, this);
            null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = M(this.xData), this.autoIncrement());
            return true;
          }
          setData(b2, c2 = true, a3, k2) {
            var f2;
            const e2 = this, l2 = e2.points, g2 = l2 && l2.length || 0, h2 = e2.options, n2 = e2.chart, r2 = h2.dataSorting, m2 = e2.xAxis, w2 = h2.turboThreshold, v2 = this.xData, z2 = this.yData;
            var p2 = e2.pointArrayMap;
            p2 = p2 && p2.length;
            const q2 = h2.keys;
            let F2, y2 = 0, x2 = 1, N = null;
            if (!n2.options.chart.allowMutatingData) {
              h2.data && delete e2.options.data;
              e2.userOptions.data && delete e2.userOptions.data;
              var t2 = U(true, b2);
            }
            b2 = t2 || b2 || [];
            t2 = b2.length;
            r2 && r2.enabled && (b2 = this.sortData(b2));
            n2.options.chart.allowMutatingData && false !== k2 && t2 && g2 && !e2.cropped && !e2.hasGroupedData && e2.visible && !e2.boosted && (F2 = this.updateData(b2, a3));
            if (!F2) {
              e2.xIncrement = null;
              e2.colorCounter = 0;
              this.parallelArrays.forEach(function(b3) {
                e2[b3 + "Data"].length = 0;
              });
              if (w2 && t2 > w2)
                if (N = e2.getFirstValidPoint(b2), P(N))
                  for (a3 = 0; a3 < t2; a3++)
                    v2[a3] = this.autoIncrement(), z2[a3] = b2[a3];
                else if (O(N))
                  if (p2)
                    if (N.length === p2)
                      for (a3 = 0; a3 < t2; a3++)
                        v2[a3] = this.autoIncrement(), z2[a3] = b2[a3];
                    else
                      for (a3 = 0; a3 < t2; a3++)
                        k2 = b2[a3], v2[a3] = k2[0], z2[a3] = k2.slice(1, p2 + 1);
                  else if (q2 && (y2 = q2.indexOf("x"), x2 = q2.indexOf("y"), y2 = 0 <= y2 ? y2 : 0, x2 = 0 <= x2 ? x2 : 1), 1 === N.length && (x2 = 0), y2 === x2)
                    for (a3 = 0; a3 < t2; a3++)
                      v2[a3] = this.autoIncrement(), z2[a3] = b2[a3][x2];
                  else
                    for (a3 = 0; a3 < t2; a3++)
                      k2 = b2[a3], v2[a3] = k2[y2], z2[a3] = k2[x2];
                else
                  d(12, false, n2);
              else
                for (a3 = 0; a3 < t2; a3++)
                  k2 = { series: e2 }, e2.pointClass.prototype.applyOptions.apply(k2, [b2[a3]]), e2.updateParallelArrays(k2, a3);
              z2 && T(z2[0]) && d(
                14,
                true,
                n2
              );
              e2.data = [];
              e2.options.data = e2.userOptions.data = b2;
              for (a3 = g2; a3--; )
                null === (f2 = l2[a3]) || void 0 === f2 ? void 0 : f2.destroy();
              m2 && (m2.minRange = m2.userMinRange);
              e2.isDirty = n2.isDirtyBox = true;
              e2.isDirtyData = !!l2;
              a3 = false;
            }
            "point" === h2.legendType && (this.processData(), this.generatePoints());
            c2 && n2.redraw(a3);
          }
          sortData(b2) {
            const c2 = this, a3 = c2.options.dataSorting.sortKey || "y", d2 = function(b3, c3) {
              return r(c3) && b3.pointClass.prototype.optionsToObject.call({ series: b3 }, c3) || {};
            };
            b2.forEach(function(a4, k2) {
              b2[k2] = d2(c2, a4);
              b2[k2].index = k2;
            }, this);
            b2.concat().sort((b3, c3) => {
              b3 = z(a3, b3);
              c3 = z(a3, c3);
              return c3 < b3 ? -1 : c3 > b3 ? 1 : 0;
            }).forEach(function(b3, c3) {
              b3.x = c3;
            }, this);
            c2.linkedSeries && c2.linkedSeries.forEach(function(c3) {
              const a4 = c3.options, k2 = a4.data;
              a4.dataSorting && a4.dataSorting.enabled || !k2 || (k2.forEach(function(a5, f2) {
                k2[f2] = d2(c3, a5);
                b2[f2] && (k2[f2].x = b2[f2].x, k2[f2].index = f2);
              }), c3.setData(k2, false));
            });
            return b2;
          }
          getProcessedData(b2) {
            const c2 = this;
            var a3 = c2.xAxis, k2 = c2.options;
            const f2 = k2.cropThreshold, e2 = b2 || c2.getExtremesFromAll || k2.getExtremesFromAll, l2 = null === a3 || void 0 === a3 ? void 0 : a3.logarithmic, g2 = c2.isCartesian;
            let h2 = 0;
            let n2;
            b2 = c2.xData;
            k2 = c2.yData;
            let r2 = false;
            const m2 = b2.length;
            if (a3) {
              var v2 = a3.getExtremes();
              n2 = v2.min;
              v2 = v2.max;
              r2 = !(!a3.categories || a3.names.length);
            }
            if (g2 && c2.sorted && !e2 && (!f2 || m2 > f2 || c2.forceCrop)) {
              if (b2[m2 - 1] < n2 || b2[0] > v2)
                b2 = [], k2 = [];
              else if (c2.yData && (b2[0] < n2 || b2[m2 - 1] > v2)) {
                var z2 = this.cropData(c2.xData, c2.yData, n2, v2);
                b2 = z2.xData;
                k2 = z2.yData;
                h2 = z2.start;
                z2 = true;
              }
            }
            a3 = w([l2 ? b2.map(l2.log2lin) : b2], () => c2.requireSorting && !r2 && d(15, false, c2.chart));
            return { xData: b2, yData: k2, cropped: z2, cropStart: h2, closestPointRange: a3 };
          }
          processData(b2) {
            const c2 = this.xAxis;
            if (this.isCartesian && !this.isDirty && !c2.isDirty && !this.yAxis.isDirty && !b2)
              return false;
            b2 = this.getProcessedData();
            this.cropped = b2.cropped;
            this.cropStart = b2.cropStart;
            this.processedXData = b2.xData;
            this.processedYData = b2.yData;
            this.closestPointRange = this.basePointRange = b2.closestPointRange;
            k(this, "afterProcessData");
          }
          cropData(b2, c2, a3, d2, k2) {
            const f2 = b2.length;
            let e2, l2 = 0, g2 = f2;
            k2 = H(k2, this.cropShoulder);
            for (e2 = 0; e2 < f2; e2++)
              if (b2[e2] >= a3) {
                l2 = Math.max(0, e2 - k2);
                break;
              }
            for (a3 = e2; a3 < f2; a3++)
              if (b2[a3] > d2) {
                g2 = a3 + k2;
                break;
              }
            return {
              xData: b2.slice(l2, g2),
              yData: c2.slice(l2, g2),
              start: l2,
              end: g2
            };
          }
          generatePoints() {
            var c2 = this.options;
            const a3 = this.processedData || c2.data, d2 = this.processedXData, f2 = this.processedYData, e2 = this.pointClass, l2 = d2.length, g2 = this.cropStart || 0, h2 = this.hasGroupedData, n2 = c2.keys, r2 = [];
            c2 = c2.dataGrouping && c2.dataGrouping.groupAll ? g2 : 0;
            let m2;
            let w2, v2, z2 = this.data;
            if (!z2 && !h2) {
              var p2 = [];
              p2.length = a3.length;
              z2 = this.data = p2;
            }
            n2 && h2 && (this.options.keys = false);
            for (v2 = 0; v2 < l2; v2++)
              p2 = g2 + v2, h2 ? (w2 = new e2().init(this, [d2[v2]].concat(ea(f2[v2]))), w2.dataGroup = this.groupMap[c2 + v2], w2.dataGroup.options && (w2.options = w2.dataGroup.options, b(w2, w2.dataGroup.options), delete w2.dataLabels)) : (w2 = z2[p2]) || "undefined" === typeof a3[p2] || (z2[p2] = w2 = new e2().init(this, a3[p2], d2[v2])), w2 && (w2.index = h2 ? c2 + v2 : p2, r2[v2] = w2);
            this.options.keys = n2;
            if (z2 && (l2 !== (m2 = z2.length) || h2))
              for (v2 = 0; v2 < m2; v2++)
                v2 !== g2 || h2 || (v2 += l2), z2[v2] && (z2[v2].destroyElements(), z2[v2].plotX = void 0);
            this.data = z2;
            this.points = r2;
            k(this, "afterGeneratePoints");
          }
          getXExtremes(b2) {
            return { min: C(b2), max: M(b2) };
          }
          getExtremes(b2, c2) {
            const a3 = this.xAxis;
            var d2 = this.yAxis;
            const f2 = this.processedXData || this.xData, e2 = [], l2 = this.requireSorting ? this.cropShoulder : 0;
            d2 = d2 ? d2.positiveValuesOnly : false;
            let g2, h2 = 0, n2 = 0, r2 = 0;
            b2 = b2 || this.stackedYData || this.processedYData || [];
            const w2 = b2.length;
            if (a3) {
              var m2 = a3.getExtremes();
              h2 = m2.min;
              n2 = m2.max;
            }
            for (g2 = 0; g2 < w2; g2++) {
              var v2 = f2[g2];
              m2 = b2[g2];
              var z2 = (P(m2) || O(m2)) && (m2.length || 0 < m2 || !d2);
              v2 = c2 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a3 || (f2[g2 + l2] || v2) >= h2 && (f2[g2 - l2] || v2) <= n2;
              if (z2 && v2)
                if (z2 = m2.length)
                  for (; z2--; )
                    P(m2[z2]) && (e2[r2++] = m2[z2]);
                else
                  e2[r2++] = m2;
            }
            b2 = { activeYData: e2, dataMin: C(e2), dataMax: M(e2) };
            k(this, "afterGetExtremes", { dataExtremes: b2 });
            return b2;
          }
          applyExtremes() {
            const b2 = this.getExtremes();
            this.dataMin = b2.dataMin;
            this.dataMax = b2.dataMax;
            return b2;
          }
          getFirstValidPoint(b2) {
            const c2 = b2.length;
            let a3 = 0, d2 = null;
            for (; null === d2 && a3 < c2; )
              d2 = b2[a3], a3++;
            return d2;
          }
          translate() {
            var b2;
            this.processedXData || this.processData();
            this.generatePoints();
            var c2 = this.options;
            const a3 = c2.stacking, d2 = this.xAxis, e2 = d2.categories, l2 = this.enabledDataSorting, g2 = this.yAxis, h2 = this.points, n2 = h2.length, m2 = this.pointPlacementToXValue(), w2 = !!m2, v2 = c2.threshold;
            c2 = c2.startFromThreshold ? v2 : 0;
            let z2, p2, q2, F2, x2 = Number.MAX_VALUE;
            for (z2 = 0; z2 < n2; z2++) {
              const k2 = h2[z2], n3 = k2.x;
              let t2, u2, I = k2.y, N = k2.low;
              const C2 = a3 && (null === (b2 = g2.stacking) || void 0 === b2 ? void 0 : b2.stacks[(this.negStacks && I < (c2 ? 0 : v2) ? "-" : "") + this.stackKey]);
              p2 = d2.translate(n3, false, false, false, true, m2);
              k2.plotX = P(p2) ? y(f(p2, -1e5, 1e5)) : void 0;
              a3 && this.visible && C2 && C2[n3] && (F2 = this.getStackIndicator(F2, n3, this.index), !k2.isNull && F2.key && (t2 = C2[n3], u2 = t2.points[F2.key]), t2 && O(u2) && (N = u2[0], I = u2[1], N === c2 && F2.key === C2[n3].base && (N = H(P(v2) ? v2 : g2.min)), g2.positiveValuesOnly && r(N) && 0 >= N && (N = void 0), k2.total = k2.stackTotal = H(t2.total), k2.percentage = r(k2.y) && t2.total ? k2.y / t2.total * 100 : void 0, k2.stackY = I, this.irregularWidths || t2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));
              k2.yBottom = r(N) ? f(g2.translate(N, false, true, false, true), -1e5, 1e5) : void 0;
              this.dataModify && (I = this.dataModify.modifyValue(I, z2));
              let ca;
              P(I) && void 0 !== k2.plotX && (ca = g2.translate(I, false, true, false, true), ca = P(ca) ? f(ca, -1e5, 1e5) : void 0);
              k2.plotY = ca;
              k2.isInside = this.isPointInside(k2);
              k2.clientX = w2 ? y(d2.translate(n3, false, false, false, true, m2)) : p2;
              k2.negative = (k2.y || 0) < (v2 || 0);
              k2.category = H(e2 && e2[k2.x], k2.x);
              k2.isNull || false === k2.visible || ("undefined" !== typeof q2 && (x2 = Math.min(x2, Math.abs(p2 - q2))), q2 = p2);
              k2.zone = this.zones.length ? k2.getZone() : void 0;
              !k2.graphic && this.group && l2 && (k2.isNew = true);
            }
            this.closestPointRangePx = x2;
            k(this, "afterTranslate");
          }
          getValidPoints(b2, c2, a3) {
            const d2 = this.chart;
            return (b2 || this.points || []).filter(function(b3) {
              const { plotX: k2, plotY: f2 } = b3;
              return !a3 && (b3.isNull || !P(f2)) || c2 && !d2.isInsidePlot(k2, f2, { inverted: d2.inverted }) ? false : false !== b3.visible;
            });
          }
          getClipBox() {
            const { chart: b2, xAxis: c2, yAxis: a3 } = this, d2 = U(b2.clipBox);
            c2 && c2.len !== b2.plotSizeX && (d2.width = c2.len);
            a3 && a3.len !== b2.plotSizeY && (d2.height = a3.len);
            return d2;
          }
          getSharedClipKey() {
            return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
          }
          setClip() {
            const { chart: b2, group: c2, markerGroup: a3 } = this, d2 = b2.sharedClips, k2 = b2.renderer, f2 = this.getClipBox(), e2 = this.getSharedClipKey();
            let l2 = d2[e2];
            l2 ? l2.animate(f2) : d2[e2] = l2 = k2.clipRect(f2);
            c2 && c2.clip(false === this.options.clip ? void 0 : l2);
            a3 && a3.clip();
          }
          animate(b2) {
            const { chart: c2, group: a3, markerGroup: d2 } = this, k2 = c2.inverted;
            var f2 = m(this.options.animation), e2 = [this.getSharedClipKey(), f2.duration, f2.easing, f2.defer].join();
            let l2 = c2.sharedClips[e2], g2 = c2.sharedClips[e2 + "m"];
            if (b2 && a3)
              f2 = this.getClipBox(), l2 ? l2.attr("height", f2.height) : (f2.width = 0, k2 && (f2.x = c2.plotHeight), l2 = c2.renderer.clipRect(f2), c2.sharedClips[e2] = l2, g2 = c2.renderer.clipRect({ x: -99, y: -99, width: k2 ? c2.plotWidth + 199 : 99, height: k2 ? 99 : c2.plotHeight + 199 }), c2.sharedClips[e2 + "m"] = g2), a3.clip(l2), d2 && d2.clip(g2);
            else if (l2 && !l2.hasClass("highcharts-animating")) {
              e2 = this.getClipBox();
              const b3 = f2.step;
              d2 && d2.element.childNodes.length && (f2.step = function(c3, a4) {
                b3 && b3.apply(a4, arguments);
                "width" === a4.prop && g2 && g2.element && g2.attr(k2 ? "height" : "width", c3 + 99);
              });
              l2.addClass("highcharts-animating").animate(e2, f2);
            }
          }
          afterAnimate() {
            this.setClip();
            W(this.chart.sharedClips, (b2, c2, a3) => {
              b2 && !this.chart.container.querySelector(`[clip-path="url(#${b2.id})"]`) && (b2.destroy(), delete a3[c2]);
            });
            this.finishedAnimating = true;
            k(this, "afterAnimate");
          }
          drawPoints(b2 = this.points) {
            const c2 = this.chart, a3 = c2.styledMode, { colorAxis: d2, options: k2 } = this, f2 = k2.marker, e2 = this[this.specialGroup || "markerGroup"], l2 = this.xAxis, g2 = H(f2.enabled, !l2 || l2.isRadial ? true : null, this.closestPointRangePx >= f2.enabledThreshold * f2.radius);
            let h2, n2, m2, r2;
            let w2, v2;
            if (false !== f2.enabled || this._hasPointMarkers)
              for (h2 = 0; h2 < b2.length; h2++) {
                n2 = b2[h2];
                r2 = (m2 = n2.graphic) ? "animate" : "attr";
                var z2 = n2.marker || {};
                w2 = !!n2.marker;
                if ((g2 && "undefined" === typeof z2.enabled || z2.enabled) && !n2.isNull && false !== n2.visible) {
                  const b3 = H(z2.symbol, this.symbol, "rect");
                  v2 = this.markerAttribs(n2, n2.selected && "select");
                  this.enabledDataSorting && (n2.startXPos = l2.reversed ? -(v2.width || 0) : l2.width);
                  const k3 = false !== n2.isInside;
                  !m2 && k3 && (0 < (v2.width || 0) || n2.hasImage) && (n2.graphic = m2 = c2.renderer.symbol(b3, v2.x, v2.y, v2.width, v2.height, w2 ? z2 : f2).add(e2), this.enabledDataSorting && c2.hasRendered && (m2.attr({ x: n2.startXPos }), r2 = "animate"));
                  m2 && "animate" === r2 && m2[k3 ? "show" : "hide"](k3).animate(v2);
                  if (m2)
                    if (z2 = this.pointAttribs(n2, a3 || !n2.selected ? void 0 : "select"), a3)
                      d2 && m2.css({ fill: z2.fill });
                    else
                      m2[r2](z2);
                  m2 && m2.addClass(n2.getClassName(), true);
                } else
                  m2 && (n2.graphic = m2.destroy());
              }
          }
          markerAttribs(b2, c2) {
            const a3 = this.options;
            var d2 = a3.marker;
            const k2 = b2.marker || {}, f2 = k2.symbol || d2.symbol, e2 = {};
            let l2 = H(k2.radius, d2 && d2.radius);
            c2 && (d2 = d2.states[c2], c2 = k2.states && k2.states[c2], l2 = H(c2 && c2.radius, d2 && d2.radius, l2 && l2 + (d2 && d2.radiusPlus || 0)));
            b2.hasImage = f2 && 0 === f2.indexOf("url");
            b2.hasImage && (l2 = 0);
            b2 = b2.pos();
            P(l2) && b2 && (e2.x = b2[0] - l2, e2.y = b2[1] - l2, a3.crisp && (e2.x = Math.floor(e2.x)));
            l2 && (e2.width = e2.height = 2 * l2);
            return e2;
          }
          pointAttribs(b2, c2) {
            var a3 = this.options.marker, d2 = b2 && b2.options;
            const k2 = d2 && d2.marker || {};
            var f2 = d2 && d2.color, e2 = b2 && b2.color;
            const l2 = b2 && b2.zone && b2.zone.color;
            let g2 = this.color;
            b2 = H(k2.lineWidth, a3.lineWidth);
            d2 = 1;
            g2 = f2 || l2 || e2 || g2;
            f2 = k2.fillColor || a3.fillColor || g2;
            e2 = k2.lineColor || a3.lineColor || g2;
            c2 = c2 || "normal";
            a3 = a3.states[c2] || {};
            c2 = k2.states && k2.states[c2] || {};
            b2 = H(c2.lineWidth, a3.lineWidth, b2 + H(c2.lineWidthPlus, a3.lineWidthPlus, 0));
            f2 = c2.fillColor || a3.fillColor || f2;
            e2 = c2.lineColor || a3.lineColor || e2;
            d2 = H(c2.opacity, a3.opacity, d2);
            return { stroke: e2, "stroke-width": b2, fill: f2, opacity: d2 };
          }
          destroy(b2) {
            const c2 = this, a3 = c2.chart, d2 = /AppleWebKit\/533/.test(x.navigator.userAgent), f2 = c2.data || [];
            let e2, l2, g2, h2;
            k(c2, "destroy", { keepEventsForUpdate: b2 });
            this.removeEvents(b2);
            (c2.axisTypes || []).forEach(function(b3) {
              (h2 = c2[b3]) && h2.series && (v(h2.series, c2), h2.isDirty = h2.forceRedraw = true);
            });
            c2.legendItem && c2.chart.legend.destroyItem(c2);
            for (l2 = f2.length; l2--; )
              (g2 = f2[l2]) && g2.destroy && g2.destroy();
            c2.clips && c2.clips.forEach((b3) => b3.destroy());
            q.clearTimeout(c2.animationTimeout);
            W(c2, function(b3, c3) {
              b3 instanceof t && !b3.survive && (e2 = d2 && "group" === c3 ? "hide" : "destroy", b3[e2]());
            });
            a3.hoverSeries === c2 && (a3.hoverSeries = void 0);
            v(a3.series, c2);
            a3.orderItems("series");
            W(c2, function(a4, d3) {
              b2 && "hcEvents" === d3 || delete c2[d3];
            });
          }
          applyZones() {
            const b2 = this, c2 = this.chart, a3 = c2.renderer, d2 = this.zones, k2 = this.clips || [], e2 = this.graph, l2 = this.area, g2 = Math.max(c2.plotWidth, c2.plotHeight), h2 = this[(this.zoneAxis || "y") + "Axis"], n2 = c2.inverted;
            let m2, r2, w2, v2, z2, p2, q2, F2, y2, x2, t2, u2 = false;
            d2.length && (e2 || l2) && h2 && "undefined" !== typeof h2.min ? (z2 = h2.reversed, p2 = h2.horiz, e2 && !this.showLine && e2.hide(), l2 && l2.hide(), v2 = h2.getExtremes(), d2.forEach(function(d3, I) {
              m2 = z2 ? p2 ? c2.plotWidth : 0 : p2 ? 0 : h2.toPixels(v2.min) || 0;
              m2 = f(H(r2, m2), 0, g2);
              r2 = f(Math.round(h2.toPixels(H(d3.value, v2.max), true) || 0), 0, g2);
              u2 && (m2 = r2 = h2.toPixels(v2.max));
              q2 = Math.abs(m2 - r2);
              F2 = Math.min(m2, r2);
              y2 = Math.max(m2, r2);
              h2.isXAxis ? (w2 = { x: n2 ? y2 : F2, y: 0, width: q2, height: g2 }, p2 || (w2.x = c2.plotHeight - w2.x)) : (w2 = { x: 0, y: n2 ? y2 : F2, width: g2, height: q2 }, p2 && (w2.y = c2.plotWidth - w2.y));
              k2[I] ? k2[I].animate(w2) : k2[I] = a3.clipRect(w2);
              x2 = b2["zone-area-" + I];
              t2 = b2["zone-graph-" + I];
              e2 && t2 && t2.clip(k2[I]);
              l2 && x2 && x2.clip(k2[I]);
              u2 = d3.value > v2.max;
              b2.resetZones && 0 === r2 && (r2 = void 0);
            }), this.clips = k2) : b2.visible && (e2 && e2.show(), l2 && l2.show());
          }
          plotGroup(b2, c2, a3, d2, k2) {
            let f2 = this[b2];
            const e2 = !f2;
            a3 = { visibility: a3, zIndex: d2 || 0.1 };
            "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (a3.opacity = this.opacity);
            e2 && (this[b2] = f2 = this.chart.renderer.g().add(k2));
            f2.addClass("highcharts-" + c2 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (r(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f2.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
            f2.attr(a3)[e2 ? "attr" : "animate"](this.getPlotBox(c2));
            return f2;
          }
          getPlotBox(b2) {
            let c2 = this.xAxis, a3 = this.yAxis;
            const d2 = this.chart;
            b2 = d2.inverted && !d2.polar && c2 && false !== this.invertible && "series" === b2;
            d2.inverted && (c2 = a3, a3 = this.xAxis);
            return { translateX: c2 ? c2.left : d2.plotLeft, translateY: a3 ? a3.top : d2.plotTop, rotation: b2 ? 90 : 0, rotationOriginX: b2 ? (c2.len - a3.len) / 2 : 0, rotationOriginY: b2 ? (c2.len + a3.len) / 2 : 0, scaleX: b2 ? -1 : 1, scaleY: 1 };
          }
          removeEvents(b2) {
            b2 || Y(this);
            this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(b3) {
              b3();
            }), this.eventsToUnbind.length = 0);
          }
          render() {
            const b2 = this;
            var c2 = b2.chart;
            const a3 = b2.options, d2 = m(a3.animation), f2 = b2.visible ? "inherit" : "hidden", e2 = a3.zIndex, l2 = b2.hasRendered;
            c2 = c2.seriesGroup;
            let g2 = b2.finishedAnimating ? 0 : d2.duration;
            k(this, "render");
            b2.plotGroup("group", "series", f2, e2, c2);
            b2.markerGroup = b2.plotGroup("markerGroup", "markers", f2, e2, c2);
            false !== a3.clip && b2.setClip();
            b2.animate && g2 && b2.animate(true);
            b2.drawGraph && (b2.drawGraph(), b2.applyZones());
            b2.visible && b2.drawPoints();
            b2.drawDataLabels && b2.drawDataLabels();
            b2.redrawPoints && b2.redrawPoints();
            b2.drawTracker && a3.enableMouseTracking && b2.drawTracker();
            b2.animate && g2 && b2.animate();
            l2 || (g2 && d2.defer && (g2 += d2.defer), b2.animationTimeout = aa(function() {
              b2.afterAnimate();
            }, g2 || 0));
            b2.isDirty = false;
            b2.hasRendered = true;
            k(b2, "afterRender");
          }
          redraw() {
            const b2 = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            b2 && delete this.kdTree;
          }
          searchPoint(b2, c2) {
            const a3 = this.xAxis, d2 = this.yAxis, k2 = this.chart.inverted;
            return this.searchKDTree({ clientX: k2 ? a3.len - b2.chartY + a3.pos : b2.chartX - a3.pos, plotY: k2 ? d2.len - b2.chartX + d2.pos : b2.chartY - d2.pos }, c2, b2);
          }
          buildKDTree(b2) {
            function c2(b3, d3, k2) {
              var f2 = b3 && b3.length;
              let e2;
              if (f2)
                return e2 = a3.kdAxisArray[d3 % k2], b3.sort(function(b4, c3) {
                  return b4[e2] - c3[e2];
                }), f2 = Math.floor(f2 / 2), { point: b3[f2], left: c2(b3.slice(0, f2), d3 + 1, k2), right: c2(b3.slice(f2 + 1), d3 + 1, k2) };
            }
            this.buildingKdTree = true;
            const a3 = this, d2 = -1 < a3.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete a3.kdTree;
            aa(function() {
              a3.kdTree = c2(a3.getValidPoints(null, !a3.directTouch), d2, d2);
              a3.buildingKdTree = false;
            }, a3.options.kdNow || b2 && "touchstart" === b2.type ? 0 : 1);
          }
          searchKDTree(b2, c2, a3) {
            function d2(b3, c3, a4, g2) {
              const h2 = c3.point;
              var n2 = k2.kdAxisArray[a4 % g2];
              let m2 = h2;
              var w2 = r(b3[f2]) && r(h2[f2]) ? Math.pow(b3[f2] - h2[f2], 2) : null;
              var v2 = r(b3[e2]) && r(h2[e2]) ? Math.pow(b3[e2] - h2[e2], 2) : null;
              v2 = (w2 || 0) + (v2 || 0);
              h2.dist = r(v2) ? Math.sqrt(v2) : Number.MAX_VALUE;
              h2.distX = r(w2) ? Math.sqrt(w2) : Number.MAX_VALUE;
              n2 = b3[n2] - h2[n2];
              v2 = 0 > n2 ? "left" : "right";
              w2 = 0 > n2 ? "right" : "left";
              c3[v2] && (v2 = d2(b3, c3[v2], a4 + 1, g2), m2 = v2[l2] < m2[l2] ? v2 : h2);
              c3[w2] && Math.sqrt(n2 * n2) < m2[l2] && (b3 = d2(b3, c3[w2], a4 + 1, g2), m2 = b3[l2] < m2[l2] ? b3 : m2);
              return m2;
            }
            const k2 = this, f2 = this.kdAxisArray[0], e2 = this.kdAxisArray[1], l2 = c2 ? "distX" : "dist";
            c2 = -1 < k2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree(a3);
            if (this.kdTree)
              return d2(
                b2,
                this.kdTree,
                c2,
                c2
              );
          }
          pointPlacementToXValue() {
            const { options: { pointPlacement: b2, pointRange: c2 }, xAxis: a3 } = this;
            let d2 = b2;
            "between" === d2 && (d2 = a3.reversed ? -0.5 : 0.5);
            return P(d2) ? d2 * (c2 || a3.pointRange) : 0;
          }
          isPointInside(b2) {
            const { chart: c2, xAxis: a3, yAxis: d2 } = this;
            return "undefined" !== typeof b2.plotY && "undefined" !== typeof b2.plotX && 0 <= b2.plotY && b2.plotY <= (d2 ? d2.len : c2.plotHeight) && 0 <= b2.plotX && b2.plotX <= (a3 ? a3.len : c2.plotWidth);
          }
          drawTracker() {
            const b2 = this, c2 = b2.options, a3 = c2.trackByArea, d2 = [].concat(a3 ? b2.areaPath : b2.graphPath), f2 = b2.chart, l2 = f2.pointer, h2 = f2.renderer, n2 = f2.options.tooltip.snap, m2 = b2.tracker, r2 = function(a4) {
              if (c2.enableMouseTracking && f2.hoverSeries !== b2)
                b2.onMouseOver();
            }, w2 = "rgba(192,192,192," + (e ? 1e-4 : 2e-3) + ")";
            m2 ? m2.attr({ d: d2 }) : b2.graph && (b2.tracker = h2.path(d2).attr({ visibility: b2.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(a3 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b2.group), f2.styledMode || b2.tracker.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: w2, fill: a3 ? w2 : "none", "stroke-width": b2.graph.strokeWidth() + (a3 ? 0 : 2 * n2) }), [
              b2.tracker,
              b2.markerGroup,
              b2.dataLabelsGroup
            ].forEach(function(b3) {
              if (b3 && (b3.addClass("highcharts-tracker").on("mouseover", r2).on("mouseout", function(b4) {
                l2.onTrackerMouseOut(b4);
              }), c2.cursor && !f2.styledMode && b3.css({ cursor: c2.cursor }), g))
                b3.on("touchstart", r2);
            }));
            k(this, "afterDrawTracker");
          }
          addPoint(b2, c2, a3, d2, f2) {
            const e2 = this.options, l2 = this.data, g2 = this.chart;
            var h2 = this.xAxis;
            h2 = h2 && h2.hasNames && h2.names;
            const n2 = e2.data, m2 = this.xData;
            let r2, w2;
            c2 = H(c2, true);
            const v2 = { series: this };
            this.pointClass.prototype.applyOptions.apply(v2, [b2]);
            const z2 = v2.x;
            w2 = m2.length;
            if (this.requireSorting && z2 < m2[w2 - 1])
              for (r2 = true; w2 && m2[w2 - 1] > z2; )
                w2--;
            this.updateParallelArrays(v2, "splice", [w2, 0, 0]);
            this.updateParallelArrays(v2, w2);
            h2 && v2.name && (h2[z2] = v2.name);
            n2.splice(w2, 0, b2);
            if (r2 || this.processedData)
              this.data.splice(w2, 0, null), this.processData();
            "point" === e2.legendType && this.generatePoints();
            a3 && (l2[0] && l2[0].remove ? l2[0].remove(false) : (l2.shift(), this.updateParallelArrays(v2, "shift"), n2.shift()));
            false !== f2 && k(this, "addPoint", { point: v2 });
            this.isDirtyData = this.isDirty = true;
            c2 && g2.redraw(d2);
          }
          removePoint(b2, c2, a3) {
            const d2 = this, k2 = d2.data, f2 = k2[b2], e2 = d2.points, l2 = d2.chart, g2 = function() {
              e2 && e2.length === k2.length && e2.splice(b2, 1);
              k2.splice(b2, 1);
              d2.options.data.splice(b2, 1);
              d2.updateParallelArrays(f2 || { series: d2 }, "splice", [b2, 1]);
              f2 && f2.destroy();
              d2.isDirty = true;
              d2.isDirtyData = true;
              c2 && l2.redraw();
            };
            p(a3, l2);
            c2 = H(c2, true);
            f2 ? f2.firePointEvent("remove", null, g2) : g2();
          }
          remove(b2, c2, a3, d2) {
            function f2() {
              e2.destroy(d2);
              l2.isDirtyLegend = l2.isDirtyBox = true;
              l2.linkSeries(d2);
              H(b2, true) && l2.redraw(c2);
            }
            const e2 = this, l2 = e2.chart;
            false !== a3 ? k(e2, "remove", null, f2) : f2();
          }
          update(c2, a3) {
            c2 = l(c2, this.userOptions);
            k(this, "update", { options: c2 });
            const f2 = this, e2 = f2.chart;
            var g2 = f2.userOptions;
            const h2 = f2.initialType || f2.type;
            var n2 = e2.options.plotOptions;
            const m2 = u[h2].prototype;
            var w2 = f2.finishedAnimating && { animation: false };
            const r2 = {};
            let v2, z2 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], p2 = c2.type || g2.type || e2.options.chart.type;
            const q2 = !(this.hasDerivedData || p2 && p2 !== this.type || "undefined" !== typeof c2.pointStart || "undefined" !== typeof c2.pointInterval || "undefined" !== typeof c2.relativeXValue || c2.joinBy || c2.mapData || f2.hasOptionChanged("dataGrouping") || f2.hasOptionChanged("pointStart") || f2.hasOptionChanged("pointInterval") || f2.hasOptionChanged("pointIntervalUnit") || f2.hasOptionChanged("keys"));
            p2 = p2 || h2;
            q2 && (z2.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), false !== c2.visible && z2.push("area", "graph"), f2.parallelArrays.forEach(function(b2) {
              z2.push(b2 + "Data");
            }), c2.data && (c2.dataSorting && b(f2.options.dataSorting, c2.dataSorting), this.setData(c2.data, false)));
            c2 = U(g2, w2, { index: "undefined" === typeof g2.index ? f2.index : g2.index, pointStart: H(n2 && n2.series && n2.series.pointStart, g2.pointStart, f2.xData[0]) }, !q2 && { data: f2.options.data }, c2);
            q2 && c2.data && (c2.data = f2.options.data);
            z2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(z2);
            z2.forEach(function(b2) {
              z2[b2] = f2[b2];
              delete f2[b2];
            });
            n2 = false;
            if (u[p2]) {
              if (n2 = p2 !== f2.type, f2.remove(false, false, false, true), n2)
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(
                    f2,
                    u[p2].prototype
                  );
                else {
                  w2 = Object.hasOwnProperty.call(f2, "hcEvents") && f2.hcEvents;
                  for (v2 in m2)
                    f2[v2] = void 0;
                  b(f2, u[p2].prototype);
                  w2 ? f2.hcEvents = w2 : delete f2.hcEvents;
                }
            } else
              d(17, true, e2, { missingModuleFor: p2 });
            z2.forEach(function(b2) {
              f2[b2] = z2[b2];
            });
            f2.init(e2, c2);
            if (q2 && this.points) {
              c2 = f2.options;
              if (false === c2.visible)
                r2.graphic = 1, r2.dataLabel = 1;
              else if (!f2._hasPointLabels) {
                const { marker: b2, dataLabels: a4 } = c2;
                g2 = g2.marker || {};
                !b2 || false !== b2.enabled && g2.symbol === b2.symbol && g2.height === b2.height && g2.width === b2.width || (r2.graphic = 1);
                a4 && false === a4.enabled && (r2.dataLabel = 1);
              }
              for (const b2 of this.points)
                b2 && b2.series && (b2.resolveColor(), Object.keys(r2).length && b2.destroyElements(r2), false === c2.showInLegend && b2.legendItem && e2.legend.destroyItem(b2));
            }
            f2.initialType = h2;
            e2.linkSeries();
            n2 && f2.linkedSeries.length && (f2.isDirtyData = true);
            k(this, "afterUpdate");
            H(a3, true) && e2.redraw(q2 ? void 0 : false);
          }
          setName(b2) {
            this.name = this.options.name = this.userOptions.name = b2;
            this.chart.isDirtyLegend = true;
          }
          hasOptionChanged(b2) {
            const c2 = this.options[b2], a3 = this.chart.options.plotOptions, d2 = this.userOptions[b2];
            return d2 ? c2 !== d2 : c2 !== H(a3 && a3[this.type] && a3[this.type][b2], a3 && a3.series && a3.series[b2], c2);
          }
          onMouseOver() {
            const b2 = this.chart, c2 = b2.hoverSeries;
            b2.pointer.setHoverChartIndex();
            if (c2 && c2 !== this)
              c2.onMouseOut();
            this.options.events.mouseOver && k(this, "mouseOver");
            this.setState("hover");
            b2.hoverSeries = this;
          }
          onMouseOut() {
            const b2 = this.options, c2 = this.chart, a3 = c2.tooltip, d2 = c2.hoverPoint;
            c2.hoverSeries = null;
            if (d2)
              d2.onMouseOut();
            this && b2.events.mouseOut && k(this, "mouseOut");
            !a3 || this.stickyTracking || a3.shared && !this.noSharedTooltip || a3.hide();
            c2.series.forEach(function(b3) {
              b3.setState(
                "",
                true
              );
            });
          }
          setState(b2, c2) {
            const a3 = this;
            var d2 = a3.options;
            const k2 = a3.graph, f2 = d2.inactiveOtherPoints, e2 = d2.states, l2 = H(e2[b2 || "normal"] && e2[b2 || "normal"].animation, a3.chart.options.chart.animation);
            let g2 = d2.lineWidth, h2 = 0, n2 = d2.opacity;
            b2 = b2 || "";
            if (a3.state !== b2 && ([a3.group, a3.markerGroup, a3.dataLabelsGroup].forEach(function(c3) {
              c3 && (a3.state && c3.removeClass("highcharts-series-" + a3.state), b2 && c3.addClass("highcharts-series-" + b2));
            }), a3.state = b2, !a3.chart.styledMode)) {
              if (e2[b2] && false === e2[b2].enabled)
                return;
              b2 && (g2 = e2[b2].lineWidth || g2 + (e2[b2].lineWidthPlus || 0), n2 = H(e2[b2].opacity, n2));
              if (k2 && !k2.dashstyle && P(g2))
                for (d2 = { "stroke-width": g2 }, k2.animate(d2, l2); a3["zone-graph-" + h2]; )
                  a3["zone-graph-" + h2].animate(d2, l2), h2 += 1;
              f2 || [a3.group, a3.markerGroup, a3.dataLabelsGroup, a3.labelBySeries].forEach(function(b3) {
                b3 && b3.animate({ opacity: n2 }, l2);
              });
            }
            c2 && f2 && a3.points && a3.setAllPointsToState(b2 || void 0);
          }
          setAllPointsToState(b2) {
            this.points.forEach(function(c2) {
              c2.setState && c2.setState(b2);
            });
          }
          setVisible(b2, c2) {
            const a3 = this, d2 = a3.chart, f2 = d2.options.chart.ignoreHiddenSeries, e2 = a3.visible, l2 = (a3.visible = b2 = a3.options.visible = a3.userOptions.visible = "undefined" === typeof b2 ? !e2 : b2) ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function(b3) {
              if (a3[b3])
                a3[b3][l2]();
            });
            if (d2.hoverSeries === a3 || (d2.hoverPoint && d2.hoverPoint.series) === a3)
              a3.onMouseOut();
            a3.legendItem && d2.legend.colorizeItem(a3, b2);
            a3.isDirty = true;
            a3.options.stacking && d2.series.forEach(function(b3) {
              b3.options.stacking && b3.visible && (b3.isDirty = true);
            });
            a3.linkedSeries.forEach(function(c3) {
              c3.setVisible(b2, false);
            });
            f2 && (d2.isDirtyBox = true);
            k(a3, l2);
            false !== c2 && d2.redraw();
          }
          show() {
            this.setVisible(true);
          }
          hide() {
            this.setVisible(false);
          }
          select(b2) {
            this.selected = b2 = this.options.selected = "undefined" === typeof b2 ? !this.selected : b2;
            this.checkbox && (this.checkbox.checked = b2);
            k(this, b2 ? "select" : "unselect");
          }
          shouldShowTooltip(b2, c2, a3 = {}) {
            a3.series = this;
            a3.visiblePlotOnly = true;
            return this.chart.isInsidePlot(b2, c2, a3);
          }
          drawLegendSymbol(b2, c2) {
            var a3;
            null === (a3 = G[this.options.legendSymbol || "rectangle"]) || void 0 === a3 ? void 0 : a3.call(this, b2, c2);
          }
        }
        Z.defaultOptions = E;
        Z.types = B.seriesTypes;
        Z.registerType = B.registerSeriesType;
        b(Z.prototype, {
          axisTypes: ["xAxis", "yAxis"],
          coll: "series",
          colorCounter: 0,
          cropShoulder: 1,
          directTouch: false,
          isCartesian: true,
          kdAxisArray: ["clientX", "plotY"],
          parallelArrays: ["x", "y"],
          pointClass: D,
          requireSorting: true,
          sorted: true
        });
        B.series = Z;
        "";
        "";
        return Z;
      });
      L(a, "Core/Chart/Chart.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Time.js"],
        a["Core/Utilities.js"],
        a["Core/Renderer/HTML/AST.js"]
      ], function(a2, A, J, K, G, D, E, B, t, q, m, p, n) {
        const { animate: h, animObject: g, setAnimation: e } = a2, { defaultOptions: x, defaultTime: u } = J, { numberFormat: M } = K, { registerEventOptions: C } = G, { charts: f, doc: y, marginNames: r, svg: l, win: v } = D, { seriesTypes: d } = t, {
          addEvent: b,
          attr: c,
          createElement: k,
          css: w,
          defined: z,
          diffObjects: F,
          discardElement: O,
          erase: P,
          error: T,
          extend: U,
          find: W,
          fireEvent: H,
          getStyle: Y,
          isArray: ea,
          isNumber: aa,
          isObject: Z,
          isString: N,
          merge: L2,
          objectEach: Q,
          pick: R,
          pInt: V,
          relativeLength: ha,
          removeEvent: ia,
          splat: da,
          syncTimeout: ja,
          uniqueKey: ba
        } = p;
        class S2 {
          static chart(b2, c2, a3) {
            return new S2(b2, c2, a3);
          }
          constructor(b2, c2, a3) {
            this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
            this.sharedClips = {};
            this.zooming = this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
            this.getArgs(b2, c2, a3);
          }
          getArgs(b2, c2, a3) {
            N(b2) || b2.nodeName ? (this.renderTo = b2, this.init(c2, a3)) : this.init(b2, c2);
          }
          setZoomOptions() {
            const b2 = this.options.chart, c2 = b2.zooming;
            this.zooming = Object.assign(Object.assign({}, c2), { type: R(b2.zoomType, c2.type), key: R(b2.zoomKey, c2.key), pinchType: R(b2.pinchType, c2.pinchType), singleTouch: R(b2.zoomBySingleTouch, c2.singleTouch, false), resetButton: L2(
              c2.resetButton,
              b2.resetZoomButton
            ) });
          }
          init(b2, c2) {
            H(this, "init", { args: arguments }, function() {
              const a3 = L2(x, b2), d2 = a3.chart;
              this.userOptions = U({}, b2);
              this.margin = [];
              this.spacing = [];
              this.bounds = { h: {}, v: {} };
              this.labelCollectors = [];
              this.callback = c2;
              this.isResizing = 0;
              this.options = a3;
              this.axes = [];
              this.series = [];
              this.time = b2.time && Object.keys(b2.time).length ? new m(b2.time) : D.time;
              this.numberFormatter = d2.numberFormatter || M;
              this.styledMode = d2.styledMode;
              this.hasCartesianSeries = d2.showAxes;
              this.index = f.length;
              f.push(this);
              D.chartCount++;
              C(
                this,
                d2
              );
              this.xAxis = [];
              this.yAxis = [];
              this.pointCount = this.colorCounter = this.symbolCounter = 0;
              this.setZoomOptions();
              H(this, "afterInit");
              this.firstRender();
            });
          }
          initSeries(b2) {
            var c2 = this.options.chart;
            c2 = b2.type || c2.type;
            const a3 = d[c2];
            a3 || T(17, true, this, { missingModuleFor: c2 });
            c2 = new a3();
            "function" === typeof c2.init && c2.init(this, b2);
            return c2;
          }
          setSeriesData() {
            this.getSeriesOrderByLinks().forEach(function(b2) {
              b2.points || b2.data || !b2.enabledDataSorting || b2.setData(b2.options.data, false);
            });
          }
          getSeriesOrderByLinks() {
            return this.series.concat().sort(function(b2, c2) {
              return b2.linkedSeries.length || c2.linkedSeries.length ? c2.linkedSeries.length - b2.linkedSeries.length : 0;
            });
          }
          orderItems(b2, c2 = 0) {
            const a3 = this[b2], d2 = this.options[b2] = da(this.options[b2]).slice();
            b2 = this.userOptions[b2] = this.userOptions[b2] ? da(this.userOptions[b2]).slice() : [];
            this.hasRendered && (d2.splice(c2), b2.splice(c2));
            if (a3) {
              for (let k2 = c2, f2 = a3.length; k2 < f2; ++k2)
                if (c2 = a3[k2])
                  c2.index = k2, c2 instanceof B && (c2.name = c2.getName()), c2.options.isInternal || (d2[k2] = c2.options, b2[k2] = c2.userOptions);
            }
          }
          isInsidePlot(b2, c2, a3 = {}) {
            const {
              inverted: d2,
              plotBox: k2,
              plotLeft: f2,
              plotTop: e2,
              scrollablePlotBox: l2
            } = this;
            var g2 = 0;
            let h2 = 0;
            a3.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: g2, scrollTop: h2 } = this.scrollingContainer);
            const n2 = a3.series, m2 = a3.visiblePlotOnly && l2 || k2;
            var w2 = a3.inverted ? c2 : b2;
            c2 = a3.inverted ? b2 : c2;
            b2 = { x: w2, y: c2, isInsidePlot: true, options: a3 };
            if (!a3.ignoreX) {
              const c3 = n2 && (d2 && !this.polar ? n2.yAxis : n2.xAxis) || { pos: f2, len: Infinity };
              w2 = a3.paneCoordinates ? c3.pos + w2 : f2 + w2;
              w2 >= Math.max(g2 + f2, c3.pos) && w2 <= Math.min(g2 + f2 + m2.width, c3.pos + c3.len) || (b2.isInsidePlot = false);
            }
            !a3.ignoreY && b2.isInsidePlot && (g2 = !d2 && a3.axis && !a3.axis.isXAxis && a3.axis || n2 && (d2 ? n2.xAxis : n2.yAxis) || { pos: e2, len: Infinity }, a3 = a3.paneCoordinates ? g2.pos + c2 : e2 + c2, a3 >= Math.max(h2 + e2, g2.pos) && a3 <= Math.min(h2 + e2 + m2.height, g2.pos + g2.len) || (b2.isInsidePlot = false));
            H(this, "afterIsInsidePlot", b2);
            return b2.isInsidePlot;
          }
          redraw(b2) {
            H(this, "beforeRedraw");
            const c2 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], a3 = this.series, d2 = this.pointer, k2 = this.legend, f2 = this.userOptions.legend, l2 = this.renderer, g2 = l2.isHidden(), h2 = [];
            let n2, m2, w2 = this.isDirtyBox, r2 = this.isDirtyLegend, v2;
            l2.rootFontSize = l2.boxWrapper.getStyle("font-size");
            this.setResponsive && this.setResponsive(false);
            e(this.hasRendered ? b2 : false, this);
            g2 && this.temporaryDisplay();
            this.layOutTitles(false);
            for (b2 = a3.length; b2--; )
              if (v2 = a3[b2], v2.options.stacking || v2.options.centerInCategory) {
                if (m2 = true, v2.isDirty) {
                  n2 = true;
                  break;
                }
              }
            if (n2)
              for (b2 = a3.length; b2--; )
                v2 = a3[b2], v2.options.stacking && (v2.isDirty = true);
            a3.forEach(function(b3) {
              b3.isDirty && ("point" === b3.options.legendType ? ("function" === typeof b3.updateTotals && b3.updateTotals(), r2 = true) : f2 && (f2.labelFormatter || f2.labelFormat) && (r2 = true));
              b3.isDirtyData && H(b3, "updatedData");
            });
            r2 && k2 && k2.options.enabled && (k2.render(), this.isDirtyLegend = false);
            m2 && this.getStacks();
            c2.forEach(function(b3) {
              b3.updateNames();
              b3.setScale();
            });
            this.getMargins();
            c2.forEach(function(b3) {
              b3.isDirty && (w2 = true);
            });
            c2.forEach(function(b3) {
              const c3 = b3.min + "," + b3.max;
              b3.extKey !== c3 && (b3.extKey = c3, h2.push(function() {
                H(b3, "afterSetExtremes", U(b3.eventArgs, b3.getExtremes()));
                delete b3.eventArgs;
              }));
              (w2 || m2) && b3.redraw();
            });
            w2 && this.drawChartBox();
            H(this, "predraw");
            a3.forEach(function(b3) {
              (w2 || b3.isDirty) && b3.visible && b3.redraw();
              b3.isDirtyData = false;
            });
            d2 && d2.reset(true);
            l2.draw();
            H(this, "redraw");
            H(this, "render");
            g2 && this.temporaryDisplay(true);
            h2.forEach(function(b3) {
              b3.call();
            });
          }
          get(b2) {
            function c2(c3) {
              return c3.id === b2 || c3.options && c3.options.id === b2;
            }
            const a3 = this.series;
            let d2 = W(this.axes, c2) || W(this.series, c2);
            for (let b3 = 0; !d2 && b3 < a3.length; b3++)
              d2 = W(a3[b3].points || [], c2);
            return d2;
          }
          getAxes() {
            const b2 = this.options;
            H(this, "getAxes");
            for (const c2 of ["xAxis", "yAxis"]) {
              const a3 = b2[c2] = da(b2[c2] || {});
              for (const b3 of a3)
                new A(this, b3, c2);
            }
            H(this, "afterGetAxes");
          }
          getSelectedPoints() {
            return this.series.reduce((b2, c2) => {
              c2.getPointsCollection().forEach((c3) => {
                R(c3.selectedStaging, c3.selected) && b2.push(c3);
              });
              return b2;
            }, []);
          }
          getSelectedSeries() {
            return this.series.filter(function(b2) {
              return b2.selected;
            });
          }
          setTitle(b2, c2, a3) {
            this.applyDescription("title", b2);
            this.applyDescription("subtitle", c2);
            this.applyDescription("caption", void 0);
            this.layOutTitles(a3);
          }
          applyDescription(b2, c2) {
            const a3 = this, d2 = this.options[b2] = L2(this.options[b2], c2);
            let k2 = this[b2];
            k2 && c2 && (this[b2] = k2 = k2.destroy());
            d2 && !k2 && (k2 = this.renderer.text(d2.text, 0, 0, d2.useHTML).attr({
              align: d2.align,
              "class": "highcharts-" + b2,
              zIndex: d2.zIndex || 4
            }).add(), k2.update = function(c3, d3) {
              a3.applyDescription(b2, c3);
              a3.layOutTitles(d3);
            }, this.styledMode || k2.css(U("title" === b2 ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, d2.style)), this[b2] = k2);
          }
          layOutTitles(b2 = true) {
            const c2 = [0, 0, 0], a3 = this.renderer, d2 = this.spacingBox;
            ["title", "subtitle", "caption"].forEach(function(b3) {
              const k3 = this[b3], f2 = this.options[b3], e2 = f2.verticalAlign || "top";
              b3 = "title" === b3 ? "top" === e2 ? -3 : 0 : "top" === e2 ? c2[0] + 2 : 0;
              if (k3) {
                k3.css({ width: (f2.width || d2.width + (f2.widthAdjust || 0)) + "px" });
                const l2 = a3.fontMetrics(k3).b, g2 = Math.round(k3.getBBox(f2.useHTML).height);
                k3.align(U({ y: "bottom" === e2 ? l2 : b3 + l2, height: g2 }, f2), false, "spacingBox");
                f2.floating || ("top" === e2 ? c2[0] = Math.ceil(c2[0] + g2) : "bottom" === e2 && (c2[2] = Math.ceil(c2[2] + g2)));
              }
            }, this);
            c2[0] && "top" === (this.options.title.verticalAlign || "top") && (c2[0] += this.options.title.margin);
            c2[2] && "bottom" === this.options.caption.verticalAlign && (c2[2] += this.options.caption.margin);
            const k2 = !this.titleOffset || this.titleOffset.join(",") !== c2.join(",");
            this.titleOffset = c2;
            H(this, "afterLayOutTitles");
            !this.isDirtyBox && k2 && (this.isDirtyBox = this.isDirtyLegend = k2, this.hasRendered && b2 && this.isDirtyBox && this.redraw());
          }
          getContainerBox() {
            return { width: Y(this.renderTo, "width", true) || 0, height: Y(this.renderTo, "height", true) || 0 };
          }
          getChartSize() {
            var b2 = this.options.chart;
            const c2 = b2.width;
            b2 = b2.height;
            const a3 = this.getContainerBox();
            this.chartWidth = Math.max(0, c2 || a3.width || 600);
            this.chartHeight = Math.max(0, ha(b2, this.chartWidth) || (1 < a3.height ? a3.height : 400));
            this.containerBox = a3;
          }
          temporaryDisplay(b2) {
            let c2 = this.renderTo;
            if (b2)
              for (; c2 && c2.style; )
                c2.hcOrigStyle && (w(c2, c2.hcOrigStyle), delete c2.hcOrigStyle), c2.hcOrigDetached && (y.body.removeChild(c2), c2.hcOrigDetached = false), c2 = c2.parentNode;
            else
              for (; c2 && c2.style; ) {
                y.body.contains(c2) || c2.parentNode || (c2.hcOrigDetached = true, y.body.appendChild(c2));
                if ("none" === Y(c2, "display", false) || c2.hcOricDetached)
                  c2.hcOrigStyle = { display: c2.style.display, height: c2.style.height, overflow: c2.style.overflow }, b2 = { display: "block", overflow: "hidden" }, c2 !== this.renderTo && (b2.height = 0), w(c2, b2), c2.offsetWidth || c2.style.setProperty(
                    "display",
                    "block",
                    "important"
                  );
                c2 = c2.parentNode;
                if (c2 === y.body)
                  break;
              }
          }
          setClassName(b2) {
            this.container.className = "highcharts-container " + (b2 || "");
          }
          getContainer() {
            const b2 = this.options, a3 = b2.chart;
            var d2 = ba();
            let g2, h2 = this.renderTo;
            h2 || (this.renderTo = h2 = a3.renderTo);
            N(h2) && (this.renderTo = h2 = y.getElementById(h2));
            h2 || T(13, true, this);
            var m2 = V(c(h2, "data-highcharts-chart"));
            aa(m2) && f[m2] && f[m2].hasRendered && f[m2].destroy();
            c(h2, "data-highcharts-chart", this.index);
            h2.innerHTML = n.emptyHTML;
            a3.skipClone || h2.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            m2 = this.chartWidth;
            const r2 = this.chartHeight;
            w(h2, { overflow: "hidden" });
            this.styledMode || (g2 = U({ position: "relative", overflow: "hidden", width: m2 + "px", height: r2 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, a3.style || {}));
            this.container = d2 = k("div", { id: d2 }, g2, h2);
            this._cursor = d2.style.cursor;
            this.renderer = new (a3.renderer || !l ? E.getRendererType(a3.renderer) : q)(
              d2,
              m2,
              r2,
              void 0,
              a3.forExport,
              b2.exporting && b2.exporting.allowHTML,
              this.styledMode
            );
            this.containerBox = this.getContainerBox();
            e(void 0, this);
            this.setClassName(a3.className);
            if (this.styledMode)
              for (const c2 in b2.defs)
                this.renderer.definition(b2.defs[c2]);
            else
              this.renderer.setStyle(a3.style);
            this.renderer.chartIndex = this.index;
            H(this, "afterGetContainer");
          }
          getMargins(b2) {
            const { spacing: c2, margin: a3, titleOffset: d2 } = this;
            this.resetMargins();
            d2[0] && !z(a3[0]) && (this.plotTop = Math.max(this.plotTop, d2[0] + c2[0]));
            d2[2] && !z(a3[2]) && (this.marginBottom = Math.max(
              this.marginBottom,
              d2[2] + c2[2]
            ));
            this.legend && this.legend.display && this.legend.adjustMargins(a3, c2);
            H(this, "getMargins");
            b2 || this.getAxisMargins();
          }
          getAxisMargins() {
            const b2 = this, c2 = b2.axisOffset = [0, 0, 0, 0], a3 = b2.colorAxis, d2 = b2.margin, k2 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.getOffset();
              });
            };
            b2.hasCartesianSeries ? k2(b2.axes) : a3 && a3.length && k2(a3);
            r.forEach(function(a4, k3) {
              z(d2[k3]) || (b2[a4] += c2[k3]);
            });
            b2.setChartSize();
          }
          getOptions() {
            return F(this.userOptions, x);
          }
          reflow(b2) {
            const c2 = this;
            var a3 = c2.options.chart;
            a3 = z(a3.width) && z(a3.height);
            const d2 = c2.containerBox, k2 = c2.getContainerBox();
            delete c2.pointer.chartPosition;
            if (!a3 && !c2.isPrinting && d2 && k2.width) {
              if (k2.width !== d2.width || k2.height !== d2.height)
                p.clearTimeout(c2.reflowTimeout), c2.reflowTimeout = ja(function() {
                  c2.container && c2.setSize(void 0, void 0, false);
                }, b2 ? 100 : 0);
              c2.containerBox = k2;
            }
          }
          setReflow() {
            const c2 = this;
            var a3 = (b2) => {
              var a4;
              (null === (a4 = c2.options) || void 0 === a4 ? 0 : a4.chart.reflow) && c2.hasLoaded && c2.reflow(b2);
            };
            "function" === typeof ResizeObserver ? new ResizeObserver(a3).observe(c2.renderTo) : (a3 = b(v, "resize", a3), b(
              this,
              "destroy",
              a3
            ));
          }
          setSize(b2, c2, a3) {
            const d2 = this, k2 = d2.renderer;
            d2.isResizing += 1;
            e(a3, d2);
            a3 = k2.globalAnimation;
            d2.oldChartHeight = d2.chartHeight;
            d2.oldChartWidth = d2.chartWidth;
            "undefined" !== typeof b2 && (d2.options.chart.width = b2);
            "undefined" !== typeof c2 && (d2.options.chart.height = c2);
            d2.getChartSize();
            d2.styledMode || (a3 ? h : w)(d2.container, { width: d2.chartWidth + "px", height: d2.chartHeight + "px" }, a3);
            d2.setChartSize(true);
            k2.setSize(d2.chartWidth, d2.chartHeight, a3);
            d2.axes.forEach(function(b3) {
              b3.isDirty = true;
              b3.setScale();
            });
            d2.isDirtyLegend = true;
            d2.isDirtyBox = true;
            d2.layOutTitles();
            d2.getMargins();
            d2.redraw(a3);
            d2.oldChartHeight = null;
            H(d2, "resize");
            ja(function() {
              d2 && H(d2, "endResize", null, function() {
                --d2.isResizing;
              });
            }, g(a3).duration);
          }
          setChartSize(b2) {
            var c2 = this.inverted;
            const a3 = this.renderer;
            var d2 = this.chartWidth, k2 = this.chartHeight;
            const f2 = this.options.chart, e2 = this.spacing, l2 = this.clipOffset;
            let g2, h2, n2, m2;
            this.plotLeft = g2 = Math.round(this.plotLeft);
            this.plotTop = h2 = Math.round(this.plotTop);
            this.plotWidth = n2 = Math.max(0, Math.round(d2 - g2 - this.marginRight));
            this.plotHeight = m2 = Math.max(
              0,
              Math.round(k2 - h2 - this.marginBottom)
            );
            this.plotSizeX = c2 ? m2 : n2;
            this.plotSizeY = c2 ? n2 : m2;
            this.plotBorderWidth = f2.plotBorderWidth || 0;
            this.spacingBox = a3.spacingBox = { x: e2[3], y: e2[0], width: d2 - e2[3] - e2[1], height: k2 - e2[0] - e2[2] };
            this.plotBox = a3.plotBox = { x: g2, y: h2, width: n2, height: m2 };
            c2 = 2 * Math.floor(this.plotBorderWidth / 2);
            d2 = Math.ceil(Math.max(c2, l2[3]) / 2);
            k2 = Math.ceil(Math.max(c2, l2[0]) / 2);
            this.clipBox = { x: d2, y: k2, width: Math.floor(this.plotSizeX - Math.max(c2, l2[1]) / 2 - d2), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(c2, l2[2]) / 2 - k2)) };
            b2 || (this.axes.forEach(function(b3) {
              b3.setAxisSize();
              b3.setAxisTranslation();
            }), a3.alignElements());
            H(this, "afterSetChartSize", { skipAxes: b2 });
          }
          resetMargins() {
            H(this, "resetMargins");
            const b2 = this, c2 = b2.options.chart;
            ["margin", "spacing"].forEach(function(a3) {
              const d2 = c2[a3], k2 = Z(d2) ? d2 : [d2, d2, d2, d2];
              ["Top", "Right", "Bottom", "Left"].forEach(function(d3, f2) {
                b2[a3][f2] = R(c2[a3 + d3], k2[f2]);
              });
            });
            r.forEach(function(c3, a3) {
              b2[c3] = R(b2.margin[a3], b2.spacing[a3]);
            });
            b2.axisOffset = [0, 0, 0, 0];
            b2.clipOffset = [0, 0, 0, 0];
          }
          drawChartBox() {
            const b2 = this.options.chart, c2 = this.renderer, a3 = this.chartWidth, d2 = this.chartHeight, k2 = this.styledMode, f2 = this.plotBGImage;
            var e2 = b2.backgroundColor;
            const l2 = b2.plotBackgroundColor, g2 = b2.plotBackgroundImage, h2 = this.plotLeft, n2 = this.plotTop, m2 = this.plotWidth, w2 = this.plotHeight, r2 = this.plotBox, v2 = this.clipRect, z2 = this.clipBox;
            let p2 = this.chartBackground, q2 = this.plotBackground, F2 = this.plotBorder, y2, x2, t2 = "animate";
            p2 || (this.chartBackground = p2 = c2.rect().addClass("highcharts-background").add(), t2 = "attr");
            if (k2)
              y2 = x2 = p2.strokeWidth();
            else {
              y2 = b2.borderWidth || 0;
              x2 = y2 + (b2.shadow ? 8 : 0);
              e2 = { fill: e2 || "none" };
              if (y2 || p2["stroke-width"])
                e2.stroke = b2.borderColor, e2["stroke-width"] = y2;
              p2.attr(e2).shadow(b2.shadow);
            }
            p2[t2]({ x: x2 / 2, y: x2 / 2, width: a3 - x2 - y2 % 2, height: d2 - x2 - y2 % 2, r: b2.borderRadius });
            t2 = "animate";
            q2 || (t2 = "attr", this.plotBackground = q2 = c2.rect().addClass("highcharts-plot-background").add());
            q2[t2](r2);
            k2 || (q2.attr({ fill: l2 || "none" }).shadow(b2.plotShadow), g2 && (f2 ? (g2 !== f2.attr("href") && f2.attr("href", g2), f2.animate(r2)) : this.plotBGImage = c2.image(g2, h2, n2, m2, w2).add()));
            v2 ? v2.animate({ width: z2.width, height: z2.height }) : this.clipRect = c2.clipRect(z2);
            t2 = "animate";
            F2 || (t2 = "attr", this.plotBorder = F2 = c2.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
            k2 || F2.attr({ stroke: b2.plotBorderColor, "stroke-width": b2.plotBorderWidth || 0, fill: "none" });
            F2[t2](F2.crisp({ x: h2, y: n2, width: m2, height: w2 }, -F2.strokeWidth()));
            this.isDirtyBox = false;
            H(this, "afterDrawChartBox");
          }
          propFromSeries() {
            const b2 = this, c2 = b2.options.chart, a3 = b2.options.series;
            let k2, f2, e2;
            ["inverted", "angular", "polar"].forEach(function(l2) {
              f2 = d[c2.type];
              e2 = c2[l2] || f2 && f2.prototype[l2];
              for (k2 = a3 && a3.length; !e2 && k2--; )
                (f2 = d[a3[k2].type]) && f2.prototype[l2] && (e2 = true);
              b2[l2] = e2;
            });
          }
          linkSeries(b2) {
            const c2 = this, a3 = c2.series;
            a3.forEach(function(b3) {
              b3.linkedSeries.length = 0;
            });
            a3.forEach(function(b3) {
              let a4 = b3.options.linkedTo;
              N(a4) && (a4 = ":previous" === a4 ? c2.series[b3.index - 1] : c2.get(a4)) && a4.linkedParent !== b3 && (a4.linkedSeries.push(b3), b3.linkedParent = a4, a4.enabledDataSorting && b3.setDataSortingOptions(), b3.visible = R(b3.options.visible, a4.options.visible, b3.visible));
            });
            H(this, "afterLinkSeries", { isUpdating: b2 });
          }
          renderSeries() {
            this.series.forEach(function(b2) {
              b2.translate();
              b2.render();
            });
          }
          render() {
            const b2 = this.axes, c2 = this.colorAxis, a3 = this.renderer, d2 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.render();
              });
            };
            let k2 = 0;
            this.setTitle();
            H(this, "beforeMargins");
            this.getStacks && this.getStacks();
            this.getMargins(true);
            this.setChartSize();
            const f2 = this.plotWidth;
            b2.some(function(b3) {
              if (b3.horiz && b3.visible && b3.options.labels.enabled && b3.series.length)
                return k2 = 21, true;
            });
            const e2 = this.plotHeight = Math.max(this.plotHeight - k2, 0);
            b2.forEach(function(b3) {
              b3.setScale();
            });
            this.getAxisMargins();
            const l2 = 1.1 < f2 / this.plotWidth, g2 = 1.05 < e2 / this.plotHeight;
            if (l2 || g2)
              b2.forEach(function(b3) {
                (b3.horiz && l2 || !b3.horiz && g2) && b3.setTickInterval(true);
              }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries ? d2(b2) : c2 && c2.length && d2(c2);
            this.seriesGroup || (this.seriesGroup = a3.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add());
            this.renderSeries();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.hasRendered = true;
          }
          addCredits(b2) {
            const c2 = this, a3 = L2(true, this.options.credits, b2);
            a3.enabled && !this.credits && (this.credits = this.renderer.text(a3.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              a3.href && (v.location.href = a3.href);
            }).attr({ align: a3.position.align, zIndex: 8 }), c2.styledMode || this.credits.css(a3.style), this.credits.add().align(a3.position), this.credits.update = function(b3) {
              c2.credits = c2.credits.destroy();
              c2.addCredits(b3);
            });
          }
          destroy() {
            const b2 = this, c2 = b2.axes, a3 = b2.series, d2 = b2.container, k2 = d2 && d2.parentNode;
            let e2;
            H(b2, "destroy");
            b2.renderer.forExport ? P(f, b2) : f[b2.index] = void 0;
            D.chartCount--;
            b2.renderTo.removeAttribute("data-highcharts-chart");
            ia(b2);
            for (e2 = c2.length; e2--; )
              c2[e2] = c2[e2].destroy();
            this.scroller && this.scroller.destroy && this.scroller.destroy();
            for (e2 = a3.length; e2--; )
              a3[e2] = a3[e2].destroy();
            "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(c3) {
              const a4 = b2[c3];
              a4 && a4.destroy && (b2[c3] = a4.destroy());
            });
            d2 && (d2.innerHTML = n.emptyHTML, ia(d2), k2 && O(d2));
            Q(b2, function(c3, a4) {
              delete b2[a4];
            });
          }
          firstRender() {
            const b2 = this, c2 = b2.options;
            b2.getContainer();
            b2.resetMargins();
            b2.setChartSize();
            b2.propFromSeries();
            b2.getAxes();
            const a3 = ea(c2.series) ? c2.series : [];
            c2.series = [];
            a3.forEach(function(c3) {
              b2.initSeries(c3);
            });
            b2.linkSeries();
            b2.setSeriesData();
            H(b2, "beforeRender");
            b2.render();
            b2.pointer.getChartPosition();
            if (!b2.renderer.imgCount && !b2.hasLoaded)
              b2.onload();
            b2.temporaryDisplay(true);
          }
          onload() {
            this.callbacks.concat([this.callback]).forEach(function(b2) {
              b2 && "undefined" !== typeof this.index && b2.apply(this, [this]);
            }, this);
            H(this, "load");
            H(this, "render");
            z(this.index) && this.setReflow();
            this.warnIfA11yModuleNotLoaded();
            this.hasLoaded = true;
          }
          warnIfA11yModuleNotLoaded() {
            const { options: b2, title: c2 } = this;
            b2 && !this.accessibility && (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (c2 && c2.element.textContent || "").replace(/</g, "&lt;") }), b2.accessibility && false === b2.accessibility.enabled || T(
              'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
              false,
              this
            ));
          }
          addSeries(b2, c2, a3) {
            const d2 = this;
            let k2;
            b2 && (c2 = R(c2, true), H(d2, "addSeries", { options: b2 }, function() {
              k2 = d2.initSeries(b2);
              d2.isDirtyLegend = true;
              d2.linkSeries();
              k2.enabledDataSorting && k2.setData(b2.data, false);
              H(d2, "afterAddSeries", { series: k2 });
              c2 && d2.redraw(a3);
            }));
            return k2;
          }
          addAxis(b2, c2, a3, d2) {
            return this.createAxis(c2 ? "xAxis" : "yAxis", { axis: b2, redraw: a3, animation: d2 });
          }
          addColorAxis(b2, c2, a3) {
            return this.createAxis("colorAxis", { axis: b2, redraw: c2, animation: a3 });
          }
          createAxis(b2, c2) {
            b2 = new A(this, c2.axis, b2);
            R(c2.redraw, true) && this.redraw(c2.animation);
            return b2;
          }
          showLoading(c2) {
            const a3 = this, d2 = a3.options, f2 = d2.loading, e2 = function() {
              l2 && w(l2, { left: a3.plotLeft + "px", top: a3.plotTop + "px", width: a3.plotWidth + "px", height: a3.plotHeight + "px" });
            };
            let l2 = a3.loadingDiv, g2 = a3.loadingSpan;
            l2 || (a3.loadingDiv = l2 = k("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, a3.container));
            g2 || (a3.loadingSpan = g2 = k("span", { className: "highcharts-loading-inner" }, null, l2), b(a3, "redraw", e2));
            l2.className = "highcharts-loading";
            n.setElementHTML(g2, R(c2, d2.lang.loading, ""));
            a3.styledMode || (w(
              l2,
              U(f2.style, { zIndex: 10 })
            ), w(g2, f2.labelStyle), a3.loadingShown || (w(l2, { opacity: 0, display: "" }), h(l2, { opacity: f2.style.opacity || 0.5 }, { duration: f2.showDuration || 0 })));
            a3.loadingShown = true;
            e2();
          }
          hideLoading() {
            const b2 = this.options, c2 = this.loadingDiv;
            c2 && (c2.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || h(c2, { opacity: 0 }, { duration: b2.loading.hideDuration || 100, complete: function() {
              w(c2, { display: "none" });
            } }));
            this.loadingShown = false;
          }
          update(b2, c2, a3, d2) {
            const k2 = this, f2 = {
              credits: "addCredits",
              title: "setTitle",
              subtitle: "setSubtitle",
              caption: "setCaption"
            }, e2 = b2.isResponsiveOptions, l2 = [];
            let g2, h2;
            H(k2, "update", { options: b2 });
            e2 || k2.setResponsive(false, true);
            b2 = F(b2, k2.options);
            k2.userOptions = L2(k2.userOptions, b2);
            var n2 = b2.chart;
            if (n2) {
              L2(true, k2.options.chart, n2);
              this.setZoomOptions();
              "className" in n2 && k2.setClassName(n2.className);
              if ("inverted" in n2 || "polar" in n2 || "type" in n2) {
                k2.propFromSeries();
                var w2 = true;
              }
              "alignTicks" in n2 && (w2 = true);
              "events" in n2 && C(this, n2);
              Q(n2, function(b3, c3) {
                -1 !== k2.propsRequireUpdateSeries.indexOf("chart." + c3) && (g2 = true);
                -1 !== k2.propsRequireDirtyBox.indexOf(c3) && (k2.isDirtyBox = true);
                -1 !== k2.propsRequireReflow.indexOf(c3) && (e2 ? k2.isDirtyBox = true : h2 = true);
              });
              !k2.styledMode && n2.style && k2.renderer.setStyle(k2.options.chart.style || {});
            }
            !k2.styledMode && b2.colors && (this.options.colors = b2.colors);
            b2.time && (this.time === u && (this.time = new m(b2.time)), L2(true, k2.options.time, b2.time));
            Q(b2, function(c3, a4) {
              if (k2[a4] && "function" === typeof k2[a4].update)
                k2[a4].update(c3, false);
              else if ("function" === typeof k2[f2[a4]])
                k2[f2[a4]](c3);
              else
                "colors" !== a4 && -1 === k2.collectionsWithUpdate.indexOf(a4) && L2(true, k2.options[a4], b2[a4]);
              "chart" !== a4 && -1 !== k2.propsRequireUpdateSeries.indexOf(a4) && (g2 = true);
            });
            this.collectionsWithUpdate.forEach(function(c3) {
              b2[c3] && (da(b2[c3]).forEach(function(b3, d3) {
                const f3 = z(b3.id);
                let e3;
                f3 && (e3 = k2.get(b3.id));
                !e3 && k2[c3] && (e3 = k2[c3][R(b3.index, d3)]) && (f3 && z(e3.options.id) || e3.options.isInternal) && (e3 = void 0);
                e3 && e3.coll === c3 && (e3.update(b3, false), a3 && (e3.touched = true));
                !e3 && a3 && k2.collectionsWithInit[c3] && (k2.collectionsWithInit[c3][0].apply(k2, [b3].concat(k2.collectionsWithInit[c3][1] || []).concat([false])).touched = true);
              }), a3 && k2[c3].forEach(function(b3) {
                b3.touched || b3.options.isInternal ? delete b3.touched : l2.push(b3);
              }));
            });
            l2.forEach(function(b3) {
              b3.chart && b3.remove && b3.remove(false);
            });
            w2 && k2.axes.forEach(function(b3) {
              b3.update({}, false);
            });
            g2 && k2.getSeriesOrderByLinks().forEach(function(b3) {
              b3.chart && b3.update({}, false);
            }, this);
            w2 = n2 && n2.width;
            n2 = n2 && (N(n2.height) ? ha(n2.height, w2 || k2.chartWidth) : n2.height);
            h2 || aa(w2) && w2 !== k2.chartWidth || aa(n2) && n2 !== k2.chartHeight ? k2.setSize(w2, n2, d2) : R(c2, true) && k2.redraw(d2);
            H(k2, "afterUpdate", { options: b2, redraw: c2, animation: d2 });
          }
          setSubtitle(b2, c2) {
            this.applyDescription(
              "subtitle",
              b2
            );
            this.layOutTitles(c2);
          }
          setCaption(b2, c2) {
            this.applyDescription("caption", b2);
            this.layOutTitles(c2);
          }
          showResetZoom() {
            function b2() {
              c2.zoomOut();
            }
            const c2 = this, a3 = x.lang, d2 = c2.zooming.resetButton, k2 = d2.theme, f2 = "chart" === d2.relativeTo || "spacingBox" === d2.relativeTo ? null : "scrollablePlotBox";
            H(this, "beforeShowResetZoom", null, function() {
              c2.resetZoomButton = c2.renderer.button(a3.resetZoom, null, null, b2, k2).attr({ align: d2.position.align, title: a3.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(d2.position, false, f2);
            });
            H(
              this,
              "afterShowResetZoom"
            );
          }
          zoomOut() {
            H(this, "selection", { resetSelection: true }, this.zoom);
          }
          zoom(b2) {
            const c2 = this, a3 = c2.pointer;
            let d2 = false, k2;
            !b2 || b2.resetSelection ? (c2.axes.forEach(function(b3) {
              k2 = b3.zoom();
            }), a3.initiated = false) : b2.xAxis.concat(b2.yAxis).forEach(function(b3) {
              const f3 = b3.axis;
              if (a3[f3.isXAxis ? "zoomX" : "zoomY"] && z(a3.mouseDownX) && z(a3.mouseDownY) && c2.isInsidePlot(a3.mouseDownX - c2.plotLeft, a3.mouseDownY - c2.plotTop, { axis: f3 }) || !z(c2.inverted ? a3.mouseDownX : a3.mouseDownY))
                k2 = f3.zoom(b3.min, b3.max), f3.displayBtn && (d2 = true);
            });
            const f2 = c2.resetZoomButton;
            d2 && !f2 ? c2.showResetZoom() : !d2 && Z(f2) && (c2.resetZoomButton = f2.destroy());
            k2 && c2.redraw(R(c2.options.chart.animation, b2 && b2.animation, 100 > c2.pointCount));
          }
          pan(b2, c2) {
            const a3 = this, d2 = a3.hoverPoints;
            c2 = "object" === typeof c2 ? c2 : { enabled: c2, type: "x" };
            const k2 = a3.options.chart;
            k2 && k2.panning && (k2.panning = c2);
            const f2 = c2.type;
            let e2;
            H(this, "pan", { originalEvent: b2 }, function() {
              d2 && d2.forEach(function(b3) {
                b3.setState();
              });
              let c3 = a3.xAxis;
              "xy" === f2 ? c3 = c3.concat(a3.yAxis) : "y" === f2 && (c3 = a3.yAxis);
              const k3 = {};
              c3.forEach(function(c4) {
                if (c4.options.panningEnabled && !c4.options.isInternal) {
                  var d3 = c4.horiz, l2 = b2[d3 ? "chartX" : "chartY"];
                  d3 = d3 ? "mouseDownX" : "mouseDownY";
                  var g2 = a3[d3], h2 = c4.minPointOffset || 0, n2 = c4.reversed && !a3.inverted || !c4.reversed && a3.inverted ? -1 : 1, m2 = c4.getExtremes(), w2 = c4.toValue(g2 - l2, true) + h2 * n2, r2 = c4.toValue(g2 + c4.len - l2, true) - (h2 * n2 || c4.isXAxis && c4.pointRangePadding || 0), v2 = r2 < w2;
                  n2 = c4.hasVerticalPanning();
                  g2 = v2 ? r2 : w2;
                  w2 = v2 ? w2 : r2;
                  var z2 = c4.panningState;
                  !n2 || c4.isXAxis || z2 && !z2.isDirty || c4.series.forEach(function(b3) {
                    var c5 = b3.getProcessedData(true);
                    c5 = b3.getExtremes(c5.yData, true);
                    z2 || (z2 = {
                      startMin: Number.MAX_VALUE,
                      startMax: -Number.MAX_VALUE
                    });
                    aa(c5.dataMin) && aa(c5.dataMax) && (z2.startMin = Math.min(R(b3.options.threshold, Infinity), c5.dataMin, z2.startMin), z2.startMax = Math.max(R(b3.options.threshold, -Infinity), c5.dataMax, z2.startMax));
                  });
                  n2 = Math.min(R(z2 && z2.startMin, m2.dataMin), h2 ? m2.min : c4.toValue(c4.toPixels(m2.min) - c4.minPixelPadding));
                  r2 = Math.max(R(z2 && z2.startMax, m2.dataMax), h2 ? m2.max : c4.toValue(c4.toPixels(m2.max) + c4.minPixelPadding));
                  c4.panningState = z2;
                  c4.isOrdinal || (h2 = n2 - g2, 0 < h2 && (w2 += h2, g2 = n2), h2 = w2 - r2, 0 < h2 && (w2 = r2, g2 -= h2), c4.series.length && g2 !== m2.min && w2 !== m2.max && g2 >= n2 && w2 <= r2 && (c4.setExtremes(g2, w2, false, false, { trigger: "pan" }), !a3.resetZoomButton && g2 !== n2 && w2 !== r2 && f2.match("y") && (a3.showResetZoom(), c4.displayBtn = false), e2 = true), k3[d3] = l2);
                }
              });
              Q(k3, (b3, c4) => {
                a3[c4] = b3;
              });
              e2 && a3.redraw(false);
              w(a3.container, { cursor: "move" });
            });
          }
        }
        U(S2.prototype, {
          callbacks: [],
          collectionsWithInit: { xAxis: [S2.prototype.addAxis, [true]], yAxis: [S2.prototype.addAxis, [false]], series: [S2.prototype.addSeries] },
          collectionsWithUpdate: ["xAxis", "yAxis", "series"],
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
        });
        "";
        return S2;
      });
      L(
        a,
        "Extensions/ScrollablePlotArea.js",
        [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]],
        function(a2, A, J, K, G, D) {
          const { stop: u } = a2, { addEvent: B, createElement: t, defined: q, merge: m, pick: p } = D;
          B(J, "afterSetChartSize", function(a3) {
            var h = this.options.chart.scrollablePlotArea, g = h && h.minWidth;
            h = h && h.minHeight;
            let e;
            if (!this.renderer.forExport) {
              if (g) {
                if (this.scrollablePixelsX = g = Math.max(0, g - this.chartWidth))
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox), this.plotBox.width = this.plotWidth += g, this.inverted ? this.clipBox.height += g : this.clipBox.width += g, e = { 1: { name: "right", value: g } };
              } else
                h && (this.scrollablePixelsY = g = Math.max(0, h - this.chartHeight), q(g) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox), this.plotBox.height = this.plotHeight += g, this.inverted ? this.clipBox.width += g : this.clipBox.height += g, e = { 2: { name: "bottom", value: g } }));
              e && !a3.skipAxes && this.axes.forEach(function(a4) {
                e[a4.side] ? a4.getPlotLinePath = function() {
                  let g2 = e[a4.side].name, h2 = this[g2], n;
                  this[g2] = h2 - e[a4.side].value;
                  n = A.prototype.getPlotLinePath.apply(this, arguments);
                  this[g2] = h2;
                  return n;
                } : (a4.setAxisSize(), a4.setAxisTranslation());
              });
            }
          });
          B(J, "render", function() {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });
          J.prototype.setUpScrolling = function() {
            const a3 = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
            this.scrollablePixelsX && (a3.overflowX = "auto");
            this.scrollablePixelsY && (a3.overflowY = "auto");
            this.scrollingParent = t("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo);
            this.scrollingContainer = t("div", { className: "highcharts-scrolling" }, a3, this.scrollingParent);
            let h;
            B(this.scrollingContainer, "scroll", () => {
              this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (h = this.hoverPoint), this.pointer.runPointActions(void 0, h, true));
            });
            this.innerContainer = t("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };
          J.prototype.moveFixedElements = function() {
            let a3 = this.container, h = this.fixedRenderer, g = ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), e;
            this.scrollablePixelsX && !this.inverted ? e = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? e = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? e = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (e = ".highcharts-yaxis");
            e && g.push(`${e}:not(.highcharts-radial-axis)`, `${e}-labels:not(.highcharts-radial-axis-labels)`);
            g.forEach(function(e2) {
              [].forEach.call(a3.querySelectorAll(e2), function(a4) {
                (a4.namespaceURI === h.SVG_NS ? h.box : h.box.parentNode).appendChild(a4);
                a4.style.pointerEvents = "auto";
              });
            });
          };
          J.prototype.applyFixed = function() {
            var a3 = !this.fixedDiv, h = this.options.chart, g = h.scrollablePlotArea, e = G.getRendererType();
            a3 ? (this.fixedDiv = t("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (h.style && h.style.zIndex || 0) + 2, top: 0 }, null, true), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = h = new e(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = h.path().attr({ fill: this.options.chart.backgroundColor || "#fff", "fill-opacity": p(
              g.opacity,
              0.85
            ), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), B(this, "afterShowResetZoom", this.moveFixedElements), B(this, "afterApplyDrilldown", this.moveFixedElements), B(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a3)
              this.scrollableDirty = false, this.moveFixedElements();
            h = this.chartWidth + (this.scrollablePixelsX || 0);
            e = this.chartHeight + (this.scrollablePixelsY || 0);
            u(this.container);
            this.container.style.width = h + "px";
            this.container.style.height = e + "px";
            this.renderer.boxWrapper.attr({ width: h, height: e, viewBox: [0, 0, h, e].join(" ") });
            this.chartBackground.attr({ width: h, height: e });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a3 && (g.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * g.scrollPositionX), g.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * g.scrollPositionY));
            e = this.axisOffset;
            a3 = this.plotTop - e[0] - 1;
            g = this.plotLeft - e[3] - 1;
            h = this.plotTop + this.plotHeight + e[2] + 1;
            e = this.plotLeft + this.plotWidth + e[1] + 1;
            let m2 = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), q2 = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a3 = this.scrollablePixelsX ? [["M", 0, a3], ["L", this.plotLeft - 1, a3], ["L", this.plotLeft - 1, h], ["L", 0, h], ["Z"], ["M", m2, a3], ["L", this.chartWidth, a3], ["L", this.chartWidth, h], ["L", m2, h], ["Z"]] : this.scrollablePixelsY ? [["M", g, 0], ["L", g, this.plotTop - 1], ["L", e, this.plotTop - 1], ["L", e, 0], ["Z"], ["M", g, q2], ["L", g, this.chartHeight], ["L", e, this.chartHeight], [
              "L",
              e,
              q2
            ], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({ d: a3 });
          };
          B(A, "afterInit", function() {
            this.chart.scrollableDirty = true;
          });
          B(K, "show", function() {
            this.chart.scrollableDirty = true;
          });
          "";
        }
      );
      L(a, "Core/Axis/Stacking/StackItem.js", [a["Core/Templating.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { format: u } = a2, { series: G } = A, { destroyObjectProperties: D, fireEvent: E, isNumber: B, pick: t } = J;
        class q {
          constructor(a3, p, n, h, g) {
            const e = a3.chart.inverted, m = a3.reversed;
            this.axis = a3;
            a3 = this.isNegative = !!n !== !!m;
            this.options = p = p || {};
            this.x = h;
            this.cumulative = this.total = null;
            this.points = {};
            this.hasValidPoints = false;
            this.stack = g;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = { align: p.align || (e ? a3 ? "left" : "right" : "center"), verticalAlign: p.verticalAlign || (e ? "middle" : a3 ? "bottom" : "top"), y: p.y, x: p.x };
            this.textAlign = p.textAlign || (e ? a3 ? "right" : "left" : "center");
          }
          destroy() {
            D(this, this.axis);
          }
          render(a3) {
            const m = this.axis.chart, n = this.options;
            var h = n.format;
            h = h ? u(h, this, m) : n.formatter.call(this);
            this.label ? this.label.attr({ text: h, visibility: "hidden" }) : (this.label = m.renderer.label(h, null, void 0, n.shape, void 0, void 0, n.useHTML, false, "stack-labels"), h = { r: n.borderRadius || 0, text: h, padding: t(n.padding, 5), visibility: "hidden" }, m.styledMode || (h.fill = n.backgroundColor, h.stroke = n.borderColor, h["stroke-width"] = n.borderWidth, this.label.css(n.style || {})), this.label.attr(h), this.label.added || this.label.add(a3));
            this.label.labelrank = m.plotSizeY;
            E(this, "afterRender");
          }
          setOffset(a3, p, n, h, g, e) {
            const {
              alignOptions: m,
              axis: q2,
              label: u2,
              options: C,
              textAlign: f
            } = this, y = q2.chart;
            n = this.getStackBox({ xOffset: a3, width: p, boxBottom: n, boxTop: h, defaultX: g, xAxis: e });
            var { verticalAlign: r } = m;
            if (u2 && n) {
              h = u2.getBBox();
              g = u2.padding;
              e = "justify" === t(C.overflow, "justify");
              m.x = C.x || 0;
              m.y = C.y || 0;
              const { x: a4, y: v } = this.adjustStackPosition({ labelBox: h, verticalAlign: r, textAlign: f });
              n.x -= a4;
              n.y -= v;
              u2.align(m, false, n);
              (r = y.isInsidePlot(u2.alignAttr.x + m.x + a4, u2.alignAttr.y + m.y + v)) || (e = false);
              e && G.prototype.justifyDataLabel.call(q2, u2, m, u2.alignAttr, h, n);
              u2.attr({
                x: u2.alignAttr.x,
                y: u2.alignAttr.y,
                rotation: C.rotation,
                rotationOriginX: h.width / 2,
                rotationOriginY: h.height / 2
              });
              t(!e && C.crop, true) && (r = B(u2.x) && B(u2.y) && y.isInsidePlot(u2.x - g + u2.width, u2.y) && y.isInsidePlot(u2.x + g, u2.y));
              u2[r ? "show" : "hide"]();
            }
            E(this, "afterSetOffset", { xOffset: a3, width: p });
          }
          adjustStackPosition({ labelBox: a3, verticalAlign: p, textAlign: n }) {
            const h = { bottom: 0, middle: 1, top: 2, right: 1, center: 0, left: -1 };
            return { x: a3.width / 2 + a3.width / 2 * h[n], y: a3.height / 2 * h[p] };
          }
          getStackBox(a3) {
            var m = this.axis;
            const n = m.chart, {
              boxTop: h,
              defaultX: g,
              xOffset: e,
              width: q2,
              boxBottom: u2
            } = a3;
            var M = m.stacking.usePercentage ? 100 : t(h, this.total, 0);
            M = m.toPixels(M);
            a3 = a3.xAxis || n.xAxis[0];
            const C = t(g, a3.translate(this.x)) + e;
            m = m.toPixels(u2 || B(m.min) && m.logarithmic && m.logarithmic.lin2log(m.min) || 0);
            m = Math.abs(M - m);
            const f = this.isNegative;
            return n.inverted ? { x: (f ? M : M - m) - n.plotLeft, y: a3.height - C - q2, width: m, height: q2 } : { x: C + a3.transB - n.plotLeft, y: (f ? M - m : M) - n.plotTop, width: q2, height: m };
          }
        }
        "";
        return q;
      });
      L(a, "Core/Axis/Stacking/StackingAxis.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G) {
        function u() {
          const b = this, c = b.inverted;
          b.yAxis.forEach((b2) => {
            b2.stacking && b2.stacking.stacks && b2.hasVisibleSeries && (b2.stacking.oldStacks = b2.stacking.stacks);
          });
          b.series.forEach((a3) => {
            const d2 = a3.xAxis && a3.xAxis.options || {};
            !a3.options.stacking || true !== a3.visible && false !== b.options.chart.ignoreHiddenSeries || (a3.stackKey = [a3.type, l(a3.options.stack, ""), c ? d2.top : d2.left, c ? d2.height : d2.width].join());
          });
        }
        function E() {
          const b = this.stacking;
          if (b) {
            var c = b.stacks;
            r(c, function(b2, a3) {
              M(b2);
              c[a3] = null;
            });
            b && b.stackTotalGroup && b.stackTotalGroup.destroy();
          }
        }
        function B() {
          "yAxis" !== this.coll || this.stacking || (this.stacking = new v(this));
        }
        function t(b, c, a3, d2) {
          !I(b) || b.x !== c || d2 && b.stackKey !== d2 ? b = { x: c, index: 0, key: d2, stackKey: d2 } : b.index++;
          b.key = [a3, c, b.index].join();
          return b;
        }
        function q() {
          const b = this, c = b.stackKey, a3 = b.yAxis.stacking.stacks, d2 = b.processedXData, f2 = b[b.options.stacking + "Stacker"];
          let e2;
          f2 && [c, "-" + c].forEach((c2) => {
            let k = d2.length;
            let l2;
            for (; k--; ) {
              var g2 = d2[k];
              e2 = b.getStackIndicator(e2, g2, b.index, c2);
              (l2 = (g2 = a3[c2] && a3[c2][g2]) && g2.points[e2.key]) && f2.call(b, l2, g2, k);
            }
          });
        }
        function m(b, c, a3) {
          c = c.total ? 100 / c.total : 0;
          b[0] = x(b[0] * c);
          b[1] = x(b[1] * c);
          this.stackedYData[a3] = b[1];
        }
        function p() {
          const b = this.yAxis.stacking;
          this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? g.setStackedPoints.call(this, "group") : b && r(b.stacks, (c, a3) => {
            "group" === a3.slice(-5) && (r(c, (b2) => b2.destroy()), delete b.stacks[a3]);
          });
        }
        function n(b) {
          var c = this.chart;
          const a3 = b || this.options.stacking;
          if (a3 && (true === this.visible || false === c.options.chart.ignoreHiddenSeries)) {
            var d2 = this.processedXData, e2 = this.processedYData, g2 = [], h2 = e2.length, n2 = this.options, m2 = n2.threshold, r2 = l(n2.startFromThreshold && m2, 0);
            n2 = n2.stack;
            b = b ? `${this.type},${a3}` : this.stackKey;
            var v2 = "-" + b, p2 = this.negStacks;
            c = "group" === a3 ? c.yAxis[0] : this.yAxis;
            var q2 = c.stacking.stacks, y2 = c.stacking.oldStacks, t2, u2;
            c.stacking.stacksTouched += 1;
            for (u2 = 0; u2 < h2; u2++) {
              var C2 = d2[u2];
              var B2 = e2[u2];
              var M2 = this.getStackIndicator(M2, C2, this.index);
              var A2 = M2.key;
              var E2 = (t2 = p2 && B2 < (r2 ? 0 : m2)) ? v2 : b;
              q2[E2] || (q2[E2] = {});
              q2[E2][C2] || (y2[E2] && y2[E2][C2] ? (q2[E2][C2] = y2[E2][C2], q2[E2][C2].total = null) : q2[E2][C2] = new K(c, c.options.stackLabels, !!t2, C2, n2));
              E2 = q2[E2][C2];
              null !== B2 ? (E2.points[A2] = E2.points[this.index] = [l(E2.cumulative, r2)], I(E2.cumulative) || (E2.base = A2), E2.touched = c.stacking.stacksTouched, 0 < M2.index && false === this.singleStacks && (E2.points[A2][0] = E2.points[this.index + "," + C2 + ",0"][0])) : E2.points[A2] = E2.points[this.index] = null;
              "percent" === a3 ? (t2 = t2 ? b : v2, p2 && q2[t2] && q2[t2][C2] ? (t2 = q2[t2][C2], E2.total = t2.total = Math.max(t2.total, E2.total) + Math.abs(B2) || 0) : E2.total = x(E2.total + (Math.abs(B2) || 0))) : "group" === a3 ? (f(B2) && (B2 = B2[0]), null !== B2 && (E2.total = (E2.total || 0) + 1)) : E2.total = x(E2.total + (B2 || 0));
              E2.cumulative = "group" === a3 ? (E2.total || 1) - 1 : x(l(E2.cumulative, r2) + (B2 || 0));
              null !== B2 && (E2.points[A2].push(E2.cumulative), g2[u2] = E2.cumulative, E2.hasValidPoints = true);
            }
            "percent" === a3 && (c.stacking.usePercentage = true);
            "group" !== a3 && (this.stackedYData = g2);
            c.stacking.oldStacks = {};
          }
        }
        const { getDeferredAnimation: h } = a2, { series: { prototype: g } } = J, { addEvent: e, correctFloat: x, defined: I, destroyObjectProperties: M, fireEvent: C, isArray: f, isNumber: y, objectEach: r, pick: l } = G;
        class v {
          constructor(b) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = b;
          }
          buildStacks() {
            const b = this.axis, c = b.series, a3 = b.options.reversedStacks, d2 = c.length;
            let f2, e2;
            this.usePercentage = false;
            for (e2 = d2; e2--; )
              f2 = c[a3 ? e2 : d2 - e2 - 1], f2.setStackedPoints(), f2.setGroupedPoints();
            for (e2 = 0; e2 < d2; e2++)
              c[e2].modifyStacks();
            C(b, "afterBuildStacks");
          }
          cleanStacks() {
            let b;
            this.oldStacks && (b = this.stacks = this.oldStacks);
            r(b, function(b2) {
              r(b2, function(b3) {
                b3.cumulative = b3.total;
              });
            });
          }
          resetStacks() {
            r(this.stacks, (b) => {
              r(b, (c, a3) => {
                y(c.touched) && c.touched < this.stacksTouched ? (c.destroy(), delete b[a3]) : (c.total = null, c.cumulative = null);
              });
            });
          }
          renderStackTotals() {
            var b = this.axis;
            const c = b.chart, a3 = c.renderer, d2 = this.stacks;
            b = h(c, b.options.stackLabels && b.options.stackLabels.animation || false);
            const f2 = this.stackTotalGroup = this.stackTotalGroup || a3.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
            f2.translate(c.plotLeft, c.plotTop);
            r(d2, function(b2) {
              r(b2, function(b3) {
                b3.render(f2);
              });
            });
            f2.animate({ opacity: 1 }, b);
          }
        }
        var d;
        (function(b) {
          const c = [];
          b.compose = function(b2, a3, d2) {
            G.pushUnique(c, b2) && (e(b2, "init", B), e(b2, "destroy", E));
            G.pushUnique(c, a3) && (a3.prototype.getStacks = u);
            G.pushUnique(c, d2) && (b2 = d2.prototype, b2.getStackIndicator = t, b2.modifyStacks = q, b2.percentStacker = m, b2.setGroupedPoints = p, b2.setStackedPoints = n);
          };
        })(d || (d = {}));
        return d;
      });
      L(
        a,
        "Series/Line/LineSeries.js",
        [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, A, J) {
          const { defined: u, merge: G } = J;
          class D extends a2 {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = void 0;
            }
            drawGraph() {
              const a3 = this, u2 = this.options, t = (this.gappedPath || this.getGraphPath).call(this), q = this.chart.styledMode;
              let m = [["graph", "highcharts-graph"]];
              q || m[0].push(u2.lineColor || this.color || "#cccccc", u2.dashStyle);
              m = a3.getZonesGraphs(m);
              m.forEach(function(m2, n) {
                var h = m2[0];
                let g = a3[h];
                const e = g ? "animate" : "attr";
                g ? (g.endX = a3.preventGraphAnimation ? null : t.xMap, g.animate({ d: t })) : t.length && (a3[h] = g = a3.chart.renderer.path(t).addClass(m2[1]).attr({ zIndex: 1 }).add(a3.group));
                g && !q && (h = { stroke: m2[2], "stroke-width": u2.lineWidth || 0, fill: a3.fillGraph && a3.color || "none" }, m2[3] ? h.dashstyle = m2[3] : "square" !== u2.linecap && (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), g[e](h).shadow(2 > n && u2.shadow));
                g && (g.startX = t.xMap, g.isArea = t.isArea);
              });
            }
            getGraphPath(a3, B, t) {
              const q = this, m = q.options, p = [], n = [];
              let h, g = m.step;
              a3 = a3 || q.points;
              const e = a3.reversed;
              e && a3.reverse();
              (g = { right: 1, center: 2 }[g] || g && 3) && e && (g = 4 - g);
              a3 = this.getValidPoints(a3, false, !(m.connectNulls && !B && !t));
              a3.forEach(function(e2, I) {
                const x = e2.plotX, C = e2.plotY, f = a3[I - 1], y = e2.isNull || "number" !== typeof C;
                (e2.leftCliff || f && f.rightCliff) && !t && (h = true);
                y && !u(B) && 0 < I ? h = !m.connectNulls : y && !B ? h = true : (0 === I || h ? I = [["M", e2.plotX, e2.plotY]] : q.getPointSpline ? I = [q.getPointSpline(a3, e2, I)] : g ? (I = 1 === g ? [["L", f.plotX, C]] : 2 === g ? [["L", (f.plotX + x) / 2, f.plotY], ["L", (f.plotX + x) / 2, C]] : [["L", x, f.plotY]], I.push(["L", x, C])) : I = [["L", x, C]], n.push(e2.x), g && (n.push(e2.x), 2 === g && n.push(e2.x)), p.push.apply(p, I), h = false);
              });
              p.xMap = n;
              return q.graphPath = p;
            }
            getZonesGraphs(a3) {
              this.zones.forEach(function(u2, t) {
                t = ["zone-graph-" + t, "highcharts-graph highcharts-zone-graph-" + t + " " + (u2.className || "")];
                this.chart.styledMode || t.push(u2.color || this.color, u2.dashStyle || this.options.dashStyle);
                a3.push(t);
              }, this);
              return a3;
            }
          }
          D.defaultOptions = G(a2.defaultOptions, { legendSymbol: "lineMarker" });
          A.registerSeriesType("line", D);
          "";
          return D;
        }
      );
      L(a, "Series/Area/AreaSeries.js", [
        a["Core/Color/Color.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J) {
        const { seriesTypes: { line: u } } = A, { extend: G, merge: D, objectEach: E, pick: B } = J;
        class t extends u {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            this.areaPath = [];
            super.drawGraph.apply(this);
            const a3 = this, m = this.areaPath, p = this.options, n = [["area", "highcharts-area", this.color, p.fillColor]];
            this.zones.forEach(function(h, g) {
              n.push(["zone-area-" + g, "highcharts-area highcharts-zone-area-" + g + " " + h.className, h.color || a3.color, h.fillColor || p.fillColor]);
            });
            n.forEach(function(h) {
              const g = h[0], e = {};
              let n2 = a3[g];
              const q = n2 ? "animate" : "attr";
              n2 ? (n2.endX = a3.preventGraphAnimation ? null : m.xMap, n2.animate({ d: m })) : (e.zIndex = 0, n2 = a3[g] = a3.chart.renderer.path(m).addClass(h[1]).add(a3.group), n2.isArea = true);
              a3.chart.styledMode || (h[3] ? e.fill = h[3] : (e.fill = h[2], e["fill-opacity"] = B(p.fillOpacity, 0.75)));
              n2[q](e);
              n2.startX = m.xMap;
              n2.shiftUnit = p.step ? 2 : 1;
            });
          }
          getGraphPath(a3) {
            var m = u.prototype.getGraphPath, p = this.options;
            const n = p.stacking, h = this.yAxis, g = [], e = [], q = this.index, t2 = h.stacking.stacks[this.stackKey], M = p.threshold, C = Math.round(h.getThreshold(p.threshold));
            p = B(p.connectNulls, "percent" === n);
            var f = function(f2, d, b) {
              var c = a3[f2];
              f2 = n && t2[c.x].points[q];
              const k = c[b + "Null"] || 0;
              b = c[b + "Cliff"] || 0;
              let l2, m2;
              c = true;
              b || k ? (l2 = (k ? f2[0] : f2[1]) + b, m2 = f2[0] + b, c = !!k) : !n && a3[d] && a3[d].isNull && (l2 = m2 = M);
              "undefined" !== typeof l2 && (e.push({ plotX: y, plotY: null === l2 ? C : h.getThreshold(l2), isNull: c, isCliff: true }), g.push({ plotX: y, plotY: null === m2 ? C : h.getThreshold(m2), doCurve: false }));
            };
            let y;
            a3 = a3 || this.points;
            n && (a3 = this.getStackPoints(a3));
            for (let h2 = 0, d = a3.length; h2 < d; ++h2) {
              n || (a3[h2].leftCliff = a3[h2].rightCliff = a3[h2].leftNull = a3[h2].rightNull = void 0);
              var r = a3[h2].isNull;
              y = B(a3[h2].rectPlotX, a3[h2].plotX);
              var l = n ? B(a3[h2].yBottom, C) : C;
              if (!r || p)
                p || f(h2, h2 - 1, "left"), r && !n && p || (e.push(a3[h2]), g.push({ x: h2, plotX: y, plotY: l })), p || f(h2, h2 + 1, "right");
            }
            f = m.call(this, e, true, true);
            g.reversed = true;
            r = m.call(this, g, true, true);
            (l = r[0]) && "M" === l[0] && (r[0] = ["L", l[1], l[2]]);
            r = f.concat(r);
            r.length && r.push(["Z"]);
            m = m.call(this, e, false, p);
            r.xMap = f.xMap;
            this.areaPath = r;
            return m;
          }
          getStackPoints(a3) {
            const m = this, p = [], n = [], h = this.xAxis, g = this.yAxis, e = g.stacking.stacks[this.stackKey], q = {}, t2 = g.series, u2 = t2.length, C = g.options.reversedStacks ? 1 : -1, f = t2.indexOf(m);
            a3 = a3 || this.points;
            if (this.options.stacking) {
              for (let f2 = 0; f2 < a3.length; f2++)
                a3[f2].leftNull = a3[f2].rightNull = void 0, q[a3[f2].x] = a3[f2];
              E(e, function(a4, f2) {
                null !== a4.total && n.push(f2);
              });
              n.sort(function(a4, f2) {
                return a4 - f2;
              });
              const y = t2.map((a4) => a4.visible);
              n.forEach(function(a4, l) {
                let r = 0, d, b;
                if (q[a4] && !q[a4].isNull)
                  p.push(q[a4]), [-1, 1].forEach(function(c) {
                    const k = 1 === c ? "rightNull" : "leftNull", g2 = e[n[l + c]];
                    let h2 = 0;
                    if (g2) {
                      let c2 = f;
                      for (; 0 <= c2 && c2 < u2; ) {
                        const f2 = t2[c2].index;
                        d = g2.points[f2];
                        d || (f2 === m.index ? q[a4][k] = true : y[c2] && (b = e[a4].points[f2]) && (h2 -= b[1] - b[0]));
                        c2 += C;
                      }
                    }
                    q[a4][1 === c ? "rightCliff" : "leftCliff"] = h2;
                  });
                else {
                  let b2 = f;
                  for (; 0 <= b2 && b2 < u2; ) {
                    if (d = e[a4].points[t2[b2].index]) {
                      r = d[1];
                      break;
                    }
                    b2 += C;
                  }
                  r = B(r, 0);
                  r = g.translate(r, 0, 1, 0, 1);
                  p.push({ isNull: true, plotX: h.translate(a4, 0, 0, 0, 1), x: a4, plotY: r, yBottom: r });
                }
              });
            }
            return p;
          }
        }
        t.defaultOptions = D(u.defaultOptions, { threshold: 0, legendSymbol: "rectangle" });
        G(t.prototype, { singleStacks: false });
        A.registerSeriesType("area", t);
        "";
        return t;
      });
      L(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { line: u } = a2.seriesTypes, { merge: K, pick: G } = A;
        class D extends u {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          getPointSpline(a3, u2, t) {
            const q = u2.plotX || 0, m = u2.plotY || 0, p = a3[t - 1];
            t = a3[t + 1];
            let n, h;
            let g;
            if (p && !p.isNull && false !== p.doCurve && !u2.isCliff && t && !t.isNull && false !== t.doCurve && !u2.isCliff) {
              a3 = p.plotY || 0;
              var e = t.plotX || 0;
              t = t.plotY || 0;
              let x = 0;
              n = (1.5 * q + (p.plotX || 0)) / 2.5;
              h = (1.5 * m + a3) / 2.5;
              e = (1.5 * q + e) / 2.5;
              g = (1.5 * m + t) / 2.5;
              e !== n && (x = (g - h) * (e - q) / (e - n) + m - g);
              h += x;
              g += x;
              h > a3 && h > m ? (h = Math.max(a3, m), g = 2 * m - h) : h < a3 && h < m && (h = Math.min(a3, m), g = 2 * m - h);
              g > t && g > m ? (g = Math.max(t, m), h = 2 * m - g) : g < t && g < m && (g = Math.min(t, m), h = 2 * m - g);
              u2.rightContX = e;
              u2.rightContY = g;
            }
            u2 = ["C", G(p.rightContX, p.plotX, 0), G(p.rightContY, p.plotY, 0), G(n, q, 0), G(h, m, 0), q, m];
            p.rightContX = p.rightContY = void 0;
            return u2;
          }
        }
        D.defaultOptions = K(u.defaultOptions);
        a2.registerSeriesType(
          "spline",
          D
        );
        "";
        return D;
      });
      L(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Spline/SplineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { area: u, area: { prototype: G } } = A.seriesTypes, { extend: D, merge: E } = J;
        class B extends a2 {
          constructor() {
            super(...arguments);
            this.options = this.points = this.data = void 0;
          }
        }
        B.defaultOptions = E(a2.defaultOptions, u.defaultOptions);
        D(B.prototype, { getGraphPath: G.getGraphPath, getStackPoints: G.getStackPoints, drawGraph: G.drawGraph });
        A.registerSeriesType(
          "areaspline",
          B
        );
        "";
        return B;
      });
      L(a, "Series/Column/ColumnSeriesDefaults.js", [], function() {
        "";
        return { borderRadius: 3, centerInCategory: false, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" };
      });
      L(a, "Series/Column/ColumnSeries.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Series/Column/ColumnSeriesDefaults.js"],
        a["Core/Globals.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G, D, E) {
        const { animObject: u } = a2, { parse: t } = A, { hasTouch: q, noop: m } = K, { clamp: p, defined: n, extend: h, fireEvent: g, isArray: e, isNumber: x, merge: I, pick: M, objectEach: C } = E;
        class f extends G {
          constructor() {
            super(...arguments);
            this.points = this.options = this.group = this.data = this.borderWidth = void 0;
          }
          animate(a3) {
            const f2 = this, e2 = this.yAxis, g2 = e2.pos, d = f2.options, b = this.chart.inverted, c = {}, k = b ? "translateX" : "translateY";
            let n2;
            a3 ? (c.scaleY = 1e-3, a3 = p(e2.toPixels(d.threshold), g2, g2 + e2.len), b ? c.translateX = a3 - e2.len : c.translateY = a3, f2.clipBox && f2.setClip(), f2.group.attr(c)) : (n2 = Number(f2.group.attr(k)), f2.group.animate({ scaleY: 1 }, h(u(f2.options.animation), { step: function(b2, a4) {
              f2.group && (c[k] = n2 + a4.pos * (g2 - n2), f2.group.attr(c));
            } })));
          }
          init(a3, f2) {
            super.init.apply(this, arguments);
            const e2 = this;
            a3 = e2.chart;
            a3.hasRendered && a3.series.forEach(function(a4) {
              a4.type === e2.type && (a4.isDirty = true);
            });
          }
          getColumnMetrics() {
            const a3 = this;
            var f2 = a3.options;
            const e2 = a3.xAxis, g2 = a3.yAxis;
            var d = e2.options.reversedStacks;
            d = e2.reversed && !d || !e2.reversed && d;
            const b = {};
            let c, k = 0;
            false === f2.grouping ? k = 1 : a3.chart.series.forEach(function(d2) {
              const f3 = d2.yAxis, e3 = d2.options;
              let l;
              d2.type !== a3.type || !d2.visible && a3.chart.options.chart.ignoreHiddenSeries || g2.len !== f3.len || g2.pos !== f3.pos || (e3.stacking && "group" !== e3.stacking ? (c = d2.stackKey, "undefined" === typeof b[c] && (b[c] = k++), l = b[c]) : false !== e3.grouping && (l = k++), d2.columnIndex = l);
            });
            const h2 = Math.min(Math.abs(e2.transA) * (e2.ordinal && e2.ordinal.slope || f2.pointRange || e2.closestPointRange || e2.tickInterval || 1), e2.len), n2 = h2 * f2.groupPadding, m2 = (h2 - 2 * n2) / (k || 1);
            f2 = Math.min(f2.maxPointWidth || e2.len, M(f2.pointWidth, m2 * (1 - 2 * f2.pointPadding)));
            a3.columnMetrics = { width: f2, offset: (m2 - f2) / 2 + (n2 + ((a3.columnIndex || 0) + (d ? 1 : 0)) * m2 - h2 / 2) * (d ? -1 : 1), paddedWidth: m2, columnCount: k };
            return a3.columnMetrics;
          }
          crispCol(a3, f2, e2, g2) {
            var d = this.borderWidth, b = -(d % 2 ? 0.5 : 0);
            d = d % 2 ? 0.5 : 1;
            this.options.crisp && (e2 = Math.round(a3 + e2) + b, a3 = Math.round(a3) + b, e2 -= a3);
            g2 = Math.round(f2 + g2) + d;
            b = 0.5 >= Math.abs(f2) && 0.5 < g2;
            f2 = Math.round(f2) + d;
            g2 -= f2;
            b && g2 && (--f2, g2 += 1);
            return { x: a3, y: f2, width: e2, height: g2 };
          }
          adjustForMissingColumns(a3, f2, l, g2) {
            const d = this.options.stacking;
            if (!l.isNull && 1 < g2.columnCount) {
              const b = this.yAxis.options.reversedStacks;
              let c = 0, k = b ? 0 : -g2.columnCount;
              C(this.yAxis.stacking && this.yAxis.stacking.stacks, (a4) => {
                if ("number" === typeof l.x) {
                  const f3 = a4[l.x.toString()];
                  f3 && (a4 = f3.points[this.index], d ? (a4 && (c = k), f3.hasValidPoints && (b ? k++ : k--)) : e(a4) && (a4 = Object.keys(f3.points).filter((b2) => !b2.match(",") && f3.points[b2] && 1 < f3.points[b2].length).map(parseFloat).sort((b2, a5) => a5 - b2), c = a4.indexOf(this.index), k = a4.length));
                }
              });
              a3 = (l.plotX || 0) + ((k - 1) * g2.paddedWidth + f2) / 2 - f2 - c * g2.paddedWidth;
            }
            return a3;
          }
          translate() {
            const a3 = this, f2 = a3.chart, e2 = a3.options;
            var h2 = a3.dense = 2 > a3.closestPointRange * a3.xAxis.transA;
            h2 = a3.borderWidth = M(e2.borderWidth, h2 ? 0 : 1);
            const d = a3.xAxis, b = a3.yAxis, c = e2.threshold, k = M(e2.minPointLength, 5), m2 = a3.getColumnMetrics(), z = m2.width, q2 = a3.pointXOffset = m2.offset, t2 = a3.dataMin, u2 = a3.dataMax;
            let I2 = a3.barW = Math.max(z, 1 + 2 * h2), C2 = a3.translatedThreshold = b.getThreshold(c);
            f2.inverted && (C2 -= 0.5);
            e2.pointPadding && (I2 = Math.ceil(I2));
            G.prototype.translate.apply(a3);
            a3.points.forEach(function(l) {
              const g2 = M(l.yBottom, C2);
              var h3 = 999 + Math.abs(g2), w = l.plotX || 0;
              h3 = p(l.plotY, -h3, b.len + h3);
              let r = Math.min(h3, g2), v = Math.max(h3, g2) - r, F = z, y = w + q2, O = I2;
              k && Math.abs(v) < k && (v = k, w = !b.reversed && !l.negative || b.reversed && l.negative, x(c) && x(u2) && l.y === c && u2 <= c && (b.min || 0) < c && (t2 !== u2 || (b.max || 0) <= c) && (w = !w, l.negative = !l.negative), r = Math.abs(r - C2) > k ? g2 - k : C2 - (w ? k : 0));
              n(l.options.pointWidth) && (F = O = Math.ceil(l.options.pointWidth), y -= Math.round((F - z) / 2));
              e2.centerInCategory && (y = a3.adjustForMissingColumns(y, F, l, m2));
              l.barX = y;
              l.pointWidth = F;
              l.tooltipPos = f2.inverted ? [p(b.len + b.pos - f2.plotLeft - h3, b.pos - f2.plotLeft, b.len + b.pos - f2.plotLeft), d.len + d.pos - f2.plotTop - y - O / 2, v] : [d.left - f2.plotLeft + y + O / 2, p(h3 + b.pos - f2.plotTop, b.pos - f2.plotTop, b.len + b.pos - f2.plotTop), v];
              l.shapeType = a3.pointClass.prototype.shapeType || "roundedRect";
              l.shapeArgs = a3.crispCol(y, l.isNull ? C2 : r, O, l.isNull ? 0 : v);
            });
            g(this, "afterColumnTranslate");
          }
          drawGraph() {
            this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
          }
          pointAttribs(a3, f2) {
            const e2 = this.options;
            var g2 = this.pointAttrToOptions || {}, d = g2.stroke || "borderColor";
            const b = g2["stroke-width"] || "borderWidth";
            let c, k = a3 && a3.color || this.color, h2 = a3 && a3[d] || e2[d] || k;
            g2 = a3 && a3.options.dashStyle || e2.dashStyle;
            let n2 = a3 && a3[b] || e2[b] || this[b] || 0, m2 = M(a3 && a3.opacity, e2.opacity, 1);
            a3 && this.zones.length && (c = a3.getZone(), k = a3.options.color || c && (c.color || a3.nonZonedColor) || this.color, c && (h2 = c.borderColor || h2, g2 = c.dashStyle || g2, n2 = c.borderWidth || n2));
            f2 && a3 && (a3 = I(
              e2.states[f2],
              a3.options.states && a3.options.states[f2] || {}
            ), f2 = a3.brightness, k = a3.color || "undefined" !== typeof f2 && t(k).brighten(a3.brightness).get() || k, h2 = a3[d] || h2, n2 = a3[b] || n2, g2 = a3.dashStyle || g2, m2 = M(a3.opacity, m2));
            d = { fill: k, stroke: h2, "stroke-width": n2, opacity: m2 };
            g2 && (d.dashstyle = g2);
            return d;
          }
          drawPoints(a3 = this.points) {
            const f2 = this, e2 = this.chart, g2 = f2.options, d = e2.renderer, b = g2.animationLimit || 250;
            let c;
            a3.forEach(function(a4) {
              let k = a4.graphic, l = !!k, h2 = k && e2.pointCount < b ? "animate" : "attr";
              if (x(a4.plotY) && null !== a4.y) {
                c = a4.shapeArgs;
                k && a4.hasNewShapeType() && (k = k.destroy());
                f2.enabledDataSorting && (a4.startXPos = f2.xAxis.reversed ? -(c ? c.width || 0 : 0) : f2.xAxis.width);
                k || (a4.graphic = k = d[a4.shapeType](c).add(a4.group || f2.group)) && f2.enabledDataSorting && e2.hasRendered && e2.pointCount < b && (k.attr({ x: a4.startXPos }), l = true, h2 = "animate");
                if (k && l)
                  k[h2](I(c));
                e2.styledMode || k[h2](f2.pointAttribs(a4, a4.selected && "select")).shadow(false !== a4.allowShadow && g2.shadow);
                k && (k.addClass(a4.getClassName(), true), k.attr({ visibility: a4.visible ? "inherit" : "hidden" }));
              } else
                k && (a4.graphic = k.destroy());
            });
          }
          drawTracker(a3 = this.points) {
            const f2 = this, l = f2.chart, h2 = l.pointer, d = function(b2) {
              const a4 = h2.getPointFromEvent(b2);
              "undefined" !== typeof a4 && f2.options.enableMouseTracking && (h2.isDirectTouch = true, a4.onMouseOver(b2));
            };
            let b;
            a3.forEach(function(a4) {
              b = e(a4.dataLabels) ? a4.dataLabels : a4.dataLabel ? [a4.dataLabel] : [];
              a4.graphic && (a4.graphic.element.point = a4);
              b.forEach(function(b2) {
                b2.div ? b2.div.point = a4 : b2.element.point = a4;
              });
            });
            f2._hasTracking || (f2.trackerGroups.forEach(function(b2) {
              if (f2[b2]) {
                f2[b2].addClass("highcharts-tracker").on("mouseover", d).on(
                  "mouseout",
                  function(b3) {
                    h2.onTrackerMouseOut(b3);
                  }
                );
                if (q)
                  f2[b2].on("touchstart", d);
                !l.styledMode && f2.options.cursor && f2[b2].css({ cursor: f2.options.cursor });
              }
            }), f2._hasTracking = true);
            g(this, "afterDrawTracker");
          }
          remove() {
            const a3 = this, f2 = a3.chart;
            f2.hasRendered && f2.series.forEach(function(f3) {
              f3.type === a3.type && (f3.isDirty = true);
            });
            G.prototype.remove.apply(a3, arguments);
          }
        }
        f.defaultOptions = I(G.defaultOptions, J);
        h(f.prototype, { cropShoulder: 0, directTouch: true, getSymbol: m, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] });
        D.registerSeriesType(
          "column",
          f
        );
        "";
        return f;
      });
      L(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { getDeferredAnimation: u } = a2, { format: G } = A, { defined: D, extend: E, fireEvent: B, isArray: t, isString: q, merge: m, objectEach: p, pick: n, splat: h } = J;
        var g;
        (function(a3) {
          function e(a4, b, c, f2, e2) {
            const d = this.chart;
            var k = this.isCartesian && d.inverted;
            const g3 = this.enabledDataSorting;
            var l2 = a4.plotX, h2 = a4.plotY;
            const m2 = c.rotation;
            var w = c.align;
            h2 = D(l2) && D(h2) && d.isInsidePlot(
              l2,
              Math.round(h2),
              { inverted: k, paneCoordinates: true, series: this }
            );
            let r2 = "justify" === n(c.overflow, g3 ? "none" : "justify");
            k = this.visible && false !== a4.visible && D(l2) && (a4.series.forceDL || g3 && !r2 || h2 || n(c.inside, !!this.options.stacking) && f2 && d.isInsidePlot(l2, k ? f2.x + 1 : f2.y + f2.height - 1, { inverted: k, paneCoordinates: true, series: this }));
            l2 = a4.pos();
            if (k && l2) {
              m2 && b.attr({ align: w });
              w = b.getBBox(true);
              var v2 = [0, 0];
              var p2 = d.renderer.fontMetrics(b).b;
              f2 = E({ x: l2[0], y: Math.round(l2[1]), width: 0, height: 0 }, f2);
              E(c, { width: w.width, height: w.height });
              m2 ? (r2 = false, v2 = d.renderer.rotCorr(p2, m2), p2 = { x: f2.x + (c.x || 0) + f2.width / 2 + v2.x, y: f2.y + (c.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[c.verticalAlign] * f2.height }, v2 = [w.x - Number(b.attr("x")), w.y - Number(b.attr("y"))], g3 && this.xAxis && !r2 && this.setDataLabelStartPos(a4, b, e2, h2, p2), b[e2 ? "attr" : "animate"](p2)) : (g3 && this.xAxis && !r2 && this.setDataLabelStartPos(a4, b, e2, h2, f2), b.align(c, void 0, f2), p2 = b.alignAttr);
              if (r2 && 0 <= f2.height)
                this.justifyDataLabel(b, c, p2, w, f2, e2);
              else if (n(c.crop, true)) {
                let { x: b2, y: a5 } = p2;
                b2 += v2[0];
                a5 += v2[1];
                k = d.isInsidePlot(b2, a5, {
                  paneCoordinates: true,
                  series: this
                }) && d.isInsidePlot(b2 + w.width, a5 + w.height, { paneCoordinates: true, series: this });
              }
              if (c.shape && !m2)
                b[e2 ? "attr" : "animate"]({ anchorX: l2[0], anchorY: l2[1] });
            }
            e2 && g3 && (b.placed = false);
            k || g3 && !r2 ? b.show() : (b.hide(), b.placed = false);
          }
          function g2(a4, b) {
            var c = b.filter;
            return c ? (b = c.operator, a4 = a4[c.property], c = c.value, ">" === b && a4 > c || "<" === b && a4 < c || ">=" === b && a4 >= c || "<=" === b && a4 <= c || "==" === b && a4 == c || "===" === b && a4 === c ? true : false) : true;
          }
          function M() {
            return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
          }
          function C(a4) {
            const b = this.hasRendered || 0, c = this.initDataLabelsGroup().attr({ opacity: +b });
            !b && c && (this.visible && c.show(), this.options.animation ? c.animate({ opacity: 1 }, a4) : c.attr({ opacity: 1 }));
            return c;
          }
          function f(a4 = this.points) {
            var b, c;
            const d = this, f2 = d.chart, e2 = d.options, l2 = f2.renderer, { backgroundColor: m2, plotBackgroundColor: v2 } = f2.options.chart, x = f2.options.plotOptions, y2 = l2.getContrast(q(v2) && v2 || q(m2) && m2 || "#000000");
            let I = e2.dataLabels, C2, M2;
            var A2 = h(I)[0];
            const E2 = A2.animation;
            A2 = A2.defer ? u(f2, E2, d) : { defer: 0, duration: 0 };
            I = r(r(null === (b = null === x || void 0 === x ? void 0 : x.series) || void 0 === b ? void 0 : b.dataLabels, null === (c = null === x || void 0 === x ? void 0 : x[d.type]) || void 0 === c ? void 0 : c.dataLabels), I);
            B(this, "drawDataLabels");
            if (t(I) || I.enabled || d._hasPointLabels)
              M2 = this.initDataLabels(A2), a4.forEach((b2) => {
                var a5;
                const c2 = b2.dataLabels || [];
                C2 = h(r(I, b2.dlOptions || (null === (a5 = b2.options) || void 0 === a5 ? void 0 : a5.dataLabels)));
                C2.forEach((a6, k) => {
                  var h2, m3 = a6.enabled && (!b2.isNull || b2.dataLabelOnNull) && g2(b2, a6);
                  const w = b2.connectors ? b2.connectors[k] : b2.connector, r2 = a6.style || {};
                  let v3 = {}, z = c2[k], x2 = !z;
                  const F = n(a6.distance, b2.labelDistance);
                  if (m3) {
                    var t2 = n(a6[b2.formatPrefix + "Format"], a6.format);
                    var u2 = b2.getLabelConfig();
                    u2 = D(t2) ? G(t2, u2, f2) : (a6[b2.formatPrefix + "Formatter"] || a6.formatter).call(u2, a6);
                    t2 = a6.rotation;
                    f2.styledMode || (r2.color = n(a6.color, r2.color, q(d.color) ? d.color : void 0, "#000000"), "contrast" === r2.color ? (b2.contrastColor = l2.getContrast(b2.color || d.color), r2.color = !D(F) && a6.inside || 0 > (F || 0) || e2.stacking ? b2.contrastColor : y2) : delete b2.contrastColor, e2.cursor && (r2.cursor = e2.cursor));
                    v3 = { r: a6.borderRadius || 0, rotation: t2, padding: a6.padding, zIndex: 1 };
                    if (!f2.styledMode) {
                      const { backgroundColor: c3, borderColor: d2 } = a6;
                      v3.fill = "auto" === c3 ? b2.color : c3;
                      v3.stroke = "auto" === d2 ? b2.color : d2;
                      v3["stroke-width"] = a6.borderWidth;
                    }
                    p(v3, (b3, a7) => {
                      "undefined" === typeof b3 && delete v3[a7];
                    });
                  }
                  !z || m3 && D(u2) && !!z.div === !!a6.useHTML && (z.rotation && a6.rotation || z.rotation === a6.rotation) || (z = void 0, x2 = true, w && b2.connector && (b2.connector = b2.connector.destroy(), b2.connectors && (1 === b2.connectors.length ? delete b2.connectors : delete b2.connectors[k])));
                  m3 && D(u2) && (z ? v3.text = u2 : (z = t2 ? l2.text(u2, 0, 0, a6.useHTML).addClass("highcharts-data-label") : l2.label(u2, 0, 0, a6.shape, void 0, void 0, a6.useHTML, void 0, "data-label")) && z.addClass(" highcharts-data-label-color-" + b2.colorIndex + " " + (a6.className || "") + (a6.useHTML ? " highcharts-tracker" : "")), z && (z.options = a6, z.attr(v3), f2.styledMode || z.css(r2).shadow(a6.shadow), (m3 = a6[b2.formatPrefix + "TextPath"] || a6.textPath) && !a6.useHTML && (z.setTextPath((null === (h2 = b2.getDataLabelPath) || void 0 === h2 ? void 0 : h2.call(b2, z)) || b2.graphic, m3), b2.dataLabelPath && !m3.enabled && (b2.dataLabelPath = b2.dataLabelPath.destroy())), z.added || z.add(M2), d.alignDataLabel(b2, z, a6, void 0, x2), z.isActive = true, c2[k] && c2[k] !== z && c2[k].destroy(), c2[k] = z));
                });
                for (a5 = c2.length; a5--; )
                  c2[a5].isActive ? c2[a5].isActive = false : (c2[a5].destroy(), c2.splice(a5, 1));
                b2.dataLabel = c2[0];
                b2.dataLabels = c2;
              });
            B(this, "afterDrawDataLabels");
          }
          function y(a4, b, c, f2, e2, l2) {
            const d = this.chart, k = b.align, g3 = b.verticalAlign, h2 = a4.box ? 0 : a4.padding || 0;
            let { x: n2 = 0, y: m2 = 0 } = b, w, r2;
            w = (c.x || 0) + h2;
            0 > w && ("right" === k && 0 <= n2 ? (b.align = "left", b.inside = true) : n2 -= w, r2 = true);
            w = (c.x || 0) + f2.width - h2;
            w > d.plotWidth && ("left" === k && 0 >= n2 ? (b.align = "right", b.inside = true) : n2 += d.plotWidth - w, r2 = true);
            w = c.y + h2;
            0 > w && ("bottom" === g3 && 0 <= m2 ? (b.verticalAlign = "top", b.inside = true) : m2 -= w, r2 = true);
            w = (c.y || 0) + f2.height - h2;
            w > d.plotHeight && ("top" === g3 && 0 >= m2 ? (b.verticalAlign = "bottom", b.inside = true) : m2 += d.plotHeight - w, r2 = true);
            r2 && (b.x = n2, b.y = m2, a4.placed = !l2, a4.align(b, void 0, e2));
            return r2;
          }
          function r(a4, b) {
            let c = [], d;
            if (t(a4) && !t(b))
              c = a4.map(function(a5) {
                return m(a5, b);
              });
            else if (t(b) && !t(a4))
              c = b.map(function(b2) {
                return m(a4, b2);
              });
            else if (!t(a4) && !t(b))
              c = m(a4, b);
            else if (t(a4) && t(b))
              for (d = Math.max(a4.length, b.length); d--; )
                c[d] = m(a4[d], b[d]);
            return c;
          }
          function l(a4, b, c, f2, e2) {
            const d = this.chart, k = d.inverted, l2 = this.xAxis, g3 = l2.reversed, h2 = k ? b.height / 2 : b.width / 2;
            a4 = (a4 = a4.pointWidth) ? a4 / 2 : 0;
            b.startXPos = k ? e2.x : g3 ? -h2 - a4 : l2.width - h2 + a4;
            b.startYPos = k ? g3 ? this.yAxis.height - h2 + a4 : -h2 - a4 : e2.y;
            f2 ? "hidden" === b.visibility && (b.show(), b.attr({ opacity: 0 }).animate({ opacity: 1 })) : b.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, b.hide);
            d.hasRendered && (c && b.attr({ x: b.startXPos, y: b.startYPos }), b.placed = true);
          }
          const v = [];
          a3.compose = function(a4) {
            J.pushUnique(v, a4) && (a4 = a4.prototype, a4.initDataLabelsGroup = M, a4.initDataLabels = C, a4.alignDataLabel = e, a4.drawDataLabels = f, a4.justifyDataLabel = y, a4.setDataLabelStartPos = l);
          };
        })(g || (g = {}));
        "";
        return g;
      });
      L(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { series: u } = A, { merge: G, pick: D } = J;
        var E;
        (function(B) {
          function t(a3, p, n, h, g) {
            let e = this.chart.inverted;
            var m = a3.series;
            let q2 = (m.xAxis ? m.xAxis.len : this.chart.plotSizeX) || 0;
            m = (m.yAxis ? m.yAxis.len : this.chart.plotSizeY) || 0;
            var t2 = a3.dlBox || a3.shapeArgs;
            let C = D(a3.below, a3.plotY > D(this.translatedThreshold, m)), f = D(n.inside, !!this.options.stacking);
            t2 && (h = G(t2), 0 > h.y && (h.height += h.y, h.y = 0), t2 = h.y + h.height - m, 0 < t2 && t2 < h.height && (h.height -= t2), e && (h = { x: m - h.y - h.height, y: q2 - h.x - h.width, width: h.height, height: h.width }), f || (e ? (h.x += C ? 0 : h.width, h.width = 0) : (h.y += C ? h.height : 0, h.height = 0)));
            n.align = D(n.align, !e || f ? "center" : C ? "right" : "left");
            n.verticalAlign = D(n.verticalAlign, e || f ? "middle" : C ? "top" : "bottom");
            u.prototype.alignDataLabel.call(this, a3, p, n, h, g);
            n.inside && a3.contrastColor && p.css({ color: a3.contrastColor });
          }
          const q = [];
          B.compose = function(m) {
            a2.compose(u);
            J.pushUnique(q, m) && (m.prototype.alignDataLabel = t);
          };
        })(E || (E = {}));
        return E;
      });
      L(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { extend: u, merge: G } = J;
        class D extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
        }
        D.defaultOptions = G(a2.defaultOptions, {});
        u(D.prototype, { inverted: true });
        A.registerSeriesType("bar", D);
        "";
        return D;
      });
      L(a, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
        "";
        return { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">‚óè</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } };
      });
      L(
        a,
        "Series/Scatter/ScatterSeries.js",
        [a["Series/Scatter/ScatterSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, A, J) {
          const { column: u, line: G } = A.seriesTypes, { addEvent: D, extend: E, merge: B } = J;
          class t extends G {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = void 0;
            }
            applyJitter() {
              const a3 = this, m = this.options.jitter, p = this.points.length;
              m && this.points.forEach(function(n, h) {
                ["x", "y"].forEach(function(g, e) {
                  let q = "plot" + g.toUpperCase(), t2, u2;
                  if (m[g] && !n.isNull) {
                    var C = a3[g + "Axis"];
                    u2 = m[g] * C.transA;
                    C && !C.isLog && (t2 = Math.max(0, n[q] - u2), C = Math.min(C.len, n[q] + u2), e = 1e4 * Math.sin(h + e * p), e -= Math.floor(e), n[q] = t2 + (C - t2) * e, "x" === g && (n.clientX = n.plotX));
                  }
                });
              });
            }
            drawGraph() {
              this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
            }
          }
          t.defaultOptions = B(G.defaultOptions, a2);
          E(t.prototype, { drawTracker: u.prototype.drawTracker, sorted: false, requireSorting: false, noSharedTooltip: true, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: false });
          D(t, "afterTranslate", function() {
            this.applyJitter();
          });
          A.registerSeriesType("scatter", t);
          return t;
        }
      );
      L(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { deg2rad: u } = a2, { fireEvent: G, isNumber: D, pick: E, relativeLength: B } = J;
        var t;
        (function(a3) {
          a3.getCenter = function() {
            var a4 = this.options, p = this.chart;
            const n = 2 * (a4.slicedOffset || 0), h = p.plotWidth - 2 * n, g = p.plotHeight - 2 * n;
            var e = a4.center;
            const q = Math.min(h, g), t2 = a4.thickness;
            var u2 = a4.size;
            let C = a4.innerSize || 0;
            "string" === typeof u2 && (u2 = parseFloat(u2));
            "string" === typeof C && (C = parseFloat(C));
            a4 = [E(e[0], "50%"), E(e[1], "50%"), E(u2 && 0 > u2 ? void 0 : a4.size, "100%"), E(C && 0 > C ? void 0 : a4.innerSize || 0, "0%")];
            !p.angular || this instanceof A || (a4[3] = 0);
            for (e = 0; 4 > e; ++e)
              u2 = a4[e], p = 2 > e || 2 === e && /%$/.test(u2), a4[e] = B(u2, [h, g, q, a4[2]][e]) + (p ? n : 0);
            a4[3] > a4[2] && (a4[3] = a4[2]);
            D(t2) && 2 * t2 < a4[2] && 0 < t2 && (a4[3] = a4[2] - 2 * t2);
            G(this, "afterGetCenter", { positions: a4 });
            return a4;
          };
          a3.getStartAndEndRadians = function(a4, p) {
            a4 = D(a4) ? a4 : 0;
            p = D(p) && p > a4 && 360 > p - a4 ? p : a4 + 360;
            return { start: u * (a4 + -90), end: u * (p + -90) };
          };
        })(t || (t = {}));
        "";
        return t;
      });
      L(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { setAnimation: u } = a2, { addEvent: G, defined: D, extend: E, isNumber: B, pick: t, relativeLength: q } = J;
        class m extends A {
          constructor() {
            super(...arguments);
            this.series = this.options = this.labelDistance = void 0;
          }
          getConnectorPath() {
            const a3 = this.labelPosition, n = this.series.options.dataLabels, h = this.connectorShapes;
            let g = n.connectorShape;
            h[g] && (g = h[g]);
            return g.call(
              this,
              { x: a3.computed.x, y: a3.computed.y, alignment: a3.alignment },
              a3.connectorPosition,
              n
            );
          }
          getTranslate() {
            return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
          }
          haloPath(a3) {
            const n = this.shapeArgs;
            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(n.x, n.y, n.r + a3, n.r + a3, { innerR: n.r - 1, start: n.start, end: n.end, borderRadius: n.borderRadius });
          }
          init() {
            super.init.apply(this, arguments);
            this.name = t(this.name, "Slice");
            const a3 = (a4) => {
              this.slice("select" === a4.type);
            };
            G(this, "select", a3);
            G(
              this,
              "unselect",
              a3
            );
            return this;
          }
          isValid() {
            return B(this.y) && 0 <= this.y;
          }
          setVisible(a3, n) {
            const h = this.series, g = h.chart, e = h.options.ignoreHiddenPoint;
            n = t(n, e);
            a3 !== this.visible && (this.visible = this.options.visible = a3 = "undefined" === typeof a3 ? !this.visible : a3, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector"].forEach((e2) => {
              if (this[e2])
                this[e2][a3 ? "show" : "hide"](a3);
            }), this.legendItem && g.legend.colorizeItem(this, a3), a3 || "hover" !== this.state || this.setState(""), e && (h.isDirty = true), n && g.redraw());
          }
          slice(a3, n, h) {
            const g = this.series;
            u(h, g.chart);
            t(n, true);
            this.sliced = this.options.sliced = D(a3) ? a3 : !this.sliced;
            g.options.data[g.data.indexOf(this)] = this.options;
            this.graphic && this.graphic.animate(this.getTranslate());
          }
        }
        E(m.prototype, { connectorShapes: { fixedOffset: function(a3, n, h) {
          const g = n.breakAt;
          n = n.touchingSliceAt;
          return [["M", a3.x, a3.y], h.softConnector ? ["C", a3.x + ("left" === a3.alignment ? -5 : 5), a3.y, 2 * g.x - n.x, 2 * g.y - n.y, g.x, g.y] : ["L", g.x, g.y], ["L", n.x, n.y]];
        }, straight: function(a3, n) {
          n = n.touchingSliceAt;
          return [
            ["M", a3.x, a3.y],
            ["L", n.x, n.y]
          ];
        }, crookedLine: function(a3, n, h) {
          const { breakAt: g, touchingSliceAt: e } = n;
          ({ series: n } = this);
          const [m2, p, t2] = n.center, u2 = t2 / 2, f = n.chart.plotWidth, y = n.chart.plotLeft;
          n = "left" === a3.alignment;
          const { x: r, y: l } = a3;
          h.crookDistance ? (a3 = q(h.crookDistance, 1), a3 = n ? m2 + u2 + (f + y - m2 - u2) * (1 - a3) : y + (m2 - u2) * a3) : a3 = m2 + (p - l) * Math.tan((this.angle || 0) - Math.PI / 2);
          h = [["M", r, l]];
          (n ? a3 <= r && a3 >= g.x : a3 >= r && a3 <= g.x) && h.push(["L", a3, l]);
          h.push(["L", g.x, g.y], ["L", e.x, e.y]);
          return h;
        } } });
        return m;
      });
      L(a, "Series/Pie/PieSeriesDefaults.js", [], function() {
        "";
        return {
          borderRadius: 3,
          center: [null, null],
          clip: false,
          colorByPoint: true,
          dataLabels: { allowOverlap: true, connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: true, formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          }, softConnector: true, x: 0 },
          fillColor: void 0,
          ignoreHiddenPoint: true,
          inactiveOtherPoints: true,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: false,
          slicedOffset: 10,
          stickyTracking: false,
          tooltip: { followPointer: true },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } }
        };
      });
      L(a, "Series/Pie/PieSeries.js", [a["Series/CenteredUtilities.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Series/Pie/PiePoint.js"], a["Series/Pie/PieSeriesDefaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D, E, B, t) {
        const { getStartAndEndRadians: q } = a2;
        ({ noop: J } = J);
        const { clamp: m, extend: p, fireEvent: n, merge: h, pick: g, relativeLength: e } = t;
        class x extends D {
          constructor() {
            super(...arguments);
            this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;
          }
          animate(a3) {
            const e2 = this, h2 = e2.points, f = e2.startAngleRad;
            a3 || h2.forEach(function(a4) {
              const h3 = a4.graphic, l = a4.shapeArgs;
              h3 && l && (h3.attr({ r: g(a4.startR, e2.center && e2.center[3] / 2), start: f, end: f }), h3.animate({ r: l.r, start: l.start, end: l.end }, e2.options.animation));
            });
          }
          drawEmpty() {
            const a3 = this.startAngleRad, e2 = this.endAngleRad, g2 = this.options;
            let f, h2;
            0 === this.total && this.center ? (f = this.center[0], h2 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(
              f,
              h2,
              this.center[1] / 2,
              0,
              a3,
              e2
            ).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: B.arc(f, h2, this.center[2] / 2, 0, { start: a3, end: e2, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": g2.borderWidth, fill: g2.fillColor || "none", stroke: g2.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy());
          }
          drawPoints() {
            const a3 = this.chart.renderer;
            this.points.forEach(function(e2) {
              e2.graphic && e2.hasNewShapeType() && (e2.graphic = e2.graphic.destroy());
              e2.graphic || (e2.graphic = a3[e2.shapeType](e2.shapeArgs).add(e2.series.group), e2.delayedRendering = true);
            });
          }
          generatePoints() {
            super.generatePoints();
            this.updateTotals();
          }
          getX(a3, e2, g2) {
            const f = this.center, h2 = this.radii ? this.radii[g2.index] || 0 : f[2] / 2;
            a3 = Math.asin(m((a3 - f[1]) / (h2 + g2.labelDistance), -1, 1));
            return f[0] + (e2 ? -1 : 1) * Math.cos(a3) * (h2 + g2.labelDistance) + (0 < g2.labelDistance ? (e2 ? -1 : 1) * this.options.dataLabels.padding : 0);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          redrawPoints() {
            const a3 = this, e2 = a3.chart;
            let g2, f, n2, m2;
            this.drawEmpty();
            a3.group && !e2.styledMode && a3.group.shadow(a3.options.shadow);
            a3.points.forEach(function(l) {
              const r = {};
              f = l.graphic;
              !l.isNull && f ? (m2 = l.shapeArgs, g2 = l.getTranslate(), e2.styledMode || (n2 = a3.pointAttribs(l, l.selected && "select")), l.delayedRendering ? (f.setRadialReference(a3.center).attr(m2).attr(g2), e2.styledMode || f.attr(n2).attr({ "stroke-linejoin": "round" }), l.delayedRendering = false) : (f.setRadialReference(a3.center), e2.styledMode || h(true, r, n2), h(true, r, m2, g2), f.animate(r)), f.attr({ visibility: l.visible ? "inherit" : "hidden" }), f.addClass(l.getClassName(), true)) : f && (l.graphic = f.destroy());
            });
          }
          sortByAngle(a3, e2) {
            a3.sort(function(a4, f) {
              return "undefined" !== typeof a4.angle && (f.angle - a4.angle) * e2;
            });
          }
          translate(a3) {
            n(this, "translate");
            this.generatePoints();
            var h2 = this.options;
            const m2 = h2.slicedOffset, f = m2 + (h2.borderWidth || 0);
            var p2 = q(h2.startAngle, h2.endAngle);
            const r = this.startAngleRad = p2.start;
            p2 = (this.endAngleRad = p2.end) - r;
            const l = this.points, v = h2.dataLabels.distance;
            h2 = h2.ignoreHiddenPoint;
            const d = l.length;
            let b, c, k, w = 0;
            a3 || (this.center = a3 = this.getCenter());
            for (c = 0; c < d; c++) {
              k = l[c];
              var z = r + w * p2;
              !k.isValid() || h2 && !k.visible || (w += k.percentage / 100);
              var F = r + w * p2;
              var x2 = {
                x: a3[0],
                y: a3[1],
                r: a3[2] / 2,
                innerR: a3[3] / 2,
                start: Math.round(1e3 * z) / 1e3,
                end: Math.round(1e3 * F) / 1e3
              };
              k.shapeType = "arc";
              k.shapeArgs = x2;
              k.labelDistance = g(k.options.dataLabels && k.options.dataLabels.distance, v);
              k.labelDistance = e(k.labelDistance, x2.r);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, k.labelDistance);
              F = (F + z) / 2;
              F > 1.5 * Math.PI ? F -= 2 * Math.PI : F < -Math.PI / 2 && (F += 2 * Math.PI);
              k.slicedTranslation = { translateX: Math.round(Math.cos(F) * m2), translateY: Math.round(Math.sin(F) * m2) };
              x2 = Math.cos(F) * a3[2] / 2;
              b = Math.sin(F) * a3[2] / 2;
              k.tooltipPos = [a3[0] + 0.7 * x2, a3[1] + 0.7 * b];
              k.half = F < -Math.PI / 2 || F > Math.PI / 2 ? 1 : 0;
              k.angle = F;
              z = Math.min(f, k.labelDistance / 5);
              k.labelPosition = { natural: { x: a3[0] + x2 + Math.cos(F) * k.labelDistance, y: a3[1] + b + Math.sin(F) * k.labelDistance }, computed: {}, alignment: 0 > k.labelDistance ? "center" : k.half ? "right" : "left", connectorPosition: { breakAt: { x: a3[0] + x2 + Math.cos(F) * z, y: a3[1] + b + Math.sin(F) * z }, touchingSliceAt: { x: a3[0] + x2, y: a3[1] + b } } };
            }
            n(this, "afterTranslate");
          }
          updateTotals() {
            const a3 = this.points, e2 = a3.length, g2 = this.options.ignoreHiddenPoint;
            let f, h2, n2 = 0;
            for (f = 0; f < e2; f++)
              h2 = a3[f], !h2.isValid() || g2 && !h2.visible || (n2 += h2.y);
            this.total = n2;
            for (f = 0; f < e2; f++)
              h2 = a3[f], h2.percentage = 0 < n2 && (h2.visible || !g2) ? h2.y / n2 * 100 : 0, h2.total = n2;
          }
        }
        x.defaultOptions = h(D.defaultOptions, G);
        p(x.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawTracker: A.prototype.drawTracker, getCenter: a2.getCenter, getSymbol: J, isCartesian: false, noSharedTooltip: true, pointAttribs: A.prototype.pointAttribs, pointClass: K, requireSorting: false, searchPoint: J, trackerGroups: ["group", "dataLabelsGroup"] });
        E.registerSeriesType(
          "pie",
          x
        );
        return x;
      });
      L(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G) {
        const { noop: u } = A, { distribute: E } = J, { series: B } = K, { arrayMax: t, clamp: q, defined: m, merge: p, pick: n, relativeLength: h } = G;
        var g;
        (function(e) {
          function g2() {
            const a3 = this, f2 = a3.data, e2 = a3.chart, g3 = a3.options.dataLabels || {}, d = g3.connectorPadding, b = e2.plotWidth, c = e2.plotHeight, k = e2.plotLeft, h2 = Math.round(e2.chartWidth / 3), z = a3.center, q2 = z[2] / 2, x = z[1], u2 = [[], []], C2 = [0, 0, 0, 0], I2 = a3.dataLabelPositioners;
            let A3, H, G2, M, D, J2, K2, L2, Q, R, V, S2;
            a3.visible && (g3.enabled || a3._hasPointLabels) && (f2.forEach(function(b2) {
              b2.dataLabel && b2.visible && b2.dataLabel.shortened && (b2.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), b2.dataLabel.shortened = false);
            }), B.prototype.drawDataLabels.apply(a3), f2.forEach(function(b2) {
              b2.dataLabel && (b2.visible ? (u2[b2.half].push(b2), b2.dataLabel._pos = null, !m(g3.style.width) && !m(b2.options.dataLabels && b2.options.dataLabels.style && b2.options.dataLabels.style.width) && b2.dataLabel.getBBox().width > h2 && (b2.dataLabel.css({ width: Math.round(0.7 * h2) + "px" }), b2.dataLabel.shortened = true)) : (b2.dataLabel = b2.dataLabel.destroy(), b2.dataLabels && 1 === b2.dataLabels.length && delete b2.dataLabels));
            }), u2.forEach((f3, l) => {
              const h3 = f3.length, w = [];
              let r, v = 0;
              if (h3) {
                a3.sortByAngle(f3, l - 0.5);
                if (0 < a3.maxLabelDistance) {
                  var p2 = Math.max(0, x - q2 - a3.maxLabelDistance);
                  r = Math.min(x + q2 + a3.maxLabelDistance, e2.plotHeight);
                  f3.forEach(function(b2) {
                    0 < b2.labelDistance && b2.dataLabel && (b2.top = Math.max(
                      0,
                      x - q2 - b2.labelDistance
                    ), b2.bottom = Math.min(x + q2 + b2.labelDistance, e2.plotHeight), v = b2.dataLabel.getBBox().height || 21, b2.distributeBox = { target: b2.labelPosition.natural.y - b2.top + v / 2, size: v, rank: b2.y }, w.push(b2.distributeBox));
                  });
                  p2 = r + v - p2;
                  E(w, p2, p2 / 5);
                }
                for (V = 0; V < h3; V++) {
                  A3 = f3[V];
                  J2 = A3.labelPosition;
                  M = A3.dataLabel;
                  R = false === A3.visible ? "hidden" : "inherit";
                  Q = p2 = J2.natural.y;
                  w && m(A3.distributeBox) && ("undefined" === typeof A3.distributeBox.pos ? R = "hidden" : (K2 = A3.distributeBox.size, Q = I2.radialDistributionY(A3)));
                  delete A3.positionIndex;
                  if (g3.justify)
                    L2 = I2.justify(A3, q2, z);
                  else
                    switch (g3.alignTo) {
                      case "connectors":
                        L2 = I2.alignToConnectors(f3, l, b, k);
                        break;
                      case "plotEdges":
                        L2 = I2.alignToPlotEdges(M, l, b, k);
                        break;
                      default:
                        L2 = I2.radialDistributionX(a3, A3, Q, p2);
                    }
                  M._attr = { visibility: R, align: J2.alignment };
                  S2 = A3.options.dataLabels || {};
                  M._pos = { x: L2 + n(S2.x, g3.x) + ({ left: d, right: -d }[J2.alignment] || 0), y: Q + n(S2.y, g3.y) - M.getBBox().height / 2 };
                  J2 && (J2.computed.x = L2, J2.computed.y = Q);
                  n(g3.crop, true) && (D = M.getBBox().width, p2 = null, L2 - D < d && 1 === l ? (p2 = Math.round(D - L2 + d), C2[3] = Math.max(p2, C2[3])) : L2 + D > b - d && 0 === l && (p2 = Math.round(L2 + D - b + d), C2[1] = Math.max(p2, C2[1])), 0 > Q - K2 / 2 ? C2[0] = Math.max(Math.round(-Q + K2 / 2), C2[0]) : Q + K2 / 2 > c && (C2[2] = Math.max(Math.round(Q + K2 / 2 - c), C2[2])), M.sideOverflow = p2);
                }
              }
            }), 0 === t(C2) || this.verifyDataLabelOverflow(C2)) && (this.placeDataLabels(), this.points.forEach(function(b2) {
              S2 = p(g3, b2.options.dataLabels);
              if (H = n(S2.connectorWidth, 1)) {
                let c2;
                G2 = b2.connector;
                if ((M = b2.dataLabel) && M._pos && b2.visible && 0 < b2.labelDistance) {
                  R = M._attr.visibility;
                  if (c2 = !G2)
                    b2.connector = G2 = e2.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b2.colorIndex + (b2.className ? " " + b2.className : "")).add(a3.dataLabelsGroup), e2.styledMode || G2.attr({ "stroke-width": H, stroke: S2.connectorColor || b2.color || "#666666" });
                  G2[c2 ? "attr" : "animate"]({ d: b2.getConnectorPath() });
                  G2.attr("visibility", R);
                } else
                  G2 && (b2.connector = G2.destroy());
              }
            }));
          }
          function I() {
            this.points.forEach(function(a3) {
              let f2 = a3.dataLabel, e2;
              f2 && a3.visible && ((e2 = f2._pos) ? (f2.sideOverflow && (f2._attr.width = Math.max(f2.getBBox().width - f2.sideOverflow, 0), f2.css({ width: f2._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), f2.shortened = true), f2.attr(f2._attr), f2[f2.moved ? "animate" : "attr"](e2), f2.moved = true) : f2 && f2.attr({ y: -9999 }));
              delete a3.distributeBox;
            }, this);
          }
          function A2(a3) {
            let f2 = this.center, e2 = this.options, g3 = e2.center, d = e2.minSize || 80, b, c = null !== e2.size;
            c || (null !== g3[0] ? b = Math.max(f2[2] - Math.max(a3[1], a3[3]), d) : (b = Math.max(f2[2] - a3[1] - a3[3], d), f2[0] += (a3[3] - a3[1]) / 2), null !== g3[1] ? b = q(b, d, f2[2] - Math.max(a3[0], a3[2])) : (b = q(b, d, f2[2] - a3[0] - a3[2]), f2[1] += (a3[0] - a3[2]) / 2), b < f2[2] ? (f2[2] = b, f2[3] = Math.min(e2.thickness ? Math.max(0, b - 2 * e2.thickness) : Math.max(0, h(e2.innerSize || 0, b)), b), this.translate(f2), this.drawDataLabels && this.drawDataLabels()) : c = true);
            return c;
          }
          const C = [], f = { radialDistributionY: function(a3) {
            return a3.top + a3.distributeBox.pos;
          }, radialDistributionX: function(a3, f2, e2, g3) {
            return a3.getX(e2 < f2.top + 2 || e2 > f2.bottom - 2 ? g3 : e2, f2.half, f2);
          }, justify: function(a3, f2, e2) {
            return e2[0] + (a3.half ? -1 : 1) * (f2 + a3.labelDistance);
          }, alignToPlotEdges: function(a3, f2, e2, g3) {
            a3 = a3.getBBox().width;
            return f2 ? a3 + g3 : e2 - a3 - g3;
          }, alignToConnectors: function(a3, f2, e2, g3) {
            let d = 0, b;
            a3.forEach(function(a4) {
              b = a4.dataLabel.getBBox().width;
              b > d && (d = b);
            });
            return f2 ? d + g3 : e2 - d - g3;
          } };
          e.compose = function(e2) {
            a2.compose(B);
            G.pushUnique(C, e2) && (e2 = e2.prototype, e2.dataLabelPositioners = f, e2.alignDataLabel = u, e2.drawDataLabels = g2, e2.placeDataLabels = I, e2.verifyDataLabelOverflow = A2);
          };
        })(g || (g = {}));
        return g;
      });
      L(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function(a2, A) {
        function u(a3, m) {
          let p, n = false;
          a3 && (p = a3.newOpacity, a3.oldOpacity !== p && (a3.alignAttr && a3.placed ? (a3[p ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), n = true, a3.alignAttr.opacity = p, a3[a3.isOld ? "animate" : "attr"](a3.alignAttr, null, function() {
            m.styledMode || a3.css({ pointerEvents: p ? "auto" : "none" });
          }), G(m, "afterHideOverlappingLabel")) : a3.attr({ opacity: p })), a3.isOld = true);
          return n;
        }
        const { addEvent: K, fireEvent: G, isArray: D, isNumber: E, objectEach: B, pick: t } = A;
        K(a2, "render", function() {
          let a3 = this, m = [];
          (this.labelCollectors || []).forEach(function(a4) {
            m = m.concat(a4());
          });
          (this.yAxis || []).forEach(function(a4) {
            a4.stacking && a4.options.stackLabels && !a4.options.stackLabels.allowOverlap && B(a4.stacking.stacks, function(a5) {
              B(a5, function(a6) {
                a6.label && m.push(a6.label);
              });
            });
          });
          (this.series || []).forEach(function(q) {
            var n = q.options.dataLabels;
            q.visible && (false !== n.enabled || q._hasPointLabels) && (n = (h) => h.forEach((g) => {
              g.visible && (D(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function(e) {
                const h2 = e.options;
                e.labelrank = t(h2.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);
                h2.allowOverlap ? (e.oldOpacity = e.opacity, e.newOpacity = 1, u(e, a3)) : m.push(e);
              });
            }), n(q.nodes || []), n(q.points));
          });
          this.hideOverlappingLabels(m);
        });
        a2.prototype.hideOverlappingLabels = function(a3) {
          let m = this, q = a3.length, n = m.renderer;
          var h;
          let g;
          let e, x, t2, A2 = false;
          var C = function(a4) {
            let f, e2;
            var g2;
            let h2 = a4.box ? 0 : a4.padding || 0, d = g2 = 0, b, c;
            if (a4 && (!a4.alignAttr || a4.placed))
              return f = a4.alignAttr || { x: a4.attr("x"), y: a4.attr("y") }, e2 = a4.parentGroup, a4.width || (g2 = a4.getBBox(), a4.width = g2.width, a4.height = g2.height, g2 = n.fontMetrics(a4.element).h), b = a4.width - 2 * h2, (c = { left: "0", center: "0.5", right: "1" }[a4.alignValue]) ? d = +c * b : E(a4.x) && Math.round(a4.x) !== a4.translateX && (d = a4.x - a4.translateX), { x: f.x + (e2.translateX || 0) + h2 - (d || 0), y: f.y + (e2.translateY || 0) + h2 - g2, width: a4.width - 2 * h2, height: a4.height - 2 * h2 };
          };
          for (g = 0; g < q; g++)
            if (h = a3[g])
              h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = C(h);
          a3.sort(function(a4, e2) {
            return (e2.labelrank || 0) - (a4.labelrank || 0);
          });
          for (g = 0; g < q; g++)
            for (x = (C = a3[g]) && C.absoluteBox, h = g + 1; h < q; ++h)
              t2 = (e = a3[h]) && e.absoluteBox, !x || !t2 || C === e || 0 === C.newOpacity || 0 === e.newOpacity || "hidden" === C.visibility || "hidden" === e.visibility || t2.x >= x.x + x.width || t2.x + t2.width <= x.x || t2.y >= x.y + x.height || t2.y + t2.height <= x.y || ((C.labelrank < e.labelrank ? C : e).newOpacity = 0);
          a3.forEach(function(a4) {
            u(a4, m) && (A2 = true);
          });
          A2 && G(m, "afterHideAllOverlappingLabels");
        };
      });
      L(a, "Extensions/BorderRadius.js", [a["Core/Defaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D) {
        const { defaultOptions: u } = a2;
        ({ seriesTypes: a2 } = J);
        const { addEvent: B, extend: t, isObject: q, merge: m, relativeLength: p } = D, n = {
          radius: 0,
          scope: "stack",
          where: void 0
        }, h = (a3, e) => {
          q(a3) || (a3 = { radius: a3 || 0 });
          return m(n, e, a3);
        };
        if (-1 === K.symbolCustomAttribs.indexOf("borderRadius")) {
          K.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
          const g = G.prototype.symbols.arc;
          G.prototype.symbols.arc = function(a3, e2, h2, n2, f = {}) {
            a3 = g(a3, e2, h2, n2, f);
            const { innerR: m2 = 0, r = h2, start: l = 0, end: v = 0 } = f;
            if (f.open || !f.borderRadius)
              return a3;
            h2 = v - l;
            e2 = Math.sin(h2 / 2);
            f = Math.max(Math.min(p(f.borderRadius || 0, r - m2), (r - m2) / 2, r * e2 / (1 + e2)), 0);
            h2 = Math.min(f, h2 / Math.PI * 2 * m2);
            for (e2 = a3.length - 1; e2--; ) {
              {
                let g2 = void 0, l2 = void 0, m3 = void 0;
                n2 = a3;
                var d = e2, b = 1 < e2 ? h2 : f, c = n2[d], k = n2[d + 1];
                "Z" === k[0] && (k = n2[0]);
                "M" !== c[0] && "L" !== c[0] || "A" !== k[0] ? "A" !== c[0] || "M" !== k[0] && "L" !== k[0] || (m3 = k, l2 = c) : (m3 = c, l2 = k, g2 = true);
                if (m3 && l2 && l2.params) {
                  c = l2[1];
                  var w = l2[5];
                  k = l2.params;
                  const { start: a4, end: f2, cx: e3, cy: h3 } = k;
                  var z = w ? c - b : c + b;
                  const r2 = z ? Math.asin(b / z) : 0;
                  w = w ? r2 : -r2;
                  z *= Math.cos(r2);
                  g2 ? (k.start = a4 + w, m3[1] = e3 + z * Math.cos(a4), m3[2] = h3 + z * Math.sin(a4), n2.splice(d + 1, 0, ["A", b, b, 0, 0, 1, e3 + c * Math.cos(k.start), h3 + c * Math.sin(k.start)])) : (k.end = f2 - w, l2[6] = e3 + c * Math.cos(k.end), l2[7] = h3 + c * Math.sin(k.end), n2.splice(d + 1, 0, ["A", b, b, 0, 0, 1, e3 + z * Math.cos(f2), h3 + z * Math.sin(f2)]));
                  l2[4] = Math.abs(k.end - k.start) < Math.PI ? 0 : 1;
                }
              }
            }
            return a3;
          };
          const e = G.prototype.symbols.roundedRect;
          G.prototype.symbols.roundedRect = function(a3, g2, h2, n2, f = {}) {
            const m2 = e(a3, g2, h2, n2, f), { r = 0, brBoxHeight: l = n2, brBoxY: v = g2 } = f;
            var d = g2 - v, b = v + l - (g2 + n2);
            f = -0.1 < d - r ? 0 : r;
            const c = -0.1 < b - r ? 0 : r;
            var k = Math.max(f && d, 0);
            const w = Math.max(c && b, 0);
            b = [a3 + f, g2];
            d = [a3 + h2 - f, g2];
            const z = [a3 + h2, g2 + f], q2 = [a3 + h2, g2 + n2 - c], p2 = [a3 + h2 - c, g2 + n2], x = [a3 + c, g2 + n2], t2 = [a3, g2 + n2 - c], u2 = [a3, g2 + f];
            if (k) {
              const a4 = Math.sqrt(Math.pow(f, 2) - Math.pow(f - k, 2));
              b[0] -= a4;
              d[0] += a4;
              z[1] = u2[1] = g2 + f - k;
            }
            n2 < f - k && (k = Math.sqrt(Math.pow(f, 2) - Math.pow(f - k - n2, 2)), z[0] = q2[0] = a3 + h2 - f + k, p2[0] = Math.min(z[0], p2[0]), x[0] = Math.max(q2[0], x[0]), t2[0] = u2[0] = a3 + f - k, z[1] = u2[1] = g2 + n2);
            w && (k = Math.sqrt(Math.pow(c, 2) - Math.pow(c - w, 2)), p2[0] += k, x[0] -= k, q2[1] = t2[1] = g2 + n2 - c + w);
            n2 < c - w && (n2 = Math.sqrt(Math.pow(c, 2) - Math.pow(c - w - n2, 2)), z[0] = q2[0] = a3 + h2 - c + n2, d[0] = Math.min(z[0], d[0]), b[0] = Math.max(q2[0], b[0]), t2[0] = u2[0] = a3 + c - n2, q2[1] = t2[1] = g2);
            m2.length = 0;
            m2.push(["M", ...b], ["L", ...d], [
              "A",
              f,
              f,
              0,
              0,
              1,
              ...z
            ], ["L", ...q2], ["A", c, c, 0, 0, 1, ...p2], ["L", ...x], ["A", c, c, 0, 0, 1, ...t2], ["L", ...u2], ["A", f, f, 0, 0, 1, ...b], ["Z"]);
            return m2;
          };
          B(a2.pie, "afterTranslate", function() {
            const a3 = h(this.options.borderRadius);
            for (const e2 of this.points) {
              const g2 = e2.shapeArgs;
              g2 && (g2.borderRadius = p(a3.radius, (g2.r || 0) - (g2.innerR || 0)));
            }
          });
          B(A, "afterColumnTranslate", function() {
            var a3, e2;
            if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {
              const { options: m2, yAxis: r } = this, l = "percent" === m2.stacking;
              var g2 = null === (e2 = null === (a3 = u.plotOptions) || void 0 === a3 ? void 0 : a3[this.type]) || void 0 === e2 ? void 0 : e2.borderRadius;
              a3 = h(m2.borderRadius, q(g2) ? g2 : {});
              e2 = r.options.reversed;
              for (const h2 of this.points)
                if ({ shapeArgs: g2 } = h2, "roundedRect" === h2.shapeType && g2) {
                  const { width: d = 0, height: b = 0, y: c = 0 } = g2;
                  var n2 = c, f = b;
                  "stack" === a3.scope && h2.stackTotal && (n2 = r.translate(l ? 100 : h2.stackTotal, false, true, false, true), f = r.translate(m2.threshold || 0, false, true, false, true), f = this.crispCol(0, Math.min(n2, f), 0, Math.abs(n2 - f)), n2 = f.y, f = f.height);
                  const k = -1 === (h2.negative ? -1 : 1) * (e2 ? -1 : 1);
                  let w = a3.where;
                  !w && this.is("waterfall") && Math.abs((h2.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (w = "all");
                  w || (w = "end");
                  const v = Math.min(p(a3.radius, d), d / 2, "all" === w ? b / 2 : Infinity) || 0;
                  "end" === w && (k && (n2 -= v), f += v);
                  t(g2, { brBoxHeight: f, brBoxY: n2, r: v });
                }
            }
          }, { order: 9 });
        }
        A = { optionsToObject: h };
        "";
        return A;
      });
      L(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function(a2) {
        const { diffObjects: u, extend: J, find: K, merge: G, pick: D, uniqueKey: E } = a2;
        var B;
        (function(t) {
          function q(a3, h) {
            const g = a3.condition;
            (g.callback || function() {
              return this.chartWidth <= D(g.maxWidth, Number.MAX_VALUE) && this.chartHeight <= D(g.maxHeight, Number.MAX_VALUE) && this.chartWidth >= D(g.minWidth, 0) && this.chartHeight >= D(g.minHeight, 0);
            }).call(this) && h.push(a3._id);
          }
          function m(a3, h) {
            const g = this.options.responsive;
            var e = this.currentResponsive;
            let n = [];
            !h && g && g.rules && g.rules.forEach((a4) => {
              "undefined" === typeof a4._id && (a4._id = E());
              this.matchResponsiveRule(a4, n);
            }, this);
            h = G(...n.map((a4) => K((g || {}).rules || [], (e2) => e2._id === a4)).map((a4) => a4 && a4.chartOptions));
            h.isResponsiveOptions = true;
            n = n.toString() || void 0;
            n !== (e && e.ruleIds) && (e && this.update(e.undoOptions, a3, true), n ? (e = u(h, this.options, true, this.collectionsWithUpdate), e.isResponsiveOptions = true, this.currentResponsive = { ruleIds: n, mergedOptions: h, undoOptions: e }, this.update(h, a3, true)) : this.currentResponsive = void 0);
          }
          const p = [];
          t.compose = function(n) {
            a2.pushUnique(p, n) && J(n.prototype, { matchResponsiveRule: q, setResponsive: m });
            return n;
          };
        })(B || (B = {}));
        "";
        "";
        return B;
      });
      L(a, "masters/highcharts.src.js", [
        a["Core/Globals.js"],
        a["Core/Utilities.js"],
        a["Core/Defaults.js"],
        a["Core/Animation/Fx.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Templating.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Renderer/HTML/HTMLElement.js"],
        a["Core/Renderer/HTML/HTMLRenderer.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Axis/DateTimeAxis.js"],
        a["Core/Axis/LogarithmicAxis.js"],
        a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
        a["Core/Axis/Tick.js"],
        a["Core/Tooltip.js"],
        a["Core/Series/Point.js"],
        a["Core/Pointer.js"],
        a["Core/Legend/Legend.js"],
        a["Core/Chart/Chart.js"],
        a["Core/Axis/Stacking/StackingAxis.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Series/Column/ColumnDataLabel.js"],
        a["Series/Pie/PieSeries.js"],
        a["Series/Pie/PieDataLabel.js"],
        a["Core/Series/DataLabel.js"],
        a["Core/Responsive.js"],
        a["Core/Color/Color.js"],
        a["Core/Time.js"]
      ], function(a2, A, J, K, G, D, E, B, t, q, m, p, n, h, g, e, x, I, M, C, f, y, r, l, v, d, b, c, k, w, z, F, O, P) {
        a2.animate = G.animate;
        a2.animObject = G.animObject;
        a2.getDeferredAnimation = G.getDeferredAnimation;
        a2.setAnimation = G.setAnimation;
        a2.stop = G.stop;
        a2.timers = K.timers;
        a2.AST = D;
        a2.Axis = n;
        a2.Chart = y;
        a2.chart = y.chart;
        a2.Fx = K;
        a2.Legend = f;
        a2.PlotLineOrBand = e;
        a2.Point = M;
        a2.Pointer = C;
        a2.Series = v;
        a2.StackItem = l;
        a2.SVGElement = t;
        a2.SVGRenderer = q;
        a2.Templating = E;
        a2.Tick = x;
        a2.Time = P;
        a2.Tooltip = I;
        a2.Color = O;
        a2.color = O.parse;
        p.compose(q);
        m.compose(t);
        C.compose(y);
        f.compose(y);
        a2.defaultOptions = J.defaultOptions;
        a2.getOptions = J.getOptions;
        a2.time = J.defaultTime;
        a2.setOptions = J.setOptions;
        a2.dateFormat = E.dateFormat;
        a2.format = E.format;
        a2.numberFormat = E.numberFormat;
        a2.addEvent = A.addEvent;
        a2.arrayMax = A.arrayMax;
        a2.arrayMin = A.arrayMin;
        a2.attr = A.attr;
        a2.clearTimeout = A.clearTimeout;
        a2.correctFloat = A.correctFloat;
        a2.createElement = A.createElement;
        a2.css = A.css;
        a2.defined = A.defined;
        a2.destroyObjectProperties = A.destroyObjectProperties;
        a2.discardElement = A.discardElement;
        a2.distribute = B.distribute;
        a2.erase = A.erase;
        a2.error = A.error;
        a2.extend = A.extend;
        a2.extendClass = A.extendClass;
        a2.find = A.find;
        a2.fireEvent = A.fireEvent;
        a2.getMagnitude = A.getMagnitude;
        a2.getStyle = A.getStyle;
        a2.inArray = A.inArray;
        a2.isArray = A.isArray;
        a2.isClass = A.isClass;
        a2.isDOMElement = A.isDOMElement;
        a2.isFunction = A.isFunction;
        a2.isNumber = A.isNumber;
        a2.isObject = A.isObject;
        a2.isString = A.isString;
        a2.keys = A.keys;
        a2.merge = A.merge;
        a2.normalizeTickInterval = A.normalizeTickInterval;
        a2.objectEach = A.objectEach;
        a2.offset = A.offset;
        a2.pad = A.pad;
        a2.pick = A.pick;
        a2.pInt = A.pInt;
        a2.relativeLength = A.relativeLength;
        a2.removeEvent = A.removeEvent;
        a2.seriesType = d.seriesType;
        a2.splat = A.splat;
        a2.stableSort = A.stableSort;
        a2.syncTimeout = A.syncTimeout;
        a2.timeUnits = A.timeUnits;
        a2.uniqueKey = A.uniqueKey;
        a2.useSerialIds = A.useSerialIds;
        a2.wrap = A.wrap;
        c.compose(b);
        z.compose(v);
        h.compose(n);
        g.compose(n);
        w.compose(k);
        e.compose(n);
        F.compose(y);
        r.compose(n, y, v);
        I.compose(C);
        return a2;
      });
      L(a, "Core/Axis/BrokenAxis.js", [a["Core/Axis/Stacking/StackItem.js"], a["Core/Utilities.js"]], function(a2, A) {
        const { addEvent: u, find: K, fireEvent: G, isArray: D, isNumber: E, pick: B } = A;
        var t;
        (function(q) {
          function m() {
            "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
          }
          function p() {
            this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = false);
          }
          function n() {
            const a3 = this.brokenAxis;
            if (a3 && a3.hasBreaks) {
              const f = this.tickPositions, e2 = this.tickPositions.info, g2 = [];
              for (let e3 = 0; e3 < f.length; e3++)
                a3.isInAnyBreak(f[e3]) || g2.push(f[e3]);
              this.tickPositions = g2;
              this.tickPositions.info = e2;
            }
          }
          function h() {
            this.brokenAxis || (this.brokenAxis = new C(this));
          }
          function g() {
            const {
              isDirty: a3,
              options: { connectNulls: e2 },
              points: g2,
              xAxis: l,
              yAxis: h2
            } = this;
            if (a3) {
              let a4 = g2.length;
              for (; a4--; ) {
                const b = g2[a4], c = !(null === b.y && false === e2) && (l && l.brokenAxis && l.brokenAxis.isInAnyBreak(b.x, true) || h2 && h2.brokenAxis && h2.brokenAxis.isInAnyBreak(b.y, true));
                b.visible = c ? false : false !== b.options.visible;
              }
            }
          }
          function e() {
            this.drawBreaks(this.xAxis, ["x"]);
            this.drawBreaks(this.yAxis, B(this.pointArrayMap, ["y"]));
          }
          function t2(a3, e2) {
            const f = this, g2 = f.points;
            let h2, d, b, c;
            if (a3 && a3.brokenAxis && a3.brokenAxis.hasBreaks) {
              const k = a3.brokenAxis;
              e2.forEach(function(e3) {
                h2 = k && k.breakArray || [];
                d = a3.isXAxis ? a3.min : B(f.options.threshold, a3.min);
                g2.forEach(function(f2) {
                  c = B(f2["stack" + e3.toUpperCase()], f2[e3]);
                  h2.forEach(function(e4) {
                    if (E(d) && E(c)) {
                      b = false;
                      if (d < e4.from && c > e4.to || d > e4.from && c < e4.from)
                        b = "pointBreak";
                      else if (d < e4.from && c > e4.from && c < e4.to || d > e4.from && c > e4.to && c < e4.from)
                        b = "pointInBreak";
                      b && G(a3, b, { point: f2, brk: e4 });
                    }
                  });
                });
              });
            }
          }
          function I() {
            var e2 = this.currentDataGrouping, g2 = e2 && e2.gapSize;
            e2 = this.points.slice();
            const h2 = this.yAxis;
            let l = this.options.gapSize, n2 = e2.length - 1;
            var d;
            if (l && 0 < n2)
              for ("value" !== this.options.gapUnit && (l *= this.basePointRange), g2 && g2 > l && g2 >= this.basePointRange && (l = g2); n2--; )
                d && false !== d.visible || (d = e2[n2 + 1]), g2 = e2[n2], false !== d.visible && false !== g2.visible && (d.x - g2.x > l && (d = (g2.x + d.x) / 2, e2.splice(n2 + 1, 0, { isNull: true, x: d }), h2.stacking && this.options.stacking && (d = h2.stacking.stacks[this.stackKey][d] = new a2(h2, h2.options.stackLabels, false, d, this.stack), d.total = 0)), d = g2);
            return this.getGraphPath(e2);
          }
          const M = [];
          q.compose = function(a3, q2) {
            A.pushUnique(M, a3) && (a3.keepProps.push("brokenAxis"), u(a3, "init", h), u(a3, "afterInit", m), u(
              a3,
              "afterSetTickPositions",
              n
            ), u(a3, "afterSetOptions", p));
            if (A.pushUnique(M, q2)) {
              const a4 = q2.prototype;
              a4.drawBreaks = t2;
              a4.gappedPath = I;
              u(q2, "afterGeneratePoints", g);
              u(q2, "afterRender", e);
            }
            return a3;
          };
          class C {
            static isInBreak(a3, e2) {
              const f = a3.repeat || Infinity, g2 = a3.from, h2 = a3.to - a3.from;
              e2 = e2 >= g2 ? (e2 - g2) % f : f - (g2 - e2) % f;
              return a3.inclusive ? e2 <= h2 : e2 < h2 && 0 !== e2;
            }
            static lin2Val(a3) {
              var e2 = this.brokenAxis;
              e2 = e2 && e2.breakArray;
              if (!e2 || !E(a3))
                return a3;
              let f, g2;
              for (g2 = 0; g2 < e2.length && !(f = e2[g2], f.from >= a3); g2++)
                f.to < a3 ? a3 += f.len : C.isInBreak(f, a3) && (a3 += f.len);
              return a3;
            }
            static val2Lin(a3) {
              var e2 = this.brokenAxis;
              e2 = e2 && e2.breakArray;
              if (!e2 || !E(a3))
                return a3;
              let f = a3, g2, h2;
              for (h2 = 0; h2 < e2.length; h2++)
                if (g2 = e2[h2], g2.to <= a3)
                  f -= g2.len;
                else if (g2.from >= a3)
                  break;
                else if (C.isInBreak(g2, a3)) {
                  f -= a3 - g2.from;
                  break;
                }
              return f;
            }
            constructor(a3) {
              this.hasBreaks = false;
              this.axis = a3;
            }
            findBreakAt(a3, e2) {
              return K(e2, function(e3) {
                return e3.from < a3 && a3 < e3.to;
              });
            }
            isInAnyBreak(a3, e2) {
              const f = this.axis, g2 = f.options.breaks || [];
              let h2 = g2.length, d, b, c;
              if (h2 && E(a3)) {
                for (; h2--; )
                  C.isInBreak(g2[h2], a3) && (d = true, b || (b = B(g2[h2].showPoints, !f.isXAxis)));
                c = d && e2 ? d && !b : d;
              }
              return c;
            }
            setBreaks(a3, e2) {
              const f = this, g2 = f.axis, h2 = D(a3) && !!a3.length;
              g2.isDirty = f.hasBreaks !== h2;
              f.hasBreaks = h2;
              a3 !== g2.options.breaks && (g2.options.breaks = g2.userOptions.breaks = a3);
              g2.forceRedraw = true;
              g2.series.forEach(function(a4) {
                a4.isDirty = true;
              });
              h2 || g2.val2lin !== C.val2Lin || (delete g2.val2lin, delete g2.lin2val);
              h2 && (g2.userOptions.ordinal = false, g2.lin2val = C.lin2Val, g2.val2lin = C.val2Lin, g2.setExtremes = function(a4, b, c, e3, h3) {
                if (f.hasBreaks) {
                  const c2 = this.options.breaks || [];
                  let d;
                  for (; d = f.findBreakAt(a4, c2); )
                    a4 = d.to;
                  for (; d = f.findBreakAt(b, c2); )
                    b = d.from;
                  b < a4 && (b = a4);
                }
                g2.constructor.prototype.setExtremes.call(this, a4, b, c, e3, h3);
              }, g2.setAxisTranslation = function() {
                g2.constructor.prototype.setAxisTranslation.call(this);
                f.unitLength = void 0;
                if (f.hasBreaks) {
                  const a4 = g2.options.breaks || [], b = [], c = [], e3 = B(g2.pointRangePadding, 0);
                  let h3 = 0, l, n2, m2 = g2.userMin || g2.min, r = g2.userMax || g2.max, v, q2;
                  a4.forEach(function(b2) {
                    n2 = b2.repeat || Infinity;
                    E(m2) && E(r) && (C.isInBreak(b2, m2) && (m2 += b2.to % n2 - m2 % n2), C.isInBreak(b2, r) && (r -= r % n2 - b2.from % n2));
                  });
                  a4.forEach(function(a5) {
                    v = a5.from;
                    n2 = a5.repeat || Infinity;
                    if (E(m2) && E(r)) {
                      for (; v - n2 > m2; )
                        v -= n2;
                      for (; v < m2; )
                        v += n2;
                      for (q2 = v; q2 < r; q2 += n2)
                        b.push({ value: q2, move: "in" }), b.push({ value: q2 + a5.to - a5.from, move: "out", size: a5.breakSize });
                    }
                  });
                  b.sort(function(b2, a5) {
                    return b2.value === a5.value ? ("in" === b2.move ? 0 : 1) - ("in" === a5.move ? 0 : 1) : b2.value - a5.value;
                  });
                  l = 0;
                  v = m2;
                  b.forEach(function(b2) {
                    l += "in" === b2.move ? 1 : -1;
                    1 === l && "in" === b2.move && (v = b2.value);
                    0 === l && E(v) && (c.push({ from: v, to: b2.value, len: b2.value - v - (b2.size || 0) }), h3 += b2.value - v - (b2.size || 0));
                  });
                  f.breakArray = c;
                  E(m2) && E(r) && E(g2.min) && (f.unitLength = r - m2 - h3 + e3, G(g2, "afterBreaks"), g2.staticScale ? g2.transA = g2.staticScale : f.unitLength && (g2.transA *= (r - g2.min + e3) / f.unitLength), e3 && (g2.minPixelPadding = g2.transA * (g2.minPointOffset || 0)), g2.min = m2, g2.max = r);
                }
              });
              B(e2, true) && g2.chart.redraw();
            }
          }
          q.Additions = C;
        })(t || (t = {}));
        return t;
      });
      L(a, "masters/modules/broken-axis.src.js", [a["Core/Globals.js"], a["Core/Axis/BrokenAxis.js"]], function(a2, A) {
        A.compose(a2.Axis, a2.Series);
      });
      L(a, "Extensions/DataGrouping/ApproximationRegistry.js", [], function() {
        return {};
      });
      L(a, "Extensions/DataGrouping/ApproximationDefaults.js", [
        a["Extensions/DataGrouping/ApproximationRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A) {
        function u(a3) {
          const m = a3.length;
          a3 = K(a3);
          t(a3) && m && (a3 = E(a3 / m));
          return a3;
        }
        function K(a3) {
          let m = a3.length, q;
          if (!m && a3.hasNulls)
            q = null;
          else if (m)
            for (q = 0; m--; )
              q += a3[m];
          return q;
        }
        const { arrayMax: G, arrayMin: D, correctFloat: E, extend: B, isNumber: t } = A;
        A = { average: u, averages: function() {
          const a3 = [];
          [].forEach.call(arguments, function(m) {
            a3.push(u(m));
          });
          return "undefined" === typeof a3[0] ? void 0 : a3;
        }, close: function(a3) {
          return a3.length ? a3[a3.length - 1] : a3.hasNulls ? null : void 0;
        }, high: function(a3) {
          return a3.length ? G(a3) : a3.hasNulls ? null : void 0;
        }, hlc: function(q, m, p) {
          q = a2.high(q);
          m = a2.low(m);
          p = a2.close(p);
          if (t(q) || t(m) || t(p))
            return [q, m, p];
        }, low: function(a3) {
          return a3.length ? D(a3) : a3.hasNulls ? null : void 0;
        }, ohlc: function(q, m, p, n) {
          q = a2.open(q);
          m = a2.high(m);
          p = a2.low(p);
          n = a2.close(n);
          if (t(q) || t(m) || t(p) || t(n))
            return [q, m, p, n];
        }, open: function(a3) {
          return a3.length ? a3[0] : a3.hasNulls ? null : void 0;
        }, range: function(q, m) {
          q = a2.low(q);
          m = a2.high(m);
          if (t(q) || t(m))
            return [q, m];
          if (null === q && null === m)
            return null;
        }, sum: K };
        B(a2, A);
        return A;
      });
      L(
        a,
        "Extensions/DataGrouping/DataGroupingDefaults.js",
        [],
        function() {
          return { common: { groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%A, %e %b, %H:%M:%S.%L", "%A, %e %b, %H:%M:%S.%L", "-%H:%M:%S.%L"], second: ["%A, %e %b, %H:%M:%S", "%A, %e %b, %H:%M:%S", "-%H:%M:%S"], minute: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"], hour: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"], day: ["%A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"], week: ["Week from %A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"], month: ["%B %Y", "%B", "-%B %Y"], year: ["%Y", "%Y", "-%Y"] } }, seriesSpecific: {
            line: {},
            spline: {},
            area: {},
            areaspline: {},
            arearange: {},
            column: { groupPixelWidth: 10 },
            columnrange: { groupPixelWidth: 10 },
            candlestick: { groupPixelWidth: 10 },
            ohlc: { groupPixelWidth: 5 },
            hlc: { groupPixelWidth: 5 },
            heikinashi: { groupPixelWidth: 10 }
          }, units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]] };
        }
      );
      L(a, "Extensions/DataGrouping/DataGroupingAxisComposition.js", [
        a["Extensions/DataGrouping/DataGroupingDefaults.js"],
        a["Core/Utilities.js"]
      ], function(a2, A) {
        function u(a3) {
          const h = this, g = h.series;
          g.forEach(function(a4) {
            a4.groupPixelWidth = void 0;
          });
          g.forEach(function(e) {
            e.groupPixelWidth = h.getGroupPixelWidth && h.getGroupPixelWidth();
            e.groupPixelWidth && (e.hasProcessed = true);
            e.applyGrouping(!!a3.hasExtremesChanged);
          });
        }
        function K() {
          const n = this.series;
          let h = n.length, g = 0, e = false, m2, p2;
          for (; h--; )
            if (p2 = n[h].options.dataGrouping) {
              if (g = Math.max(g, q(p2.groupPixelWidth, a2.common.groupPixelWidth)), m2 = (n[h].processedXData || n[h].data).length, n[h].groupPixelWidth || m2 > this.chart.plotSizeX / g || m2 && p2.forced)
                e = true;
            }
          return e ? g : 0;
        }
        function G() {
          this.series.forEach(function(a3) {
            a3.hasProcessed = false;
          });
        }
        function D(a3, h) {
          let g;
          h = q(h, true);
          a3 || (a3 = { forced: false, units: null });
          if (this instanceof p)
            for (g = this.series.length; g--; )
              this.series[g].update({ dataGrouping: a3 }, false);
          else
            this.chart.options.series.forEach(function(e) {
              e.dataGrouping = "boolean" === typeof a3 ? a3 : t(a3, e.dataGrouping);
            });
          this.ordinal && (this.ordinal.slope = void 0);
          h && this.chart.redraw();
        }
        const { addEvent: E, extend: B, merge: t, pick: q } = A, m = [];
        let p;
        return { compose: function(a3) {
          p = a3;
          A.pushUnique(m, a3) && (E(a3, "afterSetScale", G), E(a3, "postProcessData", u), B(a3.prototype, { applyGrouping: u, getGroupPixelWidth: K, setDataGrouping: D }));
        } };
      });
      L(a, "Extensions/DataGrouping/DataGroupingSeriesComposition.js", [a["Extensions/DataGrouping/ApproximationRegistry.js"], a["Extensions/DataGrouping/DataGroupingDefaults.js"], a["Core/Axis/DateTimeAxis.js"], a["Core/Defaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D) {
        function u(a3) {
          var f2 = this.chart, h2 = this.options.dataGrouping, d = false !== this.allowDG && h2 && C(h2.enabled, f2.options.isStock), b = this.visible || !f2.options.chart.ignoreHiddenSeries;
          const c = this.currentDataGrouping;
          var k = false;
          d && !this.requireSorting && (this.requireSorting = k = true);
          a3 = false === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !a3) || !d;
          k && (this.requireSorting = false);
          if (!a3) {
            this.destroyGroupedData();
            a3 = h2.groupAll ? this.xData : this.processedXData;
            d = h2.groupAll ? this.yData : this.processedYData;
            var m2 = f2.plotSizeX;
            k = this.xAxis;
            var r = k.options.ordinal, q2 = this.groupPixelWidth, p2;
            let l;
            if (q2 && a3 && a3.length && m2) {
              this.isDirty = l = true;
              this.points = null;
              var t2 = k.getExtremes();
              var x2 = t2.min;
              t2 = t2.max;
              r = r && k.ordinal && k.ordinal.getGroupIntervalFactor(x2, t2, this) || 1;
              m2 = k.getTimeTicks(J.Additions.prototype.normalizeTimeTickInterval(q2 * (t2 - x2) / m2 * r, h2.units || A.units), Math.min(x2, a3[0]), Math.max(t2, a3[a3.length - 1]), k.options.startOfWeek, a3, this.closestPointRange);
              q2 = n.groupData.apply(this, [a3, d, m2, h2.approximation]);
              a3 = q2.groupedXData;
              d = q2.groupedYData;
              r = 0;
              h2 && h2.smoothed && a3.length && (h2.firstAnchor = "firstPoint", h2.anchor = "middle", h2.lastAnchor = "lastPoint", e(32, false, f2, { "dataGrouping.smoothed": "use dataGrouping.anchor" }));
              f2 = a3;
              var u2 = t2, y2 = this.options.dataGrouping;
              t2 = this.currentDataGrouping && this.currentDataGrouping.gapSize;
              if (y2 && this.xData && t2 && this.groupMap) {
                x2 = f2.length - 1;
                var H = y2.anchor;
                const b2 = C(y2.firstAnchor, H);
                y2 = C(y2.lastAnchor, H);
                if (H && "start" !== H) {
                  var B2 = t2 * { middle: 0.5, end: 1 }[H];
                  for (H = f2.length - 1; H-- && 0 < H; )
                    f2[H] += B2;
                }
                b2 && "start" !== b2 && this.xData[0] >= f2[0] && (H = this.groupMap[0].start, B2 = this.groupMap[0].length, I(H) && I(B2) && (p2 = H + (B2 - 1)), f2[0] = { middle: f2[0] + 0.5 * t2, end: f2[0] + t2, firstPoint: this.xData[0], lastPoint: p2 && this.xData[p2] }[b2]);
                y2 && "start" !== y2 && t2 && f2[x2] >= u2 - t2 && (p2 = this.groupMap[this.groupMap.length - 1].start, f2[x2] = { middle: f2[x2] + 0.5 * t2, end: f2[x2] + t2, firstPoint: p2 && this.xData[p2], lastPoint: this.xData[this.xData.length - 1] }[y2]);
              }
              for (p2 = 1; p2 < m2.length; p2++)
                m2.info.segmentStarts && -1 !== m2.info.segmentStarts.indexOf(p2) || (r = Math.max(m2[p2] - m2[p2 - 1], r));
              t2 = m2.info;
              t2.gapSize = r;
              this.closestPointRange = m2.info.totalRange;
              this.groupMap = q2.groupMap;
              if (b) {
                b = k;
                p2 = a3;
                if (g(p2[0]) && I(b.min) && I(b.dataMin) && p2[0] < b.min) {
                  if (!g(b.options.min) && b.min <= b.dataMin || b.min === b.dataMin)
                    b.min = Math.min(p2[0], b.min);
                  b.dataMin = Math.min(p2[0], b.dataMin);
                }
                if (g(p2[p2.length - 1]) && I(b.max) && I(b.dataMax) && p2[p2.length - 1] > b.max) {
                  if (!g(b.options.max) && I(b.dataMax) && b.max >= b.dataMax || b.max === b.dataMax)
                    b.max = Math.max(p2[p2.length - 1], b.max);
                  b.dataMax = Math.max(p2[p2.length - 1], b.dataMax);
                }
              }
              h2.groupAll && (this.allGroupedData = d, h2 = this.cropData(a3, d, k.min, k.max, 1), a3 = h2.xData, d = h2.yData, this.cropStart = h2.start);
              this.processedXData = a3;
              this.processedYData = d;
            } else
              this.groupMap = null;
            this.hasGroupedData = l;
            this.currentDataGrouping = t2;
            this.preventGraphAnimation = (c && c.totalRange) !== (t2 && t2.totalRange);
          }
        }
        function B() {
          this.groupedData && (this.groupedData.forEach(function(a3, e2) {
            a3 && (this.groupedData[e2] = a3.destroy ? a3.destroy() : null);
          }, this), this.groupedData.length = 0);
        }
        function t() {
          f.apply(this);
          this.destroyGroupedData();
          this.groupedData = this.hasGroupedData ? this.points : null;
        }
        function q() {
          return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
        }
        function m(e2, f2, h2, d) {
          const b = this, c = b.data, k = b.options && b.options.data, l = [], n2 = [], m2 = [], r = e2.length, p2 = !!f2, v = [], q2 = b.pointArrayMap, t2 = q2 && q2.length, x2 = ["x"].concat(q2 || ["y"]), u2 = this.options.dataGrouping && this.options.dataGrouping.groupAll;
          let y2 = 0, C2 = 0;
          d = "function" === typeof d ? d : d && a2[d] ? a2[d] : a2[b.getDGApproximation && b.getDGApproximation() || "average"];
          if (t2)
            for (var A2 = q2.length; A2--; )
              v.push([]);
          else
            v.push([]);
          A2 = t2 || 1;
          for (let a3 = 0; a3 <= r; a3++)
            if (!(e2[a3] < h2[0])) {
              for (; "undefined" !== typeof h2[y2 + 1] && e2[a3] >= h2[y2 + 1] || a3 === r; ) {
                var B2 = h2[y2];
                b.dataGroupInfo = { start: u2 ? C2 : b.cropStart + C2, length: v[0].length };
                var E = d.apply(b, v);
                b.pointClass && !g(b.dataGroupInfo.options) && (b.dataGroupInfo.options = M(b.pointClass.prototype.optionsToObject.call({ series: b }, b.options.data[b.cropStart + C2])), x2.forEach(function(a4) {
                  delete b.dataGroupInfo.options[a4];
                }));
                "undefined" !== typeof E && (l.push(B2), n2.push(E), m2.push(b.dataGroupInfo));
                C2 = a3;
                for (B2 = 0; B2 < A2; B2++)
                  v[B2].length = 0, v[B2].hasNulls = false;
                y2 += 1;
                if (a3 === r)
                  break;
              }
              if (a3 === r)
                break;
              if (q2) {
                B2 = b.options.dataGrouping && b.options.dataGrouping.groupAll ? a3 : b.cropStart + a3;
                B2 = c && c[B2] || b.pointClass.prototype.applyOptions.apply({ series: b }, [k[B2]]);
                for (let b2 = 0; b2 < t2; b2++)
                  E = B2[q2[b2]], I(E) ? v[b2].push(E) : null === E && (v[b2].hasNulls = true);
              } else
                B2 = p2 ? f2[a3] : null, I(B2) ? v[0].push(B2) : null === B2 && (v[0].hasNulls = true);
            }
          return { groupedXData: l, groupedYData: n2, groupMap: m2 };
        }
        function p(a3) {
          a3 = a3.options;
          const e2 = this.type, f2 = this.chart.options.plotOptions, d = this.useCommonDataGrouping && A.common, b = A.seriesSpecific;
          let c = K.defaultOptions.plotOptions[e2].dataGrouping;
          if (f2 && (b[e2] || d)) {
            const k = this.chart.rangeSelector;
            c || (c = M(A.common, b[e2]));
            a3.dataGrouping = M(d, c, f2.series && f2.series.dataGrouping, f2[e2].dataGrouping, this.userOptions.dataGrouping, !a3.isInternal && k && I(k.selected) && k.buttonOptions[k.selected].dataGrouping);
          }
        }
        const { series: { prototype: n } } = G, { addEvent: h, defined: g, error: e, extend: x, isNumber: I, merge: M, pick: C } = D, f = n.generatePoints, y = [];
        return { compose: function(a3) {
          const f2 = a3.prototype.pointClass;
          D.pushUnique(y, f2) && h(f2, "update", function() {
            if (this.dataGroup)
              return e(24, false, this.series.chart), false;
          });
          D.pushUnique(y, a3) && (h(a3, "afterSetOptions", p), h(a3, "destroy", B), x(a3.prototype, { applyGrouping: u, destroyGroupedData: B, generatePoints: t, getDGApproximation: q, groupData: m }));
        }, groupData: m };
      });
      L(a, "Extensions/DataGrouping/DataGrouping.js", [
        a["Extensions/DataGrouping/DataGroupingAxisComposition.js"],
        a["Extensions/DataGrouping/DataGroupingDefaults.js"],
        a["Extensions/DataGrouping/DataGroupingSeriesComposition.js"],
        a["Core/Templating.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G) {
        function u(a3) {
          const n = this.chart, h = n.time, g = a3.labelConfig, e = g.series;
          var m2 = e.tooltipOptions, p = e.options.dataGrouping;
          const u2 = e.xAxis;
          var C = m2.xDateFormat;
          let f, y, r = m2[a3.isFooter ? "footerFormat" : "headerFormat"];
          u2 && "datetime" === u2.options.type && p && q(g.key) && (y = e.currentDataGrouping, p = p.dateTimeLabelFormats || A.common.dateTimeLabelFormats, y ? (m2 = p[y.unitName], 1 === y.count ? C = m2[0] : (C = m2[1], f = m2[2])) : !C && p && u2.dateTime && (C = u2.dateTime.getXDateFormat(
            g.x,
            m2.dateTimeLabelFormats
          )), C = h.dateFormat(C, g.key), f && (C += h.dateFormat(f, g.key + y.totalRange - 1)), e.chart.styledMode && (r = this.styledModeFormat(r)), a3.text = E(r, { point: t(g.point, { key: C }), series: e }, n), a3.preventDefault());
        }
        const { format: E } = K, { addEvent: B, extend: t, isNumber: q } = G, m = [];
        K = { compose: function(p, n, h) {
          a2.compose(p);
          J.compose(n);
          h && G.pushUnique(m, h) && B(h, "headerFormatter", u);
        }, groupData: J.groupData };
        "";
        "";
        return K;
      });
      L(a, "masters/modules/datagrouping.src.js", [
        a["Core/Globals.js"],
        a["Extensions/DataGrouping/ApproximationDefaults.js"],
        a["Extensions/DataGrouping/ApproximationRegistry.js"],
        a["Extensions/DataGrouping/DataGrouping.js"]
      ], function(a2, A, J, K) {
        a2.dataGrouping = { approximationDefaults: A, approximations: J };
        K.compose(a2.Axis, a2.Series, a2.Tooltip);
      });
      L(a, "Extensions/MouseWheelZoom/MouseWheelZoom.js", [a["Core/Utilities.js"]], function(a2) {
        function u() {
          const a3 = this, e = q(a3.options.chart.zooming.mouseWheel);
          e.enabled && J(this.container, "wheel", (g) => {
            g = this.pointer.normalize(g);
            if (a3.isInsidePlot(g.chartX - a3.plotLeft, g.chartY - a3.plotTop)) {
              const n2 = G(e.sensitivity, 1.1);
              h(a3, Math.pow(n2, g.detail || (g.deltaY || 0) / 120), a3.xAxis[0].toValue(g.chartX), a3.yAxis[0].toValue(g.chartY), g.chartX, g.chartY, e);
            }
            g.preventDefault && g.preventDefault();
          });
        }
        const { addEvent: J, isObject: K, pick: G, defined: D, merge: E } = a2, B = [], t = { enabled: true, sensitivity: 1.1 }, q = (a3) => K(a3) ? E(t, a3) : E(t, { enabled: D(a3) ? a3 : true }), m = function(a3, e) {
          a3.x + a3.width > e.x + e.width && (a3.width > e.width ? (a3.width = e.width, a3.x = e.x) : a3.x = e.x + e.width - a3.width);
          a3.width > e.width && (a3.width = e.width);
          a3.x < e.x && (a3.x = e.x);
          a3.y + a3.height > e.y + e.height && (a3.height > e.height ? (a3.height = e.height, a3.y = e.y) : a3.y = e.y + e.height - a3.height);
          a3.height > e.height && (a3.height = e.height);
          a3.y < e.y && (a3.y = e.y);
          return a3;
        };
        let p, n;
        const h = function(a3, e, h2, q2, t2, u2, f) {
          const g = a3.xAxis[0], r = a3.yAxis[0];
          var l = G(f.type, a3.options.chart.zooming.type, "x");
          f = /x/.test(l);
          l = /y/.test(l);
          if (D(g.max) && D(g.min) && D(r.max) && D(r.min) && D(g.dataMax) && D(g.dataMin) && D(r.dataMax) && D(r.dataMin)) {
            if (l) {
              D(p) && clearTimeout(p);
              const { startOnTick: a4, endOnTick: b2 } = r.options;
              n || (n = { startOnTick: a4, endOnTick: b2 });
              (a4 || b2) && r.setOptions({ startOnTick: false, endOnTick: false });
              p = setTimeout(() => {
                if (n) {
                  r.setOptions(n);
                  const { min: a5, max: b3 } = r.getExtremes();
                  r.forceRedraw = true;
                  r.setExtremes(a5, b3);
                  n = void 0;
                }
              }, 400);
            }
            if (a3.inverted) {
              var v = r.pos + r.len;
              h2 = g.toValue(u2);
              q2 = r.toValue(t2);
              var d = t2;
              t2 = u2;
              u2 = v - d + r.pos;
            }
            t2 = t2 ? (t2 - g.pos) / g.len : 0.5;
            if (g.reversed && !a3.inverted || a3.inverted && !g.reversed)
              t2 = 1 - t2;
            u2 = 1 - (u2 ? (u2 - r.pos) / r.len : 0.5);
            r.reversed && (u2 = 1 - u2);
            v = g.max - g.min;
            h2 = G(h2, g.min + v / 2);
            v *= e;
            d = r.max - r.min;
            q2 = G(q2, r.min + d / 2);
            const k = d * e;
            var b = g.dataMax - g.dataMin, c = r.dataMax - r.dataMin;
            d = g.dataMin - b * g.options.minPadding;
            b = b + b * g.options.minPadding + b * g.options.maxPadding;
            const w = r.dataMin - c * r.options.minPadding;
            c = c + c * r.options.minPadding + c * r.options.maxPadding;
            t2 = m({ x: h2 - v * t2, y: q2 - k * u2, width: v, height: k }, { x: d, y: w, width: b, height: c });
            u2 = t2.x <= d && t2.width >= b && t2.y <= w && t2.height >= c;
            D(e) && !u2 ? (f && g.setExtremes(t2.x, t2.x + t2.width, false), l && r.setExtremes(t2.y, t2.y + t2.height, false)) : (f && g.setExtremes(void 0, void 0, false), l && r.setExtremes(void 0, void 0, false));
            a3.redraw(false);
          }
        };
        "";
        return { compose: function(a3) {
          -1 === B.indexOf(a3) && (B.push(a3), J(a3, "afterGetContainer", u));
        } };
      });
      L(a, "masters/modules/mouse-wheel-zoom.src.js", [a["Core/Globals.js"], a["Extensions/MouseWheelZoom/MouseWheelZoom.js"]], function(a2, A) {
        A.compose(a2.Chart);
      });
      L(a, "Series/DataModifyComposition.js", [a["Core/Axis/Axis.js"], a["Core/Series/Point.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, A, J, K) {
        const { prototype: { tooltipFormatter: u } } = A, { addEvent: D, arrayMax: E, arrayMin: B, correctFloat: t, defined: q, isArray: m, isNumber: p, isString: n, pick: h } = K;
        var g;
        (function(a3) {
          function e(a4, b2, d2) {
            this.isXAxis || (this.series.forEach(function(c) {
              "compare" === a4 && "boolean" !== typeof b2 ? c.setCompare(b2, false) : "cumulative" !== a4 || n(b2) || c.setCumulative(b2, false);
            }), h(d2, true) && this.chart.redraw());
          }
          function g2(a4) {
            const b2 = this, { numberFormatter: c } = b2.series.chart, d2 = function(d3) {
              a4 = a4.replace("{point." + d3 + "}", (0 < b2[d3] && "change" === d3 ? "+" : "") + c(b2[d3], h(b2.series.tooltipOptions.changeDecimals, 2)));
            };
            q(b2.change) && d2("change");
            q(b2.cumulativeSum) && d2("cumulativeSum");
            return u.apply(this, [a4]);
          }
          function A2() {
            const a4 = this.options.compare;
            let d2;
            if ("percent" === a4 || "value" === a4 || this.options.cumulative)
              d2 = new b(this), "percent" === a4 || "value" === a4 ? d2.initCompare(a4) : d2.initCumulative();
            this.dataModify = d2;
          }
          function C(a4) {
            a4 = a4.dataExtremes;
            const c = a4.activeYData;
            if (this.dataModify && a4) {
              let d2;
              this.options.compare ? d2 = [this.dataModify.modifyValue(a4.dataMin), this.dataModify.modifyValue(a4.dataMax)] : this.options.cumulative && m(c) && 2 <= c.length && (d2 = b.getCumulativeExtremes(c));
              d2 && (a4.dataMin = B(d2), a4.dataMax = E(d2));
            }
          }
          function f(a4, b2) {
            this.options.compare = this.userOptions.compare = a4;
            this.update({}, h(b2, true));
            !this.dataModify || "value" !== a4 && "percent" !== a4 ? this.points.forEach((a5) => {
              delete a5.change;
            }) : this.dataModify.initCompare(a4);
          }
          function y() {
            if (this.xAxis && this.processedYData && this.dataModify) {
              const a4 = this.processedXData, b2 = this.processedYData, d2 = b2.length, e2 = true === this.options.compareStart ? 0 : 1;
              let f2 = -1, g3;
              this.pointArrayMap && (f2 = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y"));
              for (g3 = 0; g3 < d2 - e2; g3++) {
                const c = b2[g3] && -1 < f2 ? b2[g3][f2] : b2[g3];
                if (p(c) && 0 !== c && a4[g3 + e2] >= (this.xAxis.min || 0)) {
                  this.dataModify.compareValue = c;
                  break;
                }
              }
            }
          }
          function r(a4, b2) {
            this.setModifier("compare", a4, b2);
          }
          function l(a4, b2) {
            a4 = h(a4, false);
            this.options.cumulative = this.userOptions.cumulative = a4;
            this.update({}, h(b2, true));
            this.dataModify ? this.dataModify.initCumulative() : this.points.forEach((a5) => {
              delete a5.cumulativeSum;
            });
          }
          function v(a4, b2) {
            this.setModifier("cumulative", a4, b2);
          }
          const d = [];
          a3.compose = function(a4, b2, h2) {
            if (K.pushUnique(d, a4)) {
              const b3 = a4.prototype;
              b3.setCompare = f;
              b3.setCumulative = l;
              D(
                a4,
                "afterInit",
                A2
              );
              D(a4, "afterGetExtremes", C);
              D(a4, "afterProcessData", y);
            }
            K.pushUnique(d, b2) && (b2 = b2.prototype, b2.setCompare = r, b2.setModifier = e, b2.setCumulative = v);
            K.pushUnique(d, h2) && (h2.prototype.tooltipFormatter = g2);
            return a4;
          };
          class b {
            constructor(a4) {
              this.series = a4;
            }
            modifyValue() {
              return 0;
            }
            static getCumulativeExtremes(a4) {
              let b2 = Infinity, c = -Infinity;
              a4.reduce((a5, d2) => {
                d2 = a5 + d2;
                b2 = Math.min(b2, d2, a5);
                c = Math.max(c, d2, a5);
                return d2;
              });
              return [b2, c];
            }
            initCompare(a4) {
              this.modifyValue = function(b2, c) {
                null === b2 && (b2 = 0);
                const d2 = this.compareValue;
                return "undefined" !== typeof b2 && "undefined" !== typeof d2 ? (b2 = "value" === a4 ? b2 - d2 : b2 / d2 * 100 - (100 === this.series.options.compareBase ? 0 : 100), "undefined" !== typeof c && (c = this.series.points[c]) && (c.change = b2), b2) : 0;
              };
            }
            initCumulative() {
              this.modifyValue = function(a4, b2) {
                null === a4 && (a4 = 0);
                if (void 0 !== a4 && void 0 !== b2) {
                  const c = 0 < b2 ? this.series.points[b2 - 1] : null;
                  c && c.cumulativeSum && (a4 = t(c.cumulativeSum + a4));
                  if (b2 = this.series.points[b2])
                    b2.cumulativeSum = a4;
                  return a4;
                }
                return 0;
              };
            }
          }
          a3.Additions = b;
        })(g || (g = {}));
        "";
        return g;
      });
      L(
        a,
        "Core/Axis/NavigatorAxisComposition.js",
        [a["Core/Globals.js"], a["Core/Utilities.js"]],
        function(a2, A) {
          function u() {
            this.navigatorAxis || (this.navigatorAxis = new p(this));
          }
          function K(a3) {
            var h = this.chart, g = h.options, e = g.navigator;
            const n = this.navigatorAxis, m2 = h.zooming.pinchType;
            g = g.rangeSelector;
            h = h.zooming.type;
            this.isXAxis && (e && e.enabled || g && g.enabled) && ("y" === h ? a3.zoomed = false : (!G && "xy" === h || G && "xy" === m2) && this.options.range && (e = n.previousZoom, B(a3.newMin) ? n.previousZoom = [this.min, this.max] : e && (a3.newMin = e[0], a3.newMax = e[1], n.previousZoom = void 0)));
            "undefined" !== typeof a3.zoomed && a3.preventDefault();
          }
          const { isTouchDevice: G } = a2, { addEvent: D, correctFloat: E, defined: B, isNumber: t, pick: q } = A, m = [];
          class p {
            static compose(a3) {
              A.pushUnique(m, a3) && (a3.keepProps.push("navigatorAxis"), D(a3, "init", u), D(a3, "zoom", K));
            }
            constructor(a3) {
              this.axis = a3;
            }
            destroy() {
              this.axis = void 0;
            }
            toFixedRange(a3, h, g, e) {
              const m2 = this.axis;
              var n = m2.chart;
              a3 = q(g, m2.translate(a3, true, !m2.horiz));
              h = q(e, m2.translate(h, true, !m2.horiz));
              n = n && n.fixedRange;
              const p2 = (m2.pointRange || 0) / 2;
              B(g) || (a3 = E(a3 + p2));
              B(e) || (h = E(h - p2));
              n && m2.dataMin && m2.dataMax && (h >= m2.dataMax && (a3 = E(m2.dataMax - n)), a3 <= m2.dataMin && (h = E(m2.dataMin + n)));
              t(a3) && t(h) || (a3 = h = void 0);
              return { min: a3, max: h };
            }
          }
          return p;
        }
      );
      L(a, "Stock/Navigator/NavigatorDefaults.js", [a["Core/Color/Color.js"], a["Core/Series/SeriesRegistry.js"]], function(a2, A) {
        ({ parse: a2 } = a2);
        ({ seriesTypes: A } = A);
        A = {
          height: 40,
          margin: 25,
          maskInside: true,
          handles: { width: 7, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" },
          maskFill: a2("#667aff").setOpacity(0.3).get(),
          outlineColor: "#999999",
          outlineWidth: 1,
          series: { type: "undefined" === typeof A.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], [
            "year",
            null
          ]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null },
          xAxis: { overscroll: 0, className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false },
          yAxis: {
            className: "highcharts-navigator-yaxis",
            gridLineWidth: 0,
            startOnTick: false,
            endOnTick: false,
            minPadding: 0.1,
            maxPadding: 0.1,
            labels: { enabled: false },
            crosshair: false,
            title: { text: null },
            tickLength: 0,
            tickWidth: 0
          }
        };
        "";
        return A;
      });
      L(a, "Stock/Navigator/NavigatorSymbols.js", [], function() {
        return { "navigator-handle": function(a2, A, J, K, G = {}) {
          a2 = G.width ? G.width / 2 : J;
          A = Math.round(a2 / 3) + 0.5;
          K = G.height || K;
          return [["M", -a2 - 1, 0.5], ["L", a2, 0.5], ["L", a2, K + 0.5], ["L", -a2 - 1, K + 0.5], ["L", -a2 - 1, 0.5], ["M", -A, 4], ["L", -A, K - 3], ["M", A - 1, 4], ["L", A - 1, K - 3]];
        } };
      });
      L(a, "Stock/Navigator/NavigatorComposition.js", [
        a["Core/Defaults.js"],
        a["Core/Globals.js"],
        a["Core/Axis/NavigatorAxisComposition.js"],
        a["Stock/Navigator/NavigatorDefaults.js"],
        a["Stock/Navigator/NavigatorSymbols.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G, D, E) {
        function u() {
          this.navigator && this.navigator.setBaseSeries(null, false);
        }
        function t() {
          var a3;
          const b = this.legend, c = this.navigator;
          let e2, f2, g2;
          if (c) {
            e2 = b && b.options;
            f2 = c.xAxis;
            g2 = c.yAxis;
            const { scrollbarHeight: d, scrollButtonSize: k } = c;
            this.inverted ? (c.left = c.opposite ? this.chartWidth - d - c.height : this.spacing[3] + d, c.top = this.plotTop + k) : (c.left = r(f2.left, this.plotLeft + k), c.top = c.navigatorOptions.top || this.chartHeight - c.height - d - ((null === (a3 = this.scrollbar) || void 0 === a3 ? void 0 : a3.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (e2 && "bottom" === e2.verticalAlign && "proximate" !== e2.layout && e2.enabled && !e2.floating ? b.legendHeight + r(e2.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
            f2 && g2 && (this.inverted ? f2.options.left = g2.options.left = c.left : f2.options.top = g2.options.top = c.top, f2.setAxisSize(), g2.setAxisSize());
          }
        }
        function q(a3) {
          this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new v(this), r(a3.redraw, true) && this.redraw(a3.animation));
        }
        function m() {
          const a3 = this.options;
          if (a3.navigator.enabled || a3.scrollbar.enabled)
            this.scroller = this.navigator = new v(this);
        }
        function p() {
          var a3 = this.options;
          const b = a3.navigator;
          a3 = a3.rangeSelector;
          if ((b && b.enabled || a3 && a3.enabled) && (!I && "x" === this.zooming.type || I && "x" === this.zooming.pinchType))
            return false;
        }
        function n(a3) {
          const b = a3.navigator;
          b && a3.xAxis[0] && (a3 = a3.xAxis[0].getExtremes(), b.render(a3.min, a3.max));
        }
        function h(a3) {
          const b = a3.options.navigator || {}, c = a3.options.scrollbar || {};
          this.navigator || this.scroller || !b.enabled && !c.enabled || (y(true, this.options.navigator, b), y(true, this.options.scrollbar, c), delete a3.options.navigator, delete a3.options.scrollbar);
        }
        function g() {
          this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
        }
        const {
          defaultOptions: e,
          setOptions: x
        } = a2, { isTouchDevice: I } = A, { getRendererType: M } = D, { addEvent: C, extend: f, merge: y, pick: r } = E, l = [];
        let v;
        return { compose: function(a3, b, c, k) {
          J.compose(a3);
          v = c;
          E.pushUnique(l, b) && (b.prototype.callbacks.push(n), C(b, "afterAddSeries", u), C(b, "afterSetChartSize", t), C(b, "afterUpdate", q), C(b, "beforeRender", m), C(b, "beforeShowResetZoom", p), C(b, "update", h));
          E.pushUnique(l, k) && C(k, "afterUpdate", g);
          E.pushUnique(l, M) && f(M().prototype.symbols, G);
          E.pushUnique(l, x) && f(e, { navigator: K });
        } };
      });
      L(
        a,
        "Core/Axis/ScrollbarAxis.js",
        [a["Core/Utilities.js"]],
        function(a2) {
          const { addEvent: u, defined: J, pick: K } = a2, G = [];
          class D {
            static compose(A, B) {
              if (!a2.pushUnique(G, A))
                return A;
              const t = (a3) => {
                const m = K(a3.options && a3.options.min, a3.min), p = K(a3.options && a3.options.max, a3.max);
                return { axisMin: m, axisMax: p, scrollMin: J(a3.dataMin) ? Math.min(m, a3.min, a3.dataMin, K(a3.threshold, Infinity)) : m, scrollMax: J(a3.dataMax) ? Math.max(p, a3.max, a3.dataMax, K(a3.threshold, -Infinity)) : p };
              };
              u(A, "afterInit", function() {
                const a3 = this;
                a3.options && a3.options.scrollbar && a3.options.scrollbar.enabled && (a3.options.scrollbar.vertical = !a3.horiz, a3.options.startOnTick = a3.options.endOnTick = false, a3.scrollbar = new B(a3.chart.renderer, a3.options.scrollbar, a3.chart), u(a3.scrollbar, "changed", function(m) {
                  let { axisMin: p, axisMax: n, scrollMin: h, scrollMax: g } = t(a3);
                  var e = g - h;
                  let q;
                  J(p) && J(n) && (a3.horiz && !a3.reversed || !a3.horiz && a3.reversed ? (q = h + e * this.to, e = h + e * this.from) : (q = h + e * (1 - this.from), e = h + e * (1 - this.to)), this.shouldUpdateExtremes(m.DOMType) ? a3.setExtremes(e, q, true, "mousemove" === m.DOMType || "touchmove" === m.DOMType ? false : void 0, m) : this.setRange(this.from, this.to));
                }));
              });
              u(A, "afterRender", function() {
                let { scrollMin: a3, scrollMax: m } = t(this), p = this.scrollbar;
                var n = this.axisTitleMargin + (this.titleOffset || 0), h = this.chart.scrollbarsOffsets;
                let g = this.options.margin || 0;
                p && (this.horiz ? (this.opposite || (h[1] += n), p.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? g : 0), this.width, this.height), this.opposite || (h[1] += g), n = 1) : (this.opposite && (h[0] += n), p.position(p.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : g) : this.opposite ? 0 : g, this.top, this.width, this.height), this.opposite && (h[0] += g), n = 0), h[n] += p.size + (p.options.margin || 0), isNaN(a3) || isNaN(m) || !J(this.min) || !J(this.max) || this.min === this.max ? p.setRange(0, 1) : (h = (this.min - a3) / (m - a3), n = (this.max - a3) / (m - a3), this.horiz && !this.reversed || !this.horiz && this.reversed ? p.setRange(h, n) : p.setRange(1 - n, 1 - h)));
              });
              u(A, "afterGetOffset", function() {
                const a3 = this.scrollbar;
                var m = a3 && !a3.options.opposite;
                m = this.horiz ? 2 : m ? 3 : 1;
                a3 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[m] += a3.size + (a3.options.margin || 0));
              });
              return A;
            }
          }
          return D;
        }
      );
      L(a, "Stock/Scrollbar/ScrollbarDefaults.js", [a["Core/Globals.js"]], function(a2) {
        return {
          height: 10,
          barBorderRadius: 5,
          buttonBorderRadius: 0,
          buttonsEnabled: false,
          liveRedraw: void 0,
          margin: void 0,
          minWidth: 6,
          opposite: true,
          step: 0.2,
          zIndex: 3,
          barBackgroundColor: "#cccccc",
          barBorderWidth: 0,
          barBorderColor: "#cccccc",
          buttonArrowColor: "#333333",
          buttonBackgroundColor: "#e6e6e6",
          buttonBorderColor: "#cccccc",
          buttonBorderWidth: 1,
          rifleColor: "none",
          trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
          trackBorderColor: "#cccccc",
          trackBorderRadius: 5,
          trackBorderWidth: 1
        };
      });
      L(a, "Stock/Scrollbar/Scrollbar.js", [a["Core/Defaults.js"], a["Core/Globals.js"], a["Core/Axis/ScrollbarAxis.js"], a["Stock/Scrollbar/ScrollbarDefaults.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G) {
        const { defaultOptions: u } = a2, { addEvent: E, correctFloat: B, defined: t, destroyObjectProperties: q, fireEvent: m, merge: p, pick: n, removeEvent: h } = G;
        class g {
          static compose(a3) {
            J.compose(a3, g);
          }
          static swapXY(a3, g2) {
            g2 && a3.forEach((a4) => {
              const e = a4.length;
              let g3;
              for (let f = 0; f < e; f += 2)
                g3 = a4[f + 1], "number" === typeof g3 && (a4[f + 1] = a4[f + 2], a4[f + 2] = g3);
            });
            return a3;
          }
          constructor(a3, g2, h2) {
            this._events = [];
            this.chart = void 0;
            this.from = this.chartY = this.chartX = 0;
            this.scrollbar = this.renderer = this.options = this.group = void 0;
            this.scrollbarButtons = [];
            this.scrollbarGroup = void 0;
            this.scrollbarLeft = 0;
            this.scrollbarRifles = void 0;
            this.scrollbarStrokeWidth = 1;
            this.to = this.size = this.scrollbarTop = 0;
            this.track = void 0;
            this.trackBorderWidth = 1;
            this.userOptions = void 0;
            this.y = this.x = 0;
            this.init(a3, g2, h2);
          }
          addEvents() {
            var a3 = this.options.inverted ? [1, 0] : [0, 1];
            const g2 = this.scrollbarButtons, h2 = this.scrollbarGroup.element, m2 = this.track.element, n2 = this.mouseDownHandler.bind(this), f = this.mouseMoveHandler.bind(this), p2 = this.mouseUpHandler.bind(this);
            a3 = [[g2[a3[0]].element, "click", this.buttonToMinClick.bind(this)], [g2[a3[1]].element, "click", this.buttonToMaxClick.bind(this)], [m2, "click", this.trackClick.bind(this)], [h2, "mousedown", n2], [h2.ownerDocument, "mousemove", f], [h2.ownerDocument, "mouseup", p2]];
            A.hasTouch && a3.push([h2, "touchstart", n2], [
              h2.ownerDocument,
              "touchmove",
              f
            ], [h2.ownerDocument, "touchend", p2]);
            a3.forEach(function(a4) {
              E.apply(null, a4);
            });
            this._events = a3;
          }
          buttonToMaxClick(a3) {
            const e = (this.to - this.from) * n(this.options.step, 0.2);
            this.updatePosition(this.from + e, this.to + e);
            m(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: a3 });
          }
          buttonToMinClick(a3) {
            const e = B(this.to - this.from) * n(this.options.step, 0.2);
            this.updatePosition(B(this.from - e), B(this.to - e));
            m(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: a3 });
          }
          cursorToScrollbarPosition(a3) {
            var e = this.options;
            e = e.minWidth > this.calculatedWidth ? e.minWidth : 0;
            return { chartX: (a3.chartX - this.x - this.xOffset) / (this.barWidth - e), chartY: (a3.chartY - this.y - this.yOffset) / (this.barWidth - e) };
          }
          destroy() {
            const a3 = this, g2 = a3.chart.scroller;
            a3.removeEvents();
            ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e) {
              a3[e] && a3[e].destroy && (a3[e] = a3[e].destroy());
            });
            g2 && a3 === g2.scrollbar && (g2.scrollbar = null, q(g2.scrollbarButtons));
          }
          drawScrollbarButton(a3) {
            const e = this.renderer, h2 = this.scrollbarButtons, m2 = this.options, n2 = this.size;
            var f = e.g().add(this.group);
            h2.push(f);
            m2.buttonsEnabled && (f = e.rect().addClass("highcharts-scrollbar-button").add(f), this.chart.styledMode || f.attr({ stroke: m2.buttonBorderColor, "stroke-width": m2.buttonBorderWidth, fill: m2.buttonBackgroundColor }), f.attr(f.crisp({ x: -0.5, y: -0.5, width: n2 + 1, height: n2 + 1, r: m2.buttonBorderRadius }, f.strokeWidth())), a3 = e.path(g.swapXY([["M", n2 / 2 + (a3 ? -1 : 1), n2 / 2 - 3], ["L", n2 / 2 + (a3 ? -1 : 1), n2 / 2 + 3], ["L", n2 / 2 + (a3 ? 2 : -2), n2 / 2]], m2.vertical)).addClass("highcharts-scrollbar-arrow").add(h2[a3]), this.chart.styledMode || a3.attr({ fill: m2.buttonArrowColor }));
          }
          init(a3, g2, h2) {
            this.scrollbarButtons = [];
            this.renderer = a3;
            this.userOptions = g2;
            this.options = p(K, u.scrollbar, g2);
            this.options.margin = n(this.options.margin, 10);
            this.chart = h2;
            this.size = n(this.options.size, this.options.height);
            g2.enabled && (this.render(), this.addEvents());
          }
          mouseDownHandler(a3) {
            a3 = this.chart.pointer.normalize(a3);
            a3 = this.cursorToScrollbarPosition(a3);
            this.chartX = a3.chartX;
            this.chartY = a3.chartY;
            this.initPositions = [this.from, this.to];
            this.grabbedCenter = true;
          }
          mouseMoveHandler(a3) {
            var e = this.chart.pointer.normalize(a3), g2 = this.options.vertical ? "chartY" : "chartX";
            const h2 = this.initPositions || [];
            !this.grabbedCenter || a3.touches && 0 === a3.touches[0][g2] || (e = this.cursorToScrollbarPosition(e)[g2], g2 = this[g2], g2 = e - g2, this.hasDragged = true, this.updatePosition(h2[0] + g2, h2[1] + g2), this.hasDragged && m(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: a3.type, DOMEvent: a3 }));
          }
          mouseUpHandler(a3) {
            this.hasDragged && m(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: a3.type, DOMEvent: a3 });
            this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
          }
          position(a3, g2, h2, m2) {
            const { buttonsEnabled: e, margin: f = 0, vertical: n2 } = this.options, p2 = this.rendered ? "animate" : "attr";
            let l = m2, v = 0;
            this.group.show();
            this.x = a3;
            this.y = g2 + this.trackBorderWidth;
            this.width = h2;
            this.height = m2;
            this.xOffset = l;
            this.yOffset = v;
            n2 ? (this.width = this.yOffset = h2 = this.size, this.xOffset = l = 0, this.yOffset = v = e ? this.size : 0, this.barWidth = m2 - (e ? 2 * h2 : 0), this.x = a3 += f) : (this.height = m2 = this.size, this.xOffset = l = e ? this.size : 0, this.barWidth = h2 - (e ? 2 * m2 : 0), this.y += f);
            this.group[p2]({ translateX: a3, translateY: this.y });
            this.track[p2]({ width: h2, height: m2 });
            this.scrollbarButtons[1][p2]({ translateX: n2 ? 0 : h2 - l, translateY: n2 ? m2 - v : 0 });
          }
          removeEvents() {
            this._events.forEach(function(a3) {
              h.apply(null, a3);
            });
            this._events.length = 0;
          }
          render() {
            const a3 = this.renderer, h2 = this.options, m2 = this.size, n2 = this.chart.styledMode, p2 = a3.g("scrollbar").attr({ zIndex: h2.zIndex }).hide().add();
            this.group = p2;
            this.track = a3.rect().addClass("highcharts-scrollbar-track").attr({
              r: h2.trackBorderRadius || 0,
              height: m2,
              width: m2
            }).add(p2);
            n2 || this.track.attr({ fill: h2.trackBackgroundColor, stroke: h2.trackBorderColor, "stroke-width": h2.trackBorderWidth });
            const f = this.trackBorderWidth = this.track.strokeWidth();
            this.track.attr({ x: -f % 2 / 2, y: -f % 2 / 2 });
            this.scrollbarGroup = a3.g().add(p2);
            this.scrollbar = a3.rect().addClass("highcharts-scrollbar-thumb").attr({ height: m2 - f, width: m2 - f, r: h2.barBorderRadius || 0 }).add(this.scrollbarGroup);
            this.scrollbarRifles = a3.path(g.swapXY([["M", -3, m2 / 4], ["L", -3, 2 * m2 / 3], ["M", 0, m2 / 4], ["L", 0, 2 * m2 / 3], ["M", 3, m2 / 4], [
              "L",
              3,
              2 * m2 / 3
            ]], h2.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
            n2 || (this.scrollbar.attr({ fill: h2.barBackgroundColor, stroke: h2.barBorderColor, "stroke-width": h2.barBorderWidth }), this.scrollbarRifles.attr({ stroke: h2.rifleColor, "stroke-width": 1 }));
            this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
            this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
            this.drawScrollbarButton(0);
            this.drawScrollbarButton(1);
          }
          setRange(a3, g2) {
            const e = this.options, h2 = e.vertical;
            var m2 = e.minWidth, f = this.barWidth;
            const n2 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
            if (t(f)) {
              var p2 = f * Math.min(g2, 1);
              a3 = Math.max(a3, 0);
              var l = Math.ceil(f * a3);
              this.calculatedWidth = p2 = B(p2 - l);
              p2 < m2 && (l = (f - m2 + p2) * a3, p2 = m2);
              m2 = Math.floor(l + this.xOffset + this.yOffset);
              f = p2 / 2 - 0.5;
              this.from = a3;
              this.to = g2;
              h2 ? (this.scrollbarGroup[n2]({ translateY: m2 }), this.scrollbar[n2]({ height: p2 }), this.scrollbarRifles[n2]({ translateY: f }), this.scrollbarTop = m2, this.scrollbarLeft = 0) : (this.scrollbarGroup[n2]({ translateX: m2 }), this.scrollbar[n2]({ width: p2 }), this.scrollbarRifles[n2]({ translateX: f }), this.scrollbarLeft = m2, this.scrollbarTop = 0);
              12 >= p2 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();
              false === e.showFull && (0 >= a3 && 1 <= g2 ? this.group.hide() : this.group.show());
              this.rendered = true;
            }
          }
          shouldUpdateExtremes(a3) {
            return n(this.options.liveRedraw, A.svg && !A.isTouchDevice && !this.chart.boosted) || "mouseup" === a3 || "touchend" === a3 || !t(a3);
          }
          trackClick(a3) {
            const e = this.chart.pointer.normalize(a3), g2 = this.to - this.from, h2 = this.y + this.scrollbarTop, n2 = this.x + this.scrollbarLeft;
            this.options.vertical && e.chartY > h2 || !this.options.vertical && e.chartX > n2 ? this.updatePosition(this.from + g2, this.to + g2) : this.updatePosition(this.from - g2, this.to - g2);
            m(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: a3 });
          }
          update(a3) {
            this.destroy();
            this.init(this.chart.renderer, p(true, this.options, a3), this.chart);
          }
          updatePosition(a3, g2) {
            1 < g2 && (a3 = B(1 - B(g2 - a3)), g2 = 1);
            0 > a3 && (g2 = B(g2 - a3), a3 = 0);
            this.from = a3;
            this.to = g2;
          }
        }
        g.defaultOptions = K;
        u.scrollbar = p(true, g.defaultOptions, u.scrollbar);
        return g;
      });
      L(a, "Stock/Navigator/Navigator.js", [a["Core/Axis/Axis.js"], a["Core/Defaults.js"], a["Core/Globals.js"], a["Core/Axis/NavigatorAxisComposition.js"], a["Stock/Navigator/NavigatorComposition.js"], a["Stock/Scrollbar/Scrollbar.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D, E) {
        function u(a3, ...c) {
          c = [].filter.call(c, f);
          if (c.length)
            return Math[a3].apply(0, c);
        }
        const { defaultOptions: t } = A, { hasTouch: q, isTouchDevice: m } = J, {
          addEvent: p,
          clamp: n,
          correctFloat: h,
          defined: g,
          destroyObjectProperties: e,
          erase: x,
          extend: I,
          find: M,
          isArray: C,
          isNumber: f,
          merge: y,
          pick: r,
          removeEvent: l,
          splat: v
        } = E;
        class d {
          static compose(a3, c, e2) {
            G.compose(a3, c, d, e2);
          }
          constructor(a3) {
            this.rendered = this.range = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
            this.scrollbarHeight = 0;
            this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.scrollButtonSize = void 0;
            this.init(a3);
          }
          drawHandle(a3, c, d2, e2) {
            const b = this.navigatorOptions.handles.height;
            this.handles[c][e2](d2 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(a3, 10) + 0.5 - b) } : { translateX: Math.round(this.left + parseInt(a3, 10)), translateY: Math.round(this.top + this.height / 2 - b / 2 - 1) });
          }
          drawOutline(a3, c, d2, e2) {
            const b = this.navigatorOptions.maskInside;
            var f2 = this.outline.strokeWidth();
            const k = f2 / 2;
            var g2 = f2 % 2 / 2;
            const h2 = this.scrollButtonSize, l2 = this.size, m2 = this.top;
            f2 = this.height;
            const n2 = m2 - k, w = m2 + f2;
            let p2 = this.left;
            d2 ? (d2 = m2 + c + g2, c = m2 + a3 + g2, g2 = [["M", p2 + f2, m2 - h2 - g2], ["L", p2 + f2, d2], ["L", p2, d2], ["M", p2, c], ["L", p2 + f2, c], ["L", p2 + f2, m2 + l2 + h2]], b && g2.push(["M", p2 + f2, d2 - k], ["L", p2 + f2, c + k])) : (p2 -= h2, a3 += p2 + h2 - g2, c += p2 + h2 - g2, g2 = [["M", p2, n2], ["L", a3, n2], ["L", a3, w], ["M", c, w], ["L", c, n2], ["L", p2 + l2 + 2 * h2, m2 + k]], b && g2.push(["M", a3 - k, n2], ["L", c + k, n2]));
            this.outline[e2]({ d: g2 });
          }
          drawMasks(a3, c, d2, e2) {
            const b = this.left, f2 = this.top, k = this.height;
            let g2, h2, l2, m2;
            d2 ? (l2 = [b, b, b], m2 = [f2, f2 + a3, f2 + c], h2 = [k, k, k], g2 = [a3, c - a3, this.size - c]) : (l2 = [b, b + a3, b + c], m2 = [f2, f2, f2], h2 = [a3, c - a3, this.size - c], g2 = [k, k, k]);
            this.shades.forEach((a4, b2) => {
              a4[e2]({ x: l2[b2], y: m2[b2], width: h2[b2], height: g2[b2] });
            });
          }
          renderElements() {
            const a3 = this, c = a3.navigatorOptions, d2 = c.maskInside, f2 = a3.chart, e2 = f2.renderer, g2 = { cursor: f2.inverted ? "ns-resize" : "ew-resize" }, h2 = a3.navigatorGroup = e2.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add();
            [!d2, d2, !d2].forEach((b, d3) => {
              const k = e2.rect().addClass("highcharts-navigator-mask" + (1 === d3 ? "-inside" : "-outside")).add(h2);
              f2.styledMode || (k.attr({ fill: b ? c.maskFill : "rgba(0,0,0,0)" }), 1 === d3 && k.css(g2));
              a3.shades[d3] = k;
            });
            a3.outline = e2.path().addClass("highcharts-navigator-outline").add(h2);
            f2.styledMode || a3.outline.attr({ "stroke-width": c.outlineWidth, stroke: c.outlineColor });
            if (c.handles && c.handles.enabled) {
              const b = c.handles, { height: d3, width: k } = b;
              [0, 1].forEach((c2) => {
                a3.handles[c2] = e2.symbol(b.symbols[c2], -k / 2 - 1, 0, k, d3, b);
                f2.inverted && a3.handles[c2].attr({ rotation: 90, rotationOriginX: Math.floor(-k / 2), rotationOriginY: (d3 + k) / 2 });
                a3.handles[c2].attr({ zIndex: 7 - c2 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + [
                  "left",
                  "right"
                ][c2]).add(h2);
                f2.styledMode || a3.handles[c2].attr({ fill: b.backgroundColor, stroke: b.borderColor, "stroke-width": b.lineWidth }).css(g2);
              });
            }
          }
          update(a3) {
            (this.series || []).forEach((a4) => {
              a4.baseSeries && delete a4.baseSeries.navigatorSeries;
            });
            this.destroy();
            y(true, this.chart.options.navigator, a3);
            this.init(this.chart);
          }
          render(a3, c, d2, e2) {
            var b = this.chart;
            const k = this.xAxis, l2 = k.pointRange || 0;
            var m2 = k.navigatorAxis.fake ? b.xAxis[0] : k;
            const p2 = this.navigatorEnabled;
            var w = this.rendered, v2 = b.inverted;
            const q2 = b.xAxis[0].minRange, t2 = b.xAxis[0].options.maxRange, u2 = this.scrollButtonSize;
            let x2 = this.scrollbarHeight, y2;
            if (!this.hasDragged || g(d2)) {
              a3 = h(a3 - l2 / 2);
              c = h(c + l2 / 2);
              if (!f(a3) || !f(c))
                if (w)
                  d2 = 0, e2 = r(k.width, m2.width);
                else
                  return;
              this.left = r(k.left, b.plotLeft + u2 + (v2 ? b.plotWidth : 0));
              var A2 = this.size = y2 = r(k.len, (v2 ? b.plotHeight : b.plotWidth) - 2 * u2);
              b = v2 ? x2 : y2 + 2 * u2;
              d2 = r(d2, k.toPixels(a3, true));
              e2 = r(e2, k.toPixels(c, true));
              f(d2) && Infinity !== Math.abs(d2) || (d2 = 0, e2 = b);
              a3 = k.toValue(d2, true);
              c = k.toValue(e2, true);
              var B = Math.abs(h(c - a3));
              B < q2 ? this.grabbedLeft ? d2 = k.toPixels(c - q2 - l2, true) : this.grabbedRight && (e2 = k.toPixels(a3 + q2 + l2, true)) : g(t2) && h(B - l2) > t2 && (this.grabbedLeft ? d2 = k.toPixels(c - t2 - l2, true) : this.grabbedRight && (e2 = k.toPixels(a3 + t2 + l2, true)));
              this.zoomedMax = n(Math.max(d2, e2), 0, A2);
              this.zoomedMin = n(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(d2, e2), 0, A2);
              this.range = this.zoomedMax - this.zoomedMin;
              A2 = Math.round(this.zoomedMax);
              d2 = Math.round(this.zoomedMin);
              p2 && (this.navigatorGroup.attr({ visibility: "inherit" }), w = w && !this.hasDragged ? "animate" : "attr", this.drawMasks(d2, A2, v2, w), this.drawOutline(
                d2,
                A2,
                v2,
                w
              ), this.navigatorOptions.handles.enabled && (this.drawHandle(d2, 0, v2, w), this.drawHandle(A2, 1, v2, w)));
              this.scrollbar && (v2 ? (v2 = this.top - u2, m2 = this.left - x2 + (p2 || !m2.opposite ? 0 : (m2.titleOffset || 0) + m2.axisTitleMargin), x2 = y2 + 2 * u2) : (v2 = this.top + (p2 ? this.height : -x2), m2 = this.left - u2), this.scrollbar.position(m2, v2, b, x2), this.scrollbar.setRange(this.zoomedMin / (y2 || 1), this.zoomedMax / (y2 || 1)));
              this.rendered = true;
            }
          }
          addMouseEvents() {
            const a3 = this, c = a3.chart, d2 = c.container;
            let e2 = [], f2, g2;
            a3.mouseMoveHandler = f2 = function(b) {
              a3.onMouseMove(b);
            };
            a3.mouseUpHandler = g2 = function(b) {
              a3.onMouseUp(b);
            };
            e2 = a3.getPartsEvents("mousedown");
            e2.push(p(c.renderTo, "mousemove", f2), p(d2.ownerDocument, "mouseup", g2));
            q && (e2.push(p(c.renderTo, "touchmove", f2), p(d2.ownerDocument, "touchend", g2)), e2.concat(a3.getPartsEvents("touchstart")));
            a3.eventsToUnbind = e2;
            a3.series && a3.series[0] && e2.push(p(a3.series[0].xAxis, "foundExtremes", function() {
              c.navigator.modifyNavigatorAxisExtremes();
            }));
          }
          getPartsEvents(a3) {
            const b = this, d2 = [];
            ["shades", "handles"].forEach(function(c) {
              b[c].forEach(function(e2, f2) {
                d2.push(p(
                  e2.element,
                  a3,
                  function(a4) {
                    b[c + "Mousedown"](a4, f2);
                  }
                ));
              });
            });
            return d2;
          }
          shadesMousedown(a3, c) {
            a3 = this.chart.pointer.normalize(a3);
            const b = this.chart, d2 = this.xAxis, e2 = this.zoomedMin, f2 = this.size, h2 = this.range;
            let l2 = this.left, m2 = a3.chartX, n2, p2;
            b.inverted && (m2 = a3.chartY, l2 = this.top);
            1 === c ? (this.grabbedCenter = m2, this.fixedWidth = h2, this.dragOffset = m2 - e2) : (a3 = m2 - l2 - h2 / 2, 0 === c ? a3 = Math.max(0, a3) : 2 === c && a3 + h2 >= f2 && (a3 = f2 - h2, this.reversedExtremes ? (a3 -= h2, p2 = this.getUnionExtremes().dataMin) : n2 = this.getUnionExtremes().dataMax), a3 !== e2 && (this.fixedWidth = h2, c = d2.navigatorAxis.toFixedRange(
              a3,
              a3 + h2,
              p2,
              n2
            ), g(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), true, null, { trigger: "navigator" })));
          }
          handlesMousedown(a3, c) {
            this.chart.pointer.normalize(a3);
            a3 = this.chart;
            const b = a3.xAxis[0], d2 = this.reversedExtremes;
            0 === c ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d2 ? b.min : b.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d2 ? b.max : b.min);
            a3.fixedRange = null;
          }
          onMouseMove(a3) {
            const b = this;
            var d2 = b.chart;
            const e2 = b.navigatorSize, f2 = b.range, g2 = b.dragOffset, h2 = d2.inverted;
            let l2 = b.left;
            a3.touches && 0 === a3.touches[0].pageX || (a3 = d2.pointer.normalize(a3), d2 = a3.chartX, h2 && (l2 = b.top, d2 = a3.chartY), b.grabbedLeft ? (b.hasDragged = true, b.render(0, 0, d2 - l2, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = true, b.render(0, 0, b.otherHandlePos, d2 - l2)) : b.grabbedCenter && (b.hasDragged = true, d2 < g2 ? d2 = g2 : d2 > e2 + g2 - f2 && (d2 = e2 + g2 - f2), b.render(0, 0, d2 - g2, d2 - g2 + f2)), b.hasDragged && b.scrollbar && r(b.scrollbar.options.liveRedraw, !m && !this.chart.boosted) && (a3.DOMType = a3.type, setTimeout(function() {
              b.onMouseUp(a3);
            }, 0)));
          }
          onMouseUp(a3) {
            var b = this.chart, d2 = this.xAxis, e2 = this.scrollbar;
            const h2 = a3.DOMEvent || a3, l2 = b.inverted, m2 = this.rendered && !this.hasDragged ? "animate" : "attr";
            let n2, p2;
            (!this.hasDragged || e2 && e2.hasDragged) && "scrollbar" !== a3.trigger || (e2 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? n2 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (p2 = this.fixedExtreme), this.zoomedMax === this.size && (p2 = this.reversedExtremes ? e2.dataMin : e2.dataMax), 0 === this.zoomedMin && (n2 = this.reversedExtremes ? e2.dataMax : e2.dataMin), d2 = d2.navigatorAxis.toFixedRange(
              this.zoomedMin,
              this.zoomedMax,
              n2,
              p2
            ), g(d2.min) && b.xAxis[0].setExtremes(Math.min(d2.min, d2.max), Math.max(d2.min, d2.max), true, this.hasDragged ? false : null, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: h2 }));
            "mousemove" !== a3.DOMType && "touchmove" !== a3.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
            this.navigatorEnabled && f(this.zoomedMin) && f(this.zoomedMax) && (b = Math.round(this.zoomedMin), a3 = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a3, l2, m2), this.outline && this.drawOutline(b, a3, l2, m2), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, l2, m2), this.drawHandle(a3, 1, l2, m2)));
          }
          removeEvents() {
            this.eventsToUnbind && (this.eventsToUnbind.forEach(function(a3) {
              a3();
            }), this.eventsToUnbind = void 0);
            this.removeBaseSeriesEvents();
          }
          removeBaseSeriesEvents() {
            const a3 = this.baseSeries || [];
            this.navigatorEnabled && a3[0] && (false !== this.navigatorOptions.adaptToUpdatedData && a3.forEach(function(a4) {
              l(
                a4,
                "updatedData",
                this.updatedDataHandler
              );
            }, this), a3[0].xAxis && l(a3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
          }
          init(b) {
            var c = b.options, d2 = c.navigator || {}, e2 = d2.enabled, g2 = c.scrollbar || {}, h2 = g2.enabled;
            c = e2 && d2.height || 0;
            var l2 = h2 && g2.height || 0;
            const m2 = g2.buttonsEnabled && l2 || 0;
            this.handles = [];
            this.shades = [];
            this.chart = b;
            this.setBaseSeries();
            this.height = c;
            this.scrollbarHeight = l2;
            this.scrollButtonSize = m2;
            this.scrollbarEnabled = h2;
            this.navigatorEnabled = e2;
            this.navigatorOptions = d2;
            this.scrollbarOptions = g2;
            this.opposite = r(d2.opposite, !(e2 || !b.inverted));
            const n2 = this;
            e2 = n2.baseSeries;
            g2 = b.xAxis.length;
            h2 = b.yAxis.length;
            l2 = e2 && e2[0] && e2[0].xAxis || b.xAxis[0] || { options: {} };
            b.isDirtyBox = true;
            n2.navigatorEnabled ? (n2.xAxis = new a2(b, y({ breaks: l2.options.breaks, ordinal: l2.options.ordinal }, d2.xAxis, { id: "navigator-x-axis", yAxis: "navigator-y-axis", type: "datetime", index: g2, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: 0, maxPadding: 0, zoomEnabled: false }, b.inverted ? { offsets: [m2, 0, -m2, 0], width: c } : {
              offsets: [0, -m2, 0, m2],
              height: c
            }), "xAxis"), n2.yAxis = new a2(b, y(d2.yAxis, { id: "navigator-y-axis", alignTicks: false, offset: 0, index: h2, isInternal: true, reversed: r(d2.yAxis && d2.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, false), zoomEnabled: false }, b.inverted ? { width: c } : { height: c }), "yAxis"), e2 || d2.series.data ? n2.updateNavigatorSeries(false) : 0 === b.series.length && (n2.unbindRedraw = p(b, "beforeRedraw", function() {
              0 < b.series.length && !n2.series && (n2.setBaseSeries(), n2.unbindRedraw());
            })), n2.reversedExtremes = b.inverted && !n2.xAxis.reversed || !b.inverted && n2.xAxis.reversed, n2.renderElements(), n2.addMouseEvents()) : (n2.xAxis = { chart: b, navigatorAxis: { fake: true }, translate: function(a3, c2) {
              var d3 = b.xAxis[0];
              const e3 = d3.getExtremes(), f2 = d3.len - 2 * m2, k = u("min", d3.options.min, e3.dataMin);
              d3 = u("max", d3.options.max, e3.dataMax) - k;
              return c2 ? a3 * d3 / f2 + k : f2 * (a3 - k) / d3;
            }, toPixels: function(a3) {
              return this.translate(a3);
            }, toValue: function(a3) {
              return this.translate(a3, true);
            } }, n2.xAxis.navigatorAxis.axis = n2.xAxis, n2.xAxis.navigatorAxis.toFixedRange = K.prototype.toFixedRange.bind(n2.xAxis.navigatorAxis));
            b.options.scrollbar.enabled && (d2 = y(b.options.scrollbar, { vertical: b.inverted }), !f(d2.margin) && n2.navigatorEnabled && (d2.margin = b.inverted ? -3 : 3), b.scrollbar = n2.scrollbar = new D(b.renderer, d2, b), p(n2.scrollbar, "changed", function(a3) {
              var b2 = n2.size;
              const c2 = b2 * this.to;
              b2 *= this.from;
              n2.hasDragged = n2.scrollbar.hasDragged;
              n2.render(0, 0, b2, c2);
              this.shouldUpdateExtremes(a3.DOMType) && setTimeout(function() {
                n2.onMouseUp(a3);
              });
            }));
            n2.addBaseSeriesEvents();
            n2.addChartEvents();
          }
          getUnionExtremes(a3) {
            const b = this.chart.xAxis[0], d2 = this.xAxis, e2 = d2.options, f2 = b.options;
            let g2;
            a3 && null === b.dataMin || (g2 = { dataMin: r(e2 && e2.min, u("min", f2.min, b.dataMin, d2.dataMin, d2.min)), dataMax: r(e2 && e2.max, u("max", f2.max, b.dataMax, d2.dataMax, d2.max)) });
            return g2;
          }
          setBaseSeries(a3, c) {
            const b = this.chart, d2 = this.baseSeries = [];
            a3 = a3 || b.options && b.options.navigator.baseSeries || (b.series.length ? M(b.series, (a4) => !a4.options.isInternal).index : 0);
            (b.series || []).forEach((b2, c2) => {
              b2.options.isInternal || !b2.options.showInNavigator && (c2 !== a3 && b2.options.id !== a3 || false === b2.options.showInNavigator) || d2.push(b2);
            });
            this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, c);
          }
          updateNavigatorSeries(a3, c) {
            const b = this, d2 = b.chart, e2 = b.baseSeries, f2 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, g2 = b.series = (b.series || []).filter((a4) => {
              const c2 = a4.baseSeries;
              return 0 > e2.indexOf(c2) ? (c2 && (l(c2, "updatedData", b.updatedDataHandler), delete c2.navigatorSeries), a4.chart && a4.destroy(), false) : true;
            });
            let h2, m2, n2 = b.navigatorOptions.series, p2;
            e2 && e2.length && e2.forEach((a4) => {
              const k = a4.navigatorSeries;
              var l2 = I({ color: a4.color, visible: a4.visible }, C(n2) ? t.navigator.series : n2);
              k && false === b.navigatorOptions.adaptToUpdatedData || (f2.name = "Navigator " + e2.length, h2 = a4.options || {}, p2 = h2.navigatorOptions || {}, l2.dataLabels = v(l2.dataLabels), m2 = y(h2, f2, l2, p2), m2.pointRange = r(l2.pointRange, p2.pointRange, t.plotOptions[m2.type || "line"].pointRange), l2 = p2.data || l2.data, b.hasNavigatorData = b.hasNavigatorData || !!l2, m2.data = l2 || h2.data && h2.data.slice(0), k && k.options ? k.update(m2, c) : (a4.navigatorSeries = d2.initSeries(m2), a4.navigatorSeries.baseSeries = a4, g2.push(a4.navigatorSeries)));
            });
            if (n2.data && (!e2 || !e2.length) || C(n2))
              b.hasNavigatorData = false, n2 = v(n2), n2.forEach((a4, c2) => {
                f2.name = "Navigator " + (g2.length + 1);
                m2 = y(t.navigator.series, { color: d2.series[c2] && !d2.series[c2].options.isInternal && d2.series[c2].color || d2.options.colors[c2] || d2.options.colors[0] }, f2, a4);
                m2.data = a4.data;
                m2.data && (b.hasNavigatorData = true, g2.push(d2.initSeries(m2)));
              });
            a3 && this.addBaseSeriesEvents();
          }
          addBaseSeriesEvents() {
            const a3 = this, c = a3.baseSeries || [];
            c[0] && c[0].xAxis && c[0].eventsToUnbind.push(p(c[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            c.forEach((b) => {
              b.eventsToUnbind.push(p(b, "show", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
              }));
              b.eventsToUnbind.push(p(b, "hide", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
              }));
              false !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(p(b, "updatedData", this.updatedDataHandler));
              b.eventsToUnbind.push(p(b, "remove", function() {
                this.navigatorSeries && (x(a3.series, this.navigatorSeries), g(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
              }));
            });
          }
          getBaseSeriesMin(a3) {
            return this.baseSeries.reduce(function(a4, b) {
              return Math.min(a4, b.xData && b.xData.length ? b.xData[0] : a4);
            }, a3);
          }
          modifyNavigatorAxisExtremes() {
            const a3 = this.xAxis;
            if ("undefined" !== typeof a3.getExtremes) {
              const b = this.getUnionExtremes(true);
              !b || b.dataMin === a3.min && b.dataMax === a3.max || (a3.min = b.dataMin, a3.max = b.dataMax);
            }
          }
          modifyBaseAxisExtremes() {
            const a3 = this.chart.navigator;
            var c = this.getExtremes();
            const d2 = c.dataMin, e2 = c.dataMax;
            c = c.max - c.min;
            const g2 = a3.stickToMin, h2 = a3.stickToMax, l2 = r(this.options.overscroll, 0), m2 = a3.series && a3.series[0], n2 = !!this.setExtremes;
            let p2, v2;
            this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger || (g2 && (v2 = d2, p2 = v2 + c), h2 && (p2 = e2 + l2, g2 || (v2 = Math.max(d2, p2 - c, a3.getBaseSeriesMin(m2 && m2.xData ? m2.xData[0] : -Number.MAX_VALUE)))), n2 && (g2 || h2) && f(v2) && (this.min = this.userMin = v2, this.max = this.userMax = p2));
            a3.stickToMin = a3.stickToMax = null;
          }
          updatedDataHandler() {
            const a3 = this.chart.navigator, c = this.navigatorSeries;
            a3.stickToMax = r(this.chart.options.navigator && this.chart.options.navigator.stickToMax, a3.reversedExtremes ? 0 === Math.round(a3.zoomedMin) : Math.round(a3.zoomedMax) >= Math.round(a3.size));
            a3.stickToMin = a3.shouldStickToMin(this, a3);
            c && !a3.hasNavigatorData && (c.options.pointStart = this.xData[0], c.setData(this.options.data, false, null, false));
          }
          shouldStickToMin(a3, c) {
            c = c.getBaseSeriesMin(a3.xData[0]);
            var b = a3.xAxis;
            a3 = b.max;
            const d2 = b.min;
            b = b.options.range;
            return f(a3) && f(d2) ? b && 0 < a3 - c ? a3 - c < b : d2 <= c : false;
          }
          addChartEvents() {
            this.eventsToUnbind || (this.eventsToUnbind = []);
            this.eventsToUnbind.push(p(this.chart, "redraw", function() {
              const a3 = this.navigator, c = a3 && (a3.baseSeries && a3.baseSeries[0] && a3.baseSeries[0].xAxis || this.xAxis[0]);
              c && a3.render(c.min, c.max);
            }), p(this.chart, "getMargins", function() {
              let a3 = this.navigator, c = a3.opposite ? "plotTop" : "marginBottom";
              this.inverted && (c = a3.opposite ? "marginRight" : "plotLeft");
              this[c] = (this[c] || 0) + (a3.navigatorEnabled || !this.inverted ? a3.height + a3.scrollbarHeight : 0) + a3.navigatorOptions.margin;
            }));
          }
          destroy() {
            this.removeEvents();
            this.xAxis && (x(this.chart.xAxis, this.xAxis), x(this.chart.axes, this.xAxis));
            this.yAxis && (x(this.chart.yAxis, this.yAxis), x(this.chart.axes, this.yAxis));
            (this.series || []).forEach((a3) => {
              a3.destroy && a3.destroy();
            });
            "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach((a3) => {
              this[a3] && this[a3].destroy && this[a3].destroy();
              this[a3] = null;
            });
            [this.handles].forEach((a3) => {
              e(a3);
            });
          }
        }
        return d;
      });
      L(
        a,
        "Stock/RangeSelector/RangeSelectorDefaults.js",
        [],
        function() {
          return { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "‚Üí" }, rangeSelector: { allButtonsEnabled: false, buttons: void 0, buttonSpacing: 5, dropdown: "responsive", enabled: void 0, verticalAlign: "top", buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 }, floating: false, x: 0, y: 0, height: void 0, inputBoxBorderColor: "none", inputBoxHeight: 17, inputBoxWidth: void 0, inputDateFormat: "%e %b %Y", inputDateParser: void 0, inputEditDateFormat: "%Y-%m-%d", inputEnabled: true, inputPosition: {
            align: "right",
            x: 0,
            y: 0
          }, inputSpacing: 5, selected: void 0, buttonPosition: { align: "left", x: 0, y: 0 }, inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" }, labelStyle: { color: "#666666", fontSize: "0.8em" } } };
        }
      );
      L(a, "Stock/RangeSelector/RangeSelectorComposition.js", [a["Core/Defaults.js"], a["Stock/RangeSelector/RangeSelectorDefaults.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        function u() {
          const a3 = this.range, e2 = a3.type, d = this.max, b = this.chart.time, c = function(a4, c2) {
            const d2 = "year" === e2 ? "FullYear" : "Month", f3 = new b.Date(a4), g3 = b.get(
              d2,
              f3
            );
            b.set(d2, f3, g3 + c2);
            g3 === b.get(d2, f3) && b.set("Date", f3, 0);
            return f3.getTime() - a4;
          };
          let f2, g2;
          I(a3) ? (f2 = d - a3, g2 = a3) : a3 && (f2 = d + c(d, -(a3.count || 1)), this.chart && (this.chart.fixedRange = d - f2));
          const h2 = C(this.dataMin, Number.MIN_VALUE);
          I(f2) || (f2 = h2);
          f2 <= h2 && (f2 = h2, "undefined" === typeof g2 && (g2 = c(f2, a3.count)), this.newMax = Math.min(f2 + g2, C(this.dataMax, Number.MAX_VALUE)));
          I(d) ? !I(a3) && a3 && a3._offsetMin && (f2 += a3._offsetMin) : f2 = void 0;
          return f2;
        }
        function G() {
          this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new r(this));
        }
        function D() {
          var a3 = this.axes;
          const e2 = this.rangeSelector;
          e2 && (I(e2.deferredYTDClick) && (e2.clickButton(e2.deferredYTDClick), delete e2.deferredYTDClick), a3.forEach((a4) => {
            a4.updateNames();
            a4.setScale();
          }), this.getAxisMargins(), e2.render(), a3 = e2.options.verticalAlign, e2.options.floating || ("bottom" === a3 ? this.extraBottomMargin = true : "middle" !== a3 && (this.extraTopMargin = true)));
        }
        function E(a3) {
          let e2, d, b, c;
          const g2 = a3.rangeSelector, l = () => {
            g2 && (e2 = a3.xAxis[0].getExtremes(), d = a3.legend, c = g2 && g2.options.verticalAlign, I(e2.min) && g2.render(
              e2.min,
              e2.max
            ), d.display && "top" === c && c === d.options.verticalAlign && (b = M(a3.spacingBox), b.y = "vertical" === d.options.layout ? a3.plotTop : b.y + g2.getHeight(), d.group.placed = false, d.align(b)));
          };
          g2 && (x(f, (b2) => b2[0] === a3) || f.push([a3, [h(a3.xAxis[0], "afterSetExtremes", function(a4) {
            g2 && g2.render(a4.min, a4.max);
          }), h(a3, "redraw", l)]]), l());
        }
        function B() {
          for (let a3 = 0, e2 = f.length; a3 < e2; ++a3) {
            const d = f[a3];
            if (d[0] === this) {
              d[1].forEach((a4) => a4());
              f.splice(a3, 1);
              break;
            }
          }
        }
        function t() {
          var a3 = this.rangeSelector;
          a3 && (a3 = a3.getHeight(), this.extraTopMargin && (this.plotTop += a3), this.extraBottomMargin && (this.marginBottom += a3));
        }
        function q() {
          var a3 = this.rangeSelector;
          a3 && !a3.options.floating && (a3.render(), a3 = a3.options.verticalAlign, "bottom" === a3 ? this.extraBottomMargin = true : "middle" !== a3 && (this.extraTopMargin = true));
        }
        function m(a3) {
          var e2 = a3.options.rangeSelector;
          a3 = this.extraBottomMargin;
          const d = this.extraTopMargin;
          let b = this.rangeSelector;
          e2 && e2.enabled && !g(b) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = b = new r(this));
          this.extraTopMargin = this.extraBottomMargin = false;
          b && (E(this), e2 = e2 && e2.verticalAlign || b.options && b.options.verticalAlign, b.options.floating || ("bottom" === e2 ? this.extraBottomMargin = true : "middle" !== e2 && (this.extraTopMargin = true)), this.extraBottomMargin !== a3 || this.extraTopMargin !== d) && (this.isDirtyBox = true);
        }
        const { defaultOptions: p, setOptions: n } = a2, { addEvent: h, defined: g, extend: e, find: x, isNumber: I, merge: M, pick: C } = J, f = [], y = [];
        let r;
        return { compose: function(a3, f2, d) {
          r = d;
          J.pushUnique(y, a3) && (a3.prototype.minFromRange = u);
          J.pushUnique(y, f2) && (h(f2, "afterGetContainer", G), h(
            f2,
            "beforeRender",
            D
          ), h(f2, "destroy", B), h(f2, "getMargins", t), h(f2, "render", q), h(f2, "update", m), f2.prototype.callbacks.push(E));
          J.pushUnique(y, n) && (e(p, { rangeSelector: A.rangeSelector }), e(p.lang, A.lang));
        } };
      });
      L(a, "Stock/RangeSelector/RangeSelector.js", [a["Core/Axis/Axis.js"], a["Core/Defaults.js"], a["Core/Globals.js"], a["Stock/RangeSelector/RangeSelectorComposition.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D) {
        function u(a3) {
          if (-1 !== a3.indexOf("%L"))
            return "text";
          const d = "aAdewbBmoyY".split("").some((b2) => -1 !== a3.indexOf("%" + b2)), b = "HkIlMS".split("").some((b2) => -1 !== a3.indexOf("%" + b2));
          return d && b ? "datetime-local" : d ? "date" : b ? "time" : "text";
        }
        const { defaultOptions: B } = A, { addEvent: t, createElement: q, css: m, defined: p, destroyObjectProperties: n, discardElement: h, extend: g, fireEvent: e, isNumber: x, merge: I, objectEach: M, pad: C, pick: f, pInt: y, splat: r } = D;
        class l {
          static compose(a3, d) {
            K.compose(a3, d, l);
          }
          constructor(a3) {
            this.buttons = void 0;
            this.buttonOptions = l.prototype.defaultButtons;
            this.initialButtonGroupWidth = 0;
            this.options = void 0;
            this.chart = a3;
            this.init(a3);
          }
          clickButton(g2, d) {
            const b = this.chart, c = this.buttonOptions[g2], k = b.xAxis[0];
            var h2 = b.scroller && b.scroller.getUnionExtremes() || k || {}, l2 = c.type;
            const m2 = c.dataGrouping;
            let n2 = h2.dataMin, v = h2.dataMax, q2, u2 = k && Math.round(Math.min(k.max, f(v, k.max))), y2;
            h2 = c._range;
            let A2, B2, C2, E = true;
            if (null !== n2 && null !== v) {
              b.fixedRange = h2;
              this.setSelected(g2);
              m2 && (this.forcedDataGrouping = true, a2.prototype.setDataGrouping.call(k || { chart: this.chart }, m2, false), this.frozenStates = c.preserveDataGrouping);
              if ("month" === l2 || "year" === l2)
                k ? (l2 = { range: c, max: u2, chart: b, dataMin: n2, dataMax: v }, q2 = k.minFromRange.call(l2), x(l2.newMax) && (u2 = l2.newMax), E = false) : h2 = c;
              else if (h2)
                q2 = Math.max(u2 - h2, n2), u2 = Math.min(q2 + h2, v), E = false;
              else if ("ytd" === l2)
                if (k) {
                  if ("undefined" === typeof v || "undefined" === typeof n2)
                    n2 = Number.MAX_VALUE, v = Number.MIN_VALUE, b.series.forEach((a3) => {
                      if (a3 = a3.xData)
                        n2 = Math.min(a3[0], n2), v = Math.max(a3[a3.length - 1], v);
                    }), d = false;
                  l2 = this.getYTDExtremes(v, n2, b.time.useUTC);
                  q2 = A2 = l2.min;
                  u2 = l2.max;
                } else {
                  this.deferredYTDClick = g2;
                  return;
                }
              else
                "all" === l2 && k && (b.navigator && b.navigator.baseSeries[0] && (b.navigator.baseSeries[0].xAxis.options.range = void 0), q2 = n2, u2 = v);
              E && c._offsetMin && p(q2) && (q2 += c._offsetMin);
              c._offsetMax && p(u2) && (u2 += c._offsetMax);
              this.dropdown && (this.dropdown.selectedIndex = g2 + 1);
              k ? k.setExtremes(q2, u2, f(d, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: c }) : (y2 = r(b.options.xAxis)[0], C2 = y2.range, y2.range = h2, B2 = y2.min, y2.min = A2, t(b, "load", function() {
                y2.range = C2;
                y2.min = B2;
              }));
              e(this, "afterBtnClick");
            }
          }
          setSelected(a3) {
            this.selected = this.options.selected = a3;
          }
          init(a3) {
            const d = this, b = a3.options.rangeSelector, c = b.buttons || d.defaultButtons.slice(), f2 = b.selected, g2 = function() {
              const a4 = d.minInput, b2 = d.maxInput;
              a4 && a4.blur && e(a4, "blur");
              b2 && b2.blur && e(b2, "blur");
            };
            d.chart = a3;
            d.options = b;
            d.buttons = [];
            d.buttonOptions = c;
            this.eventsToUnbind = [];
            this.eventsToUnbind.push(t(a3.container, "mousedown", g2));
            this.eventsToUnbind.push(t(a3, "resize", g2));
            c.forEach(d.computeButtonRange);
            "undefined" !== typeof f2 && c[f2] && this.clickButton(f2, false);
            this.eventsToUnbind.push(t(a3, "load", function() {
              a3.xAxis && a3.xAxis[0] && t(a3.xAxis[0], "setExtremes", function(b2) {
                this.max - this.min !== a3.fixedRange && "rangeSelectorButton" !== b2.trigger && "updatedData" !== b2.trigger && d.forcedDataGrouping && !d.frozenStates && this.setDataGrouping(false, false);
              });
            }));
          }
          updateButtonStates() {
            const a3 = this;
            var d = this.chart;
            const b = this.dropdown, c = d.xAxis[0], e2 = Math.round(c.max - c.min), f2 = !c.hasVisibleSeries, g2 = d.scroller && d.scroller.getUnionExtremes() || c, h2 = g2.dataMin, l2 = g2.dataMax;
            d = a3.getYTDExtremes(l2, h2, d.time.useUTC);
            const m2 = d.min, n2 = d.max, p2 = a3.selected, r2 = a3.options.allButtonsEnabled, q2 = a3.buttons;
            let t2 = x(p2);
            a3.buttonOptions.forEach((d2, g3) => {
              var k = d2._range, w = d2.type, v = d2.count || 1;
              const z = q2[g3], u2 = d2._offsetMax - d2._offsetMin, x2 = g3 === p2, F = k > l2 - h2, y2 = k < c.minRange;
              d2 = 0;
              let A2 = false, H = false;
              k = k === e2;
              ("month" === w || "year" === w) && e2 + 36e5 >= 864e5 * { month: 28, year: 365 }[w] * v - u2 && e2 - 36e5 <= 864e5 * { month: 31, year: 366 }[w] * v + u2 ? k = true : "ytd" === w ? (k = n2 - m2 + u2 === e2, A2 = !x2) : "all" === w && (k = c.max - c.min >= l2 - h2, H = !x2 && t2 && k);
              w = !r2 && (F || y2 || H || f2);
              v = x2 && k || k && !t2 && !A2 || x2 && a3.frozenStates;
              w ? d2 = 3 : v && (t2 = true, d2 = 2);
              z.state !== d2 && (z.setState(d2), b && (b.options[g3 + 1].disabled = w, 2 === d2 && (b.selectedIndex = g3 + 1)), 0 === d2 && p2 === g3 && a3.setSelected());
            });
          }
          computeButtonRange(a3) {
            const d = a3.type, b = a3.count || 1, c = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
            if (c[d])
              a3._range = c[d] * b;
            else if ("month" === d || "year" === d)
              a3._range = 864e5 * { month: 30, year: 365 }[d] * b;
            a3._offsetMin = f(a3.offsetMin, 0);
            a3._offsetMax = f(a3.offsetMax, 0);
            a3._range += a3._offsetMax - a3._offsetMin;
          }
          getInputValue(a3) {
            a3 = "min" === a3 ? this.minInput : this.maxInput;
            const d = this.chart.options.rangeSelector, b = this.chart.time;
            return a3 ? ("text" === a3.type && d.inputDateParser || this.defaultInputDateParser)(a3.value, b.useUTC, b) : 0;
          }
          setInputValue(a3, d) {
            const b = this.options, c = this.chart.time, e2 = "min" === a3 ? this.minInput : this.maxInput;
            a3 = "min" === a3 ? this.minDateBox : this.maxDateBox;
            if (e2) {
              var f2 = e2.getAttribute("data-hc-time");
              f2 = p(f2) ? Number(f2) : void 0;
              p(d) && (p(f2) && e2.setAttribute("data-hc-time-previous", f2), e2.setAttribute("data-hc-time", d), f2 = d);
              e2.value = c.dateFormat(this.inputTypeFormats[e2.type] || b.inputEditDateFormat, f2);
              a3 && a3.attr({ text: c.dateFormat(
                b.inputDateFormat,
                f2
              ) });
            }
          }
          setInputExtremes(a3, d, b) {
            if (a3 = "min" === a3 ? this.minInput : this.maxInput) {
              const c = this.inputTypeFormats[a3.type], e2 = this.chart.time;
              c && (d = e2.dateFormat(c, d), a3.min !== d && (a3.min = d), b = e2.dateFormat(c, b), a3.max !== b && (a3.max = b));
            }
          }
          showInput(a3) {
            const d = "min" === a3 ? this.minDateBox : this.maxDateBox;
            if ((a3 = "min" === a3 ? this.minInput : this.maxInput) && d && this.inputGroup) {
              const b = "text" === a3.type, { translateX: c, translateY: e2 } = this.inputGroup, { inputBoxWidth: f2 } = this.options;
              m(a3, { width: b ? d.width + (f2 ? -2 : 20) + "px" : "auto", height: d.height - 2 + "px", border: "2px solid silver" });
              b && f2 ? m(a3, { left: c + d.x + "px", top: e2 + "px" }) : m(a3, { left: Math.min(Math.round(d.x + c - (a3.offsetWidth - d.width) / 2), this.chart.chartWidth - a3.offsetWidth) + "px", top: e2 - (a3.offsetHeight - d.height) / 2 + "px" });
            }
          }
          hideInput(a3) {
            (a3 = "min" === a3 ? this.minInput : this.maxInput) && m(a3, { top: "-9999em", border: 0, width: "1px", height: "1px" });
          }
          defaultInputDateParser(a3, d, b) {
            var c = a3.split("/").join("-").split(" ").join("T");
            -1 === c.indexOf("T") && (c += "T00:00");
            if (d)
              c += "Z";
            else {
              var e2;
              if (e2 = J.isSafari)
                e2 = c, e2 = !(6 < e2.length && (e2.lastIndexOf("-") === e2.length - 6 || e2.lastIndexOf("+") === e2.length - 6));
              e2 && (e2 = new Date(c).getTimezoneOffset() / 60, c += 0 >= e2 ? `+${C(-e2)}:00` : `-${C(e2)}:00`);
            }
            c = Date.parse(c);
            x(c) || (a3 = a3.split("-"), c = Date.UTC(y(a3[0]), y(a3[1]) - 1, y(a3[2])));
            b && d && x(c) && (c += b.getTimezoneOffset(c));
            return c;
          }
          drawInput(a3) {
            function d() {
              const { maxInput: c2, minInput: d2 } = f2, e3 = b.xAxis[0];
              var g2 = b.scroller && b.scroller.xAxis ? b.scroller.xAxis : e3;
              const k = g2.dataMin;
              g2 = g2.dataMax;
              let h3 = f2.getInputValue(a3);
              h3 !== Number(t2.getAttribute("data-hc-time-previous")) && x(h3) && (t2.setAttribute("data-hc-time-previous", h3), p2 && c2 && x(k) ? h3 > Number(c2.getAttribute("data-hc-time")) ? h3 = void 0 : h3 < k && (h3 = k) : d2 && x(g2) && (h3 < Number(d2.getAttribute("data-hc-time")) ? h3 = void 0 : h3 > g2 && (h3 = g2)), "undefined" !== typeof h3 && e3.setExtremes(p2 ? h3 : e3.min, p2 ? e3.max : h3, void 0, void 0, { trigger: "rangeSelectorInput" }));
            }
            const { chart: b, div: c, inputGroup: e2 } = this, f2 = this, h2 = b.renderer.style || {};
            var l2 = b.renderer;
            const n2 = b.options.rangeSelector, p2 = "min" === a3;
            var r2 = B.lang[p2 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
            r2 = l2.label(r2, 0).addClass("highcharts-range-label").attr({ padding: r2 ? 2 : 0, height: r2 ? n2.inputBoxHeight : 0 }).add(e2);
            l2 = l2.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: n2.inputBoxWidth, height: n2.inputBoxHeight, "text-align": "center" }).on("click", function() {
              f2.showInput(a3);
              f2[a3 + "Input"].focus();
            });
            b.styledMode || l2.attr({ stroke: n2.inputBoxBorderColor, "stroke-width": 1 });
            l2.add(e2);
            const t2 = q("input", { name: a3, className: "highcharts-range-selector" }, void 0, c);
            t2.setAttribute("type", u(n2.inputDateFormat || "%e %b %Y"));
            b.styledMode || (r2.css(I(h2, n2.labelStyle)), l2.css(I(
              { color: "#333333" },
              h2,
              n2.inputStyle
            )), m(t2, g({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: h2.fontSize, fontFamily: h2.fontFamily, top: "-9999em" }, n2.inputStyle)));
            t2.onfocus = () => {
              f2.showInput(a3);
            };
            t2.onblur = () => {
              t2 === J.doc.activeElement && d();
              f2.hideInput(a3);
              f2.setInputValue(a3);
              t2.blur();
            };
            let v = false;
            t2.onchange = () => {
              v || (d(), f2.hideInput(a3), t2.blur());
            };
            t2.onkeypress = (a4) => {
              13 === a4.keyCode && d();
            };
            t2.onkeydown = (a4) => {
              v = true;
              38 !== a4.keyCode && 40 !== a4.keyCode || d();
            };
            t2.onkeyup = () => {
              v = false;
            };
            return { dateBox: l2, input: t2, label: r2 };
          }
          getPosition() {
            var a3 = this.chart;
            const d = a3.options.rangeSelector;
            a3 = "top" === d.verticalAlign ? a3.plotTop - a3.axisOffset[0] : 0;
            return { buttonTop: a3 + d.buttonPosition.y, inputTop: a3 + d.inputPosition.y - 10 };
          }
          getYTDExtremes(a3, d, b) {
            const c = this.chart.time;
            var e2 = new c.Date(a3);
            const f2 = c.get("FullYear", e2);
            b = b ? c.Date.UTC(f2, 0, 1) : +new c.Date(f2, 0, 1);
            d = Math.max(d, b);
            e2 = e2.getTime();
            return { max: Math.min(a3 || e2, e2), min: d };
          }
          render(a3, d) {
            var b = this.chart, c = b.renderer;
            const e2 = b.container;
            var g2 = b.options;
            const h2 = g2.rangeSelector, l2 = f(g2.chart.style && g2.chart.style.zIndex, 0) + 1;
            g2 = h2.inputEnabled;
            if (false !== h2.enabled) {
              this.rendered || (this.group = c.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = q("div", void 0, { position: "relative", height: 0, zIndex: l2 }), this.buttonOptions.length && this.renderButtons(), e2.parentNode && e2.parentNode.insertBefore(this.div, e2), g2 && (this.inputGroup = c.g("input-group").add(this.group), c = this.drawInput("min"), this.minDateBox = c.dateBox, this.minLabel = c.label, this.minInput = c.input, c = this.drawInput("max"), this.maxDateBox = c.dateBox, this.maxLabel = c.label, this.maxInput = c.input));
              if (g2 && (this.setInputValue("min", a3), this.setInputValue("max", d), a3 = b.scroller && b.scroller.getUnionExtremes() || b.xAxis[0] || {}, p(a3.dataMin) && p(a3.dataMax) && (b = b.xAxis[0].minRange || 0, this.setInputExtremes("min", a3.dataMin, Math.min(a3.dataMax, this.getInputValue("max")) - b), this.setInputExtremes("max", Math.max(a3.dataMin, this.getInputValue("min")) + b, a3.dataMax)), this.inputGroup)) {
                let a4 = 0;
                [
                  this.minLabel,
                  this.minDateBox,
                  this.maxLabel,
                  this.maxDateBox
                ].forEach((b2) => {
                  if (b2) {
                    const { width: c2 } = b2.getBBox();
                    c2 && (b2.attr({ x: a4 }), a4 += c2 + h2.inputSpacing);
                  }
                });
              }
              this.alignElements();
              this.rendered = true;
            }
          }
          renderButtons() {
            const { buttons: a3, chart: d, options: b } = this, c = B.lang, g2 = d.renderer, h2 = I(b.buttonTheme), l2 = h2 && h2.states, m2 = h2.width || 28;
            delete h2.width;
            delete h2.states;
            this.buttonGroup = g2.g("range-selector-buttons").add(this.group);
            const n2 = this.dropdown = q("select", void 0, {
              position: "absolute",
              width: "1px",
              height: "1px",
              padding: 0,
              border: 0,
              top: "-9999em",
              cursor: "pointer",
              opacity: 1e-4
            }, this.div);
            t(n2, "touchstart", () => {
              n2.style.fontSize = "16px";
            });
            [[J.isMS ? "mouseover" : "mouseenter"], [J.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(([b2, c2]) => {
              t(n2, b2, () => {
                const d2 = a3[this.currentButtonIndex()];
                d2 && e(d2.element, c2 || b2);
              });
            });
            this.zoomText = g2.label(c && c.rangeSelectorZoom || "", 0).attr({ padding: b.buttonTheme.padding, height: b.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup);
            this.chart.styledMode || (this.zoomText.css(b.labelStyle), h2["stroke-width"] = f(
              h2["stroke-width"],
              0
            ));
            q("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, n2);
            this.buttonOptions.forEach((b2, c2) => {
              q("option", { textContent: b2.title || b2.text }, void 0, n2);
              a3[c2] = g2.button(b2.text, 0, 0, (a4) => {
                const d2 = b2.events && b2.events.click;
                let e2;
                d2 && (e2 = d2.call(b2, a4));
                false !== e2 && this.clickButton(c2);
                this.isActive = true;
              }, h2, l2 && l2.hover, l2 && l2.select, l2 && l2.disabled).attr({ "text-align": "center", width: m2 }).add(this.buttonGroup);
              b2.title && a3[c2].attr("title", b2.title);
            });
          }
          alignElements() {
            const {
              buttonGroup: a3,
              buttons: d,
              chart: b,
              group: c,
              inputGroup: e2,
              options: g2,
              zoomText: h2
            } = this;
            var l2 = b.options;
            const m2 = l2.exporting && false !== l2.exporting.enabled && l2.navigation && l2.navigation.buttonOptions, { buttonPosition: n2, inputPosition: p2, verticalAlign: r2 } = g2;
            l2 = (a4, c2) => m2 && this.titleCollision(b) && "top" === r2 && "right" === c2.align && c2.y - a4.getBBox().height - 12 < (m2.y || 0) + (m2.height || 0) + b.spacing[0] ? -40 : 0;
            var t2 = b.plotLeft;
            if (c && n2 && p2) {
              var q2 = n2.x - b.spacing[3];
              if (a3) {
                this.positionButtons();
                if (!this.initialButtonGroupWidth) {
                  let a4 = 0;
                  h2 && (a4 += h2.getBBox().width + 5);
                  d.forEach((b2, c2) => {
                    a4 += b2.width;
                    c2 !== d.length - 1 && (a4 += g2.buttonSpacing);
                  });
                  this.initialButtonGroupWidth = a4;
                }
                t2 -= b.spacing[3];
                this.updateButtonStates();
                var u2 = l2(a3, n2);
                this.alignButtonGroup(u2);
                c.placed = a3.placed = b.hasLoaded;
              }
              u2 = 0;
              e2 && (u2 = l2(e2, p2), "left" === p2.align ? q2 = t2 : "right" === p2.align && (q2 = -Math.max(b.axisOffset[1], -u2)), e2.align({ y: p2.y, width: e2.getBBox().width, align: p2.align, x: p2.x + q2 - 2 }, true, b.spacingBox), e2.placed = b.hasLoaded);
              this.handleCollision(u2);
              c.align({ verticalAlign: r2 }, true, b.spacingBox);
              l2 = c.alignAttr.translateY;
              t2 = c.getBBox().height + 20;
              q2 = 0;
              "bottom" === r2 && (q2 = (q2 = b.legend && b.legend.options) && "bottom" === q2.verticalAlign && q2.enabled && !q2.floating ? b.legend.legendHeight + f(q2.margin, 10) : 0, t2 = t2 + q2 - 20, q2 = l2 - t2 - (g2.floating ? 0 : g2.y) - (b.titleOffset ? b.titleOffset[2] : 0) - 10);
              if ("top" === r2)
                g2.floating && (q2 = 0), b.titleOffset && b.titleOffset[0] && (q2 = b.titleOffset[0]), q2 += b.margin[0] - b.spacing[0] || 0;
              else if ("middle" === r2) {
                if (p2.y === n2.y)
                  q2 = l2;
                else if (p2.y || n2.y)
                  q2 = 0 > p2.y || 0 > n2.y ? q2 - Math.min(p2.y, n2.y) : l2 - t2;
              }
              c.translate(g2.x, g2.y + Math.floor(q2));
              const { minInput: k, maxInput: m3, dropdown: w } = this;
              g2.inputEnabled && k && m3 && (k.style.marginTop = c.translateY + "px", m3.style.marginTop = c.translateY + "px");
              w && (w.style.marginTop = c.translateY + "px");
            }
          }
          alignButtonGroup(a3, d) {
            const { chart: b, options: c, buttonGroup: e2 } = this, { buttonPosition: g2 } = c, h2 = b.plotLeft - b.spacing[3];
            let l2 = g2.x - b.spacing[3];
            "right" === g2.align ? l2 += a3 - h2 : "center" === g2.align && (l2 -= h2 / 2);
            e2 && e2.align({ y: g2.y, width: f(d, this.initialButtonGroupWidth), align: g2.align, x: l2 }, true, b.spacingBox);
          }
          positionButtons() {
            const { buttons: a3, chart: d, options: b, zoomText: c } = this, e2 = d.hasLoaded ? "animate" : "attr", { buttonPosition: g2 } = b, h2 = d.plotLeft;
            let l2 = h2;
            c && "hidden" !== c.visibility && (c[e2]({ x: f(h2 + g2.x, h2) }), l2 += g2.x + c.getBBox().width + 5);
            for (let c2 = 0, d2 = this.buttonOptions.length; c2 < d2; ++c2)
              if ("hidden" !== a3[c2].visibility)
                a3[c2][e2]({ x: l2 }), l2 += a3[c2].width + b.buttonSpacing;
              else
                a3[c2][e2]({ x: h2 });
          }
          handleCollision(a3) {
            const { chart: d, buttonGroup: b, inputGroup: c } = this, { buttonPosition: e2, dropdown: f2, inputPosition: g2 } = this.options, h2 = () => {
              let a4 = 0;
              this.buttons.forEach((b2) => {
                b2 = b2.getBBox();
                b2.width > a4 && (a4 = b2.width);
              });
              return a4;
            }, l2 = (d2) => {
              if (c && b) {
                const f3 = c.alignAttr.translateX + c.alignOptions.x - a3 + c.getBBox().x + 2, h3 = c.alignOptions.width, k = b.alignAttr.translateX + b.getBBox().x;
                return k + d2 > f3 && f3 + h3 > k && e2.y < g2.y + c.getBBox().height;
              }
              return false;
            }, m2 = () => {
              c && b && c.attr({ translateX: c.alignAttr.translateX + (d.axisOffset[1] >= -a3 ? 0 : -a3), translateY: c.alignAttr.translateY + b.getBBox().height + 10 });
            };
            if (b) {
              if ("always" === f2) {
                this.collapseButtons(a3);
                l2(h2()) && m2();
                return;
              }
              "never" === f2 && this.expandButtons();
            }
            c && b ? g2.align === e2.align || l2(this.initialButtonGroupWidth + 20) ? "responsive" === f2 ? (this.collapseButtons(a3), l2(h2()) && m2()) : m2() : "responsive" === f2 && this.expandButtons() : b && "responsive" === f2 && (this.initialButtonGroupWidth > d.plotWidth ? this.collapseButtons(a3) : this.expandButtons());
          }
          collapseButtons(a3) {
            const { buttons: d, buttonOptions: b, chart: c, dropdown: e2, options: g2, zoomText: h2 } = this, l2 = c.userOptions.rangeSelector && c.userOptions.rangeSelector.buttonTheme || {}, m2 = (a4) => ({ text: a4 ? `${a4} ‚ñæ` : "‚ñæ", width: "auto", paddingLeft: f(g2.buttonTheme.paddingLeft, l2.padding, 8), paddingRight: f(g2.buttonTheme.paddingRight, l2.padding, 8) });
            h2 && h2.hide();
            let n2 = false;
            b.forEach((a4, b2) => {
              b2 = d[b2];
              2 !== b2.state ? b2.hide() : (b2.show(), b2.attr(m2(a4.text)), n2 = true);
            });
            n2 || (e2 && (e2.selectedIndex = 0), d[0].show(), d[0].attr(m2(this.zoomText && this.zoomText.textStr)));
            const { align: p2 } = g2.buttonPosition;
            this.positionButtons();
            "right" !== p2 && "center" !== p2 || this.alignButtonGroup(a3, d[this.currentButtonIndex()].getBBox().width);
            this.showDropdown();
          }
          expandButtons() {
            const { buttons: a3, buttonOptions: d, options: b, zoomText: c } = this;
            this.hideDropdown();
            c && c.show();
            d.forEach((c2, d2) => {
              d2 = a3[d2];
              d2.show();
              d2.attr({ text: c2.text, width: b.buttonTheme.width || 28, paddingLeft: f(b.buttonTheme.paddingLeft, "unset"), paddingRight: f(b.buttonTheme.paddingRight, "unset") });
              2 > d2.state && d2.setState(0);
            });
            this.positionButtons();
          }
          currentButtonIndex() {
            const { dropdown: a3 } = this;
            return a3 && 0 < a3.selectedIndex ? a3.selectedIndex - 1 : 0;
          }
          showDropdown() {
            const { buttonGroup: a3, buttons: d, chart: b, dropdown: c } = this;
            if (a3 && c) {
              const { translateX: e2, translateY: f2 } = a3, g2 = d[this.currentButtonIndex()].getBBox();
              m(c, { left: b.plotLeft + e2 + "px", top: f2 + 0.5 + "px", width: g2.width + "px", height: g2.height + "px" });
              this.hasVisibleDropdown = true;
            }
          }
          hideDropdown() {
            const { dropdown: a3 } = this;
            a3 && (m(a3, { top: "-9999em", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
          }
          getHeight() {
            var a3 = this.options, d = this.group;
            const b = a3.y, c = a3.buttonPosition.y, e2 = a3.inputPosition.y;
            if (a3.height)
              return a3.height;
            this.alignElements();
            a3 = d ? d.getBBox(true).height + 13 + b : 0;
            d = Math.min(e2, c);
            if (0 > e2 && 0 > c || 0 < e2 && 0 < c)
              a3 += Math.abs(d);
            return a3;
          }
          titleCollision(a3) {
            return !(a3.options.title.text || a3.options.subtitle.text);
          }
          update(a3) {
            const d = this.chart;
            I(true, d.options.rangeSelector, a3);
            this.destroy();
            this.init(d);
            this.render();
          }
          destroy() {
            const a3 = this, d = a3.minInput, b = a3.maxInput;
            a3.eventsToUnbind && (a3.eventsToUnbind.forEach((a4) => a4()), a3.eventsToUnbind = void 0);
            n(a3.buttons);
            d && (d.onfocus = d.onblur = d.onchange = null);
            b && (b.onfocus = b.onblur = b.onchange = null);
            M(a3, function(b2, d2) {
              b2 && "chart" !== d2 && (b2 instanceof G ? b2.destroy() : b2 instanceof S.HTMLElement && h(b2));
              b2 !== l.prototype[d2] && (a3[d2] = null);
            }, this);
          }
        }
        g(l.prototype, { defaultButtons: [{
          type: "month",
          count: 1,
          text: "1m",
          title: "View 1 month"
        }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } });
        "";
        return l;
      });
      L(
        a,
        "Core/Axis/OrdinalAxis.js",
        [a["Core/Axis/Axis.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]],
        function(a2, A, J, K) {
          const { addEvent: u, correctFloat: D, css: E, defined: B, error: t, pick: q, timeUnits: m } = K, p = [];
          var n;
          (function(a3) {
            function g(a4, c, d2, e2, f2 = [], g2 = 0, h2) {
              const b = {}, k = this.options.tickPixelInterval;
              var l2 = this.chart.time, n3 = [], p2;
              let r2;
              let q2;
              var w = 0;
              let u2 = [], v2 = -Number.MAX_VALUE;
              if (!this.options.ordinal && !this.options.breaks || !f2 || 3 > f2.length || "undefined" === typeof c)
                return l2.getTimeTicks.apply(l2, arguments);
              const z = f2.length;
              for (p2 = 0; p2 < z; p2++) {
                q2 = p2 && f2[p2 - 1] > d2;
                f2[p2] < c && (w = p2);
                if (p2 === z - 1 || f2[p2 + 1] - f2[p2] > 5 * g2 || q2) {
                  if (f2[p2] > v2) {
                    for (r2 = l2.getTimeTicks(a4, f2[w], f2[p2], e2); r2.length && r2[0] <= v2; )
                      r2.shift();
                    r2.length && (v2 = r2[r2.length - 1]);
                    n3.push(u2.length);
                    u2 = u2.concat(r2);
                  }
                  w = p2 + 1;
                }
                if (q2)
                  break;
              }
              if (r2) {
                f2 = r2.info;
                if (h2 && f2.unitRange <= m.hour) {
                  p2 = u2.length - 1;
                  for (w = 1; w < p2; w++)
                    if (l2.dateFormat("%d", u2[w]) !== l2.dateFormat("%d", u2[w - 1])) {
                      b[u2[w]] = "day";
                      var x = true;
                    }
                  x && (b[u2[0]] = "day");
                  f2.higherRanks = b;
                }
                f2.segmentStarts = n3;
                u2.info = f2;
              } else
                t(12, false, this.chart);
              if (h2 && B(k)) {
                w = u2.length;
                l2 = [];
                x = [];
                let a5;
                for (p2 = w; p2--; )
                  n3 = this.translate(u2[p2]), a5 && (x[p2] = a5 - n3), l2[p2] = a5 = n3;
                x.sort();
                x = x[Math.floor(x.length / 2)];
                x < 0.6 * k && (x = null);
                p2 = u2[w - 1] > d2 ? w - 1 : w;
                for (a5 = void 0; p2--; )
                  n3 = l2[p2], w = Math.abs(a5 - n3), a5 && w < 0.8 * k && (null === x || w < 0.8 * x) ? (b[u2[p2]] && !b[u2[p2 + 1]] ? (w = p2 + 1, a5 = n3) : w = p2, u2.splice(w, 1)) : a5 = n3;
              }
              return u2;
            }
            function e(a4) {
              const b = this.ordinal.positions;
              if (!b)
                return a4;
              let d2 = b.length - 1, e2;
              0 > a4 ? a4 = b[0] : a4 > d2 ? a4 = b[d2] : (d2 = Math.floor(a4), e2 = a4 - d2);
              return "undefined" !== typeof e2 && "undefined" !== typeof b[d2] ? b[d2] + (e2 ? e2 * (b[d2 + 1] - b[d2]) : 0) : a4;
            }
            function h(a4) {
              var b = this.ordinal, d2 = b.positions;
              if (!d2)
                return a4;
              var e2 = D((a4 - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding);
              a4 >= d2[0] && a4 <= d2[d2.length - 1] || (b.extendedOrdinalPositions || (b.extendedOrdinalPositions = b.getExtendedPositions()), d2 = b.extendedOrdinalPositions);
              if (d2 && d2.length) {
                a4 = d2.indexOf(a4);
                b = -1 !== a4 ? a4 : D(b.getIndexOfPoint(e2, d2));
                e2 = D(b % 1);
                if (0 <= b && b <= d2.length - 1)
                  return d2[Math.floor(b)] + e2 * (d2[Math.ceil(b)] - d2[Math.floor(b)]);
                e2 = d2.length;
                a4 = d2[0];
                d2 = d2[e2 - 1];
                const c = (d2 - a4) / (e2 - 1);
                return 0 > b ? a4 + c * b : d2 + c * (b - e2);
              }
              return a4;
            }
            function n2(b, c) {
              const d2 = a3.Additions.findIndexOf(b, c, true);
              return b[d2] === c ? d2 : d2 + (c - b[d2]) / (b[d2 + 1] - b[d2]);
            }
            function G() {
              this.ordinal || (this.ordinal = new a3.Additions(this));
            }
            function C() {
              this.isXAxis && B(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && B(this.userMin) && (this.min += this.options.overscroll));
            }
            function f() {
              this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
            }
            function y() {
              this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
            }
            function r(a4) {
              const b = this.xAxis[0], d2 = b.options.overscroll, e2 = a4.originalEvent.chartX, f2 = this.options.chart.panning;
              let g2 = false;
              if (f2 && "y" !== f2.type && b.options.ordinal && b.series.length) {
                var h2 = this.mouseDownX;
                const a5 = b.getExtremes(), c = a5.dataMax, f3 = a5.min, k = a5.max;
                var l2 = this.hoverPoints, n3 = b.closestPointRange || b.ordinal && b.ordinal.overscrollPointsRange;
                h2 = Math.round((h2 - e2) / (b.translationSlope * (b.ordinal.slope || n3)));
                n3 = b.ordinal.getExtendedPositions();
                var m2 = { ordinal: { positions: n3, extendedOrdinalPositions: n3 } };
                n3 = b.index2val;
                const p2 = b.val2lin;
                let r2;
                m2.ordinal.positions ? 1 < Math.abs(h2) && (l2 && l2.forEach(function(a6) {
                  a6.setState();
                }), 0 > h2 ? (l2 = m2, r2 = b.ordinal.positions ? b : m2) : (l2 = b.ordinal.positions ? b : m2, r2 = m2), m2 = r2.ordinal.positions, c > m2[m2.length - 1] && m2.push(c), this.fixedRange = k - f3, h2 = b.navigatorAxis.toFixedRange(void 0, void 0, n3.apply(l2, [p2.apply(l2, [f3, true]) + h2]), n3.apply(r2, [p2.apply(r2, [k, true]) + h2])), h2.min >= Math.min(a5.dataMin, f3) && h2.max <= Math.max(c, k) + d2 && b.setExtremes(h2.min, h2.max, true, false, { trigger: "pan" }), this.mouseDownX = e2, E(this.container, { cursor: "move" })) : g2 = true;
              } else
                g2 = true;
              g2 || f2 && /y/.test(f2.type) ? d2 && (b.max = b.dataMax + d2) : a4.preventDefault();
            }
            function l() {
              const a4 = this.xAxis;
              a4 && a4.options.ordinal && (delete a4.ordinal.index, delete a4.ordinal.extendedOrdinalPositions);
            }
            function v(a4, c) {
              const b = this.ordinal;
              var d2 = b.positions;
              let e2 = b.slope, f2 = b.extendedOrdinalPositions;
              if (!d2)
                return a4;
              var g2 = d2.length;
              if (d2[0] <= a4 && d2[g2 - 1] >= a4)
                a4 = n2(d2, a4);
              else {
                f2 || (f2 = b.getExtendedPositions && b.getExtendedPositions(), b.extendedOrdinalPositions = f2);
                if (!f2 || !f2.length)
                  return a4;
                g2 = f2.length;
                e2 || (e2 = (f2[g2 - 1] - f2[0]) / g2);
                d2 = n2(f2, d2[0]);
                a4 = a4 >= f2[0] && a4 <= f2[g2 - 1] ? n2(f2, a4) - d2 : a4 < f2[0] ? -d2 - (f2[0] - a4) / e2 : (a4 - f2[g2 - 1]) / e2 + g2 - d2;
              }
              return c ? a4 : e2 * (a4 || 0) + b.offset;
            }
            a3.compose = function(a4, c, d2) {
              if (K.pushUnique(p, a4)) {
                const b = a4.prototype;
                b.getTimeTicks = g;
                b.index2val = e;
                b.lin2val = h;
                b.val2lin = v;
                b.ordinal2lin = b.val2lin;
                u(a4, "afterInit", G);
                u(a4, "foundExtremes", C);
                u(a4, "afterSetScale", f);
                u(
                  a4,
                  "initialAxisTranslation",
                  y
                );
              }
              K.pushUnique(p, d2) && u(d2, "pan", r);
              K.pushUnique(p, c) && u(c, "updatedData", l);
              return a4;
            };
            class d {
              constructor(a4) {
                this.index = {};
                this.axis = a4;
              }
              beforeSetTickPositions() {
                const a4 = this.axis, c = a4.ordinal;
                var d2 = a4.getExtremes();
                const e2 = d2.min;
                var f2 = d2.max;
                const g2 = a4.isXAxis && !!a4.options.breaks;
                d2 = a4.options.ordinal;
                const h2 = a4.chart.options.chart.ignoreHiddenSeries;
                let l2, n3;
                var m2;
                let p2 = [], r2 = Number.MAX_VALUE, t2 = false, u2 = false, v2 = false;
                if (d2 || g2) {
                  let b = 0;
                  a4.series.forEach(function(a5, c2) {
                    n3 = [];
                    0 < c2 && "highcharts-navigator-series" !== a5.options.id && 1 < a5.processedXData.length && (u2 = b !== a5.processedXData[1] - a5.processedXData[0]);
                    b = a5.processedXData[1] - a5.processedXData[0];
                    a5.boosted && (v2 = a5.boosted);
                    if (!(h2 && false === a5.visible || false === a5.takeOrdinalPosition && !g2) && (p2 = p2.concat(a5.processedXData), l2 = p2.length, p2.sort(function(a6, b2) {
                      return a6 - b2;
                    }), r2 = Math.min(r2, q(a5.closestPointRange, r2)), l2)) {
                      for (c2 = 0; c2 < l2 - 1; )
                        p2[c2] !== p2[c2 + 1] && n3.push(p2[c2 + 1]), c2++;
                      n3[0] !== p2[0] && n3.unshift(p2[0]);
                      p2 = n3;
                    }
                  });
                  u2 && v2 && (p2.pop(), p2.shift());
                  l2 = p2.length;
                  if (2 < l2) {
                    var x = p2[1] - p2[0];
                    for (m2 = l2 - 1; m2-- && !t2; )
                      p2[m2 + 1] - p2[m2] !== x && (t2 = true);
                    !a4.options.keepOrdinalPadding && (p2[0] - e2 > x || f2 - p2[p2.length - 1] > x) && (t2 = true);
                  } else
                    a4.options.overscroll && (2 === l2 ? r2 = p2[1] - p2[0] : 1 === l2 ? (r2 = a4.options.overscroll, p2 = [p2[0], p2[0] + r2]) : r2 = c.overscrollPointsRange);
                  t2 || a4.forceOrdinal ? (a4.options.overscroll && (c.overscrollPointsRange = r2, p2 = p2.concat(c.getOverscrollPositions())), c.positions = p2, x = a4.ordinal2lin(Math.max(e2, p2[0]), true), m2 = Math.max(a4.ordinal2lin(Math.min(f2, p2[p2.length - 1]), true), 1), c.slope = f2 = (f2 - e2) / (m2 - x), c.offset = e2 - x * f2) : (c.overscrollPointsRange = q(a4.closestPointRange, c.overscrollPointsRange), c.positions = a4.ordinal.slope = c.offset = void 0);
                }
                a4.isOrdinal = d2 && t2;
                c.groupIntervalFactor = null;
              }
              static findIndexOf(a4, c, d2) {
                let b = 0, e2 = a4.length - 1, f2;
                for (; b < e2; )
                  f2 = Math.ceil((b + e2) / 2), a4[f2] <= c ? b = f2 : e2 = f2 - 1;
                return a4[b] === c ? b : d2 ? b : -1;
              }
              getExtendedPositions() {
                const a4 = this, c = a4.axis, d2 = c.constructor.prototype, e2 = c.chart, f2 = c.series[0].currentDataGrouping, g2 = f2 ? f2.count + f2.unitName : "raw", h2 = c.options.overscroll, l2 = c.getExtremes();
                let n3, m2 = void 0, p2 = a4.index;
                p2 || (p2 = a4.index = {});
                p2[g2] || (n3 = { series: [], chart: e2, forceOrdinal: false, getExtremes: function() {
                  return {
                    min: l2.dataMin,
                    max: l2.dataMax + h2
                  };
                }, getGroupPixelWidth: d2.getGroupPixelWidth, getTimeTicks: d2.getTimeTicks, options: { ordinal: true }, ordinal: { getGroupIntervalFactor: this.getGroupIntervalFactor }, ordinal2lin: d2.ordinal2lin, getIndexOfPoint: d2.getIndexOfPoint, val2lin: d2.val2lin }, n3.ordinal.axis = n3, c.series.forEach(function(b) {
                  m2 = { xAxis: n3, xData: b.xData.slice(), chart: e2, destroyGroupedData: A.noop, getProcessedData: J.prototype.getProcessedData, applyGrouping: J.prototype.applyGrouping };
                  m2.xData = m2.xData.concat(a4.getOverscrollPositions());
                  m2.options = { dataGrouping: f2 ? { firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", enabled: true, forced: true, approximation: "open", units: [[f2.unitName, [f2.count]]] } : { enabled: false } };
                  n3.series.push(m2);
                  b.processData.apply(m2);
                }), m2.closestPointRange !== m2.basePointRange && m2.currentDataGrouping && (n3.forceOrdinal = true), c.ordinal.beforeSetTickPositions.apply({ axis: n3 }), p2[g2] = n3.ordinal.positions);
                return p2[g2];
              }
              getGroupIntervalFactor(a4, c, d2) {
                d2 = d2.processedXData;
                const b = d2.length;
                var e2 = [];
                var f2 = this.groupIntervalFactor;
                if (!f2) {
                  for (f2 = 0; f2 < b - 1; f2++)
                    e2[f2] = d2[f2 + 1] - d2[f2];
                  e2.sort(function(a5, b2) {
                    return a5 - b2;
                  });
                  e2 = e2[Math.floor(b / 2)];
                  a4 = Math.max(a4, d2[0]);
                  c = Math.min(c, d2[b - 1]);
                  this.groupIntervalFactor = f2 = b * e2 / (c - a4);
                }
                return f2;
              }
              getIndexOfPoint(a4, c) {
                const b = this.axis, e2 = this.positions ? this.positions[0] : 0, f2 = function(a5) {
                  return a5.points.some((a6) => !!a6.isInside);
                };
                let g2;
                b.series.forEach((a5) => {
                  var b2;
                  const c2 = null === (b2 = a5.points) || void 0 === b2 ? void 0 : b2[0];
                  B(null === c2 || void 0 === c2 ? void 0 : c2.plotX) && (c2.plotX < g2 || !B(g2)) && f2(a5) && (g2 = c2.plotX);
                });
                null !== g2 && void 0 !== g2 ? g2 : g2 = b.minPixelPadding;
                a4 = D((a4 - g2) / (b.translationSlope * (this.slope || b.closestPointRange || this.overscrollPointsRange)));
                return d.findIndexOf(c, e2, true) + a4;
              }
              getOverscrollPositions() {
                const a4 = this.axis, c = a4.options.overscroll, d2 = this.overscrollPointsRange, e2 = [];
                let f2 = a4.dataMax;
                if (B(d2))
                  for (; f2 <= a4.dataMax + c; )
                    f2 += d2, e2.push(f2);
                return e2;
              }
              postProcessTickInterval(a4) {
                const b = this.axis, d2 = this.slope;
                return d2 ? b.options.breaks ? b.closestPointRange || a4 : a4 / (d2 / b.closestPointRange) : a4;
              }
            }
            a3.Additions = d;
          })(n || (n = {}));
          return n;
        }
      );
      L(
        a,
        "Series/HLC/HLCPoint.js",
        [a["Core/Series/SeriesRegistry.js"]],
        function(a2) {
          ({ column: { prototype: { pointClass: a2 } } } = a2.seriesTypes);
          class u extends a2 {
            constructor() {
              super(...arguments);
              this.series = this.plotClose = this.options = this.low = this.high = this.close = void 0;
            }
          }
          return u;
        }
      );
      L(a, "Series/HLC/HLCSeriesDefaults.js", [], function() {
        "";
        return { lineWidth: 1, tooltip: { pointFormat: '<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' }, threshold: null, states: { hover: { lineWidth: 3 } }, stickyTracking: true };
      });
      L(a, "Series/HLC/HLCSeries.js", [a["Series/HLC/HLCPoint.js"], a["Series/HLC/HLCSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J, K) {
        const { column: u } = J.seriesTypes, { extend: D, merge: E } = K;
        class B extends u {
          constructor() {
            super(...arguments);
            this.yData = this.points = this.options = this.data = void 0;
          }
          extendStem(a3, q, m) {
            const p = a3[0];
            a3 = a3[1];
            "number" === typeof p[2] && (p[2] = Math.max(m + q, p[2]));
            "number" === typeof a3[2] && (a3[2] = Math.min(m - q, a3[2]));
          }
          getPointPath(a3, q) {
            q = q.strokeWidth();
            const m = a3.series, p = q % 2 / 2, n = Math.round(a3.plotX) - p, h = Math.round(a3.shapeArgs.width / 2), g = [["M", n, Math.round(a3.yBottom)], ["L", n, Math.round(a3.plotHigh)]];
            null !== a3.close && (a3 = Math.round(a3.plotClose) + p, g.push(["M", n, a3], ["L", n + h, a3]), m.extendStem(g, q / 2, a3));
            return g;
          }
          drawSinglePoint(a3) {
            var q = a3.series;
            const m = q.chart;
            let p = a3.graphic;
            "undefined" !== typeof a3.plotY && (p || (a3.graphic = p = m.renderer.path().add(q.group)), m.styledMode || p.attr(q.pointAttribs(a3, a3.selected && "select")), q = q.getPointPath(a3, p), p[p ? "animate" : "attr"]({ d: q }).addClass(
              a3.getClassName(),
              true
            ));
          }
          drawPoints() {
            this.points.forEach(this.drawSinglePoint);
          }
          init() {
            super.init.apply(this, arguments);
            this.options.stacking = void 0;
          }
          pointAttribs(a3, q) {
            a3 = super.pointAttribs.call(this, a3, q);
            delete a3.fill;
            return a3;
          }
          toYData(a3) {
            return [a3.high, a3.low, a3.close];
          }
          translate() {
            const a3 = this, q = a3.yAxis, m = this.pointArrayMap && this.pointArrayMap.slice() || [], p = m.map((a4) => `plot${a4.charAt(0).toUpperCase() + a4.slice(1)}`);
            p.push("yBottom");
            m.push("low");
            super.translate.apply(a3);
            a3.points.forEach(function(n) {
              m.forEach(function(h, g) {
                h = n[h];
                null !== h && (a3.dataModify && (h = a3.dataModify.modifyValue(h)), n[p[g]] = q.toPixels(h, true));
              });
              n.tooltipPos[1] = n.plotHigh + q.pos - a3.chart.plotTop;
            });
          }
        }
        B.defaultOptions = E(u.defaultOptions, A);
        D(B.prototype, { pointClass: a2, animate: null, directTouch: false, pointArrayMap: ["high", "low", "close"], pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, pointValKey: "close" });
        J.registerSeriesType("hlc", B);
        return B;
      });
      L(a, "Series/OHLC/OHLCPoint.js", [a["Core/Series/SeriesRegistry.js"]], function(a2) {
        ({ seriesTypes: { hlc: a2 } } = a2);
        class u extends a2.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.plotOpen = this.options = this.open = void 0;
          }
          getClassName() {
            return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
          }
          resolveUpColor() {
            this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
          }
          resolveColor() {
            super.resolveColor();
            this.resolveUpColor();
          }
          getZone() {
            const a3 = super.getZone();
            this.resolveUpColor();
            return a3;
          }
          applyOptions() {
            super.applyOptions.apply(
              this,
              arguments
            );
            this.resolveColor && this.resolveColor();
            return this;
          }
        }
        return u;
      });
      L(a, "Series/OHLC/OHLCSeriesDefaults.js", [], function() {
        "";
        return { tooltip: { pointFormat: '<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' } };
      });
      L(a, "Series/OHLC/OHLCSeries.js", [a["Series/OHLC/OHLCPoint.js"], a["Series/OHLC/OHLCSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A, J, K) {
        function u(a3) {
          a3 = a3.options;
          const h = a3.dataGrouping;
          h && a3.useOhlcData && "highcharts-navigator-series" !== a3.id && (h.approximation = "ohlc");
        }
        function D(a3) {
          a3 = a3.options;
          a3.useOhlcData && "highcharts-navigator-series" !== a3.id && t(this, { pointValKey: p.prototype.pointValKey, pointArrayMap: p.prototype.pointArrayMap, toYData: p.prototype.toYData });
        }
        const { seriesTypes: { hlc: E } } = J, { addEvent: B, extend: t, merge: q } = K, m = [];
        class p extends E {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          static compose(a3, ...h) {
            K.pushUnique(m, a3) && (B(a3, "afterSetOptions", u), B(a3, "init", D));
          }
          getPointPath(a3, h) {
            const g = super.getPointPath(a3, h);
            h = h.strokeWidth();
            const e = h % 2 / 2, m2 = Math.round(a3.plotX) - e, n = Math.round(a3.shapeArgs.width / 2);
            null !== a3.open && (a3 = Math.round(a3.plotOpen) + e, g.push(["M", m2, a3], ["L", m2 - n, a3]), super.extendStem(g, h / 2, a3));
            return g;
          }
          pointAttribs(a3, h) {
            h = super.pointAttribs.call(this, a3, h);
            const g = this.options;
            delete h.fill;
            !a3.options.color && g.upColor && a3.open < a3.close && (h.stroke = g.upColor);
            return h;
          }
          toYData(a3) {
            return [
              a3.open,
              a3.high,
              a3.low,
              a3.close
            ];
          }
        }
        p.defaultOptions = q(E.defaultOptions, A);
        t(p.prototype, { pointClass: a2, pointArrayMap: ["open", "high", "low", "close"] });
        J.registerSeriesType("ohlc", p);
        return p;
      });
      L(a, "Series/Candlestick/CandlestickSeriesDefaults.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, A) {
        "";
        return { states: { hover: { lineWidth: 2 } }, threshold: null, lineColor: "#000000", lineWidth: 1, upColor: "#ffffff", stickyTracking: true };
      });
      L(a, "Series/Candlestick/CandlestickSeries.js", [
        a["Series/Candlestick/CandlestickSeriesDefaults.js"],
        a["Core/Defaults.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K) {
        ({ defaultOptions: A } = A);
        const { column: u, ohlc: D } = J.seriesTypes;
        ({ merge: K } = K);
        class E extends D {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          pointAttribs(a3, t) {
            const q = u.prototype.pointAttribs.call(this, a3, t), m = this.options, p = a3.open < a3.close, n = m.lineColor || this.color, h = a3.color || this.color;
            q["stroke-width"] = m.lineWidth;
            q.fill = a3.options.color || (p ? m.upColor || h : h);
            q.stroke = a3.options.lineColor || (p ? m.upLineColor || n : n);
            t && (a3 = m.states[t], q.fill = a3.color || q.fill, q.stroke = a3.lineColor || q.stroke, q["stroke-width"] = a3.lineWidth || q["stroke-width"]);
            return q;
          }
          drawPoints() {
            var a3 = this.points;
            const t = this.chart, q = this.yAxis.reversed;
            for (const h of a3) {
              a3 = h.graphic;
              var m = void 0, p = void 0;
              let g, e;
              var n = void 0;
              let u2, A2;
              const B = !a3;
              "undefined" !== typeof h.plotY && (a3 || (h.graphic = a3 = t.renderer.path().add(this.group)), this.chart.styledMode || a3.attr(this.pointAttribs(h, h.selected && "select")).shadow(this.options.shadow), n = a3.strokeWidth() % 2 / 2, u2 = Math.round(h.plotX) - n, m = h.plotOpen, p = h.plotClose, g = Math.min(m, p), m = Math.max(m, p), A2 = Math.round(h.shapeArgs.width / 2), p = q ? m !== h.yBottom : Math.round(g) !== Math.round(h.plotHigh), e = q ? Math.round(g) !== Math.round(h.plotHigh) : m !== h.yBottom, g = Math.round(g) + n, m = Math.round(m) + n, n = [], n.push(["M", u2 - A2, m], ["L", u2 - A2, g], ["L", u2 + A2, g], ["L", u2 + A2, m], ["Z"], ["M", u2, g], ["L", u2, p ? Math.round(q ? h.yBottom : h.plotHigh) : g], ["M", u2, m], ["L", u2, e ? Math.round(q ? h.plotHigh : h.yBottom) : m]), a3[B ? "attr" : "animate"]({ d: n }).addClass(
                h.getClassName(),
                true
              ));
            }
          }
        }
        E.defaultOptions = K(D.defaultOptions, A.plotOptions, { tooltip: D.defaultOptions.tooltip }, a2);
        J.registerSeriesType("candlestick", E);
        return E;
      });
      L(a, "Series/Flags/FlagsPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, A) {
        ({ column: { prototype: { pointClass: a2 } } } = a2.seriesTypes);
        const { isNumber: u } = A;
        class K extends a2 {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
            this.ttBelow = false;
          }
          isValid() {
            return u(this.y) || "undefined" === typeof this.y;
          }
          hasNewShapeType() {
            const a3 = this.options.shape || this.series.options.shape;
            return this.graphic && a3 && a3 !== this.graphic.symbolKey;
          }
        }
        return K;
      });
      L(a, "Series/Flags/FlagsSeriesDefaults.js", [], function() {
        "";
        return { pointRange: 0, allowOverlapX: false, shape: "flag", stackDistance: 12, textAlign: "center", tooltip: { pointFormat: "{point.text}" }, threshold: null, y: -30, fillColor: "#ffffff", lineWidth: 1, states: { hover: { lineColor: "#000000", fillColor: "#ccd3ff" } }, style: { fontSize: "0.7em", fontWeight: "bold" } };
      });
      L(
        a,
        "Series/Flags/FlagsSymbols.js",
        [a["Core/Renderer/RendererRegistry.js"]],
        function(a2) {
          var u;
          (function(u2) {
            function A(a3, u3, t, q, m) {
              const p = m && m.anchorX || a3;
              m = m && m.anchorY || u3;
              const n = this.circle(p - 1, m - 1, 2, 2);
              n.push(["M", p, m], ["L", a3, u3 + q], ["L", a3, u3], ["L", a3 + t, u3], ["L", a3 + t, u3 + q], ["L", a3, u3 + q], ["Z"]);
              return n;
            }
            function G(a3, u3) {
              a3[u3 + "pin"] = function(t, q, m, p, n) {
                const h = n && n.anchorX;
                n = n && n.anchorY;
                let g;
                "circle" === u3 && p > m && (t -= Math.round((p - m) / 2), m = p);
                g = a3[u3](t, q, m, p);
                if (h && n) {
                  let e = h;
                  "circle" === u3 ? e = t + m / 2 : (t = g[0], m = g[1], "M" === t[0] && "L" === m[0] && (e = (t[1] + m[1]) / 2));
                  g.push(["M", e, q > n ? q : q + p], [
                    "L",
                    h,
                    n
                  ]);
                  g = g.concat(a3.circle(h - 1, n - 1, 2, 2));
                }
                return g;
              };
            }
            const D = [];
            u2.compose = function(u3) {
              -1 === D.indexOf(u3) && (D.push(u3), u3 = u3.prototype.symbols, u3.flag = A, G(u3, "circle"), G(u3, "square"));
              u3 = a2.getRendererType();
              D.indexOf(u3) && D.push(u3);
            };
          })(u || (u = {}));
          return u;
        }
      );
      L(a, "Series/OnSeriesComposition.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, A, J) {
        const { prototype: u } = a2, { prototype: G } = A, { defined: D, stableSort: E } = J;
        var B;
        (function(a3) {
          function q(a4) {
            return G.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, a4);
          }
          function m() {
            u.translate.apply(this);
            const a4 = this;
            var h = a4.options, g = a4.chart;
            const e = a4.points;
            var m2 = h.onSeries;
            const p2 = (m2 = m2 && g.get(m2)) && m2.options.step, q2 = m2 && m2.points, t = g.inverted, f = a4.xAxis, y = a4.yAxis;
            g = e.length - 1;
            let r;
            h = h.onKey || "y";
            let l = q2 && q2.length, v = 0, d, b, c, k;
            if (m2 && m2.visible && l) {
              v = (m2.pointXOffset || 0) + (m2.barW || 0) / 2;
              var w = m2.currentDataGrouping;
              b = q2[l - 1].x + (w ? w.totalRange : 0);
              E(e, (a5, b2) => a5.x - b2.x);
              for (h = "plot" + h[0].toUpperCase() + h.substr(1); l-- && e[g] && !(d = q2[l], w = e[g], w.y = d.y, d.x <= w.x && "undefined" !== typeof d[h] && (w.x <= b && (w.plotY = d[h], d.x < w.x && !p2 && (c = q2[l + 1]) && "undefined" !== typeof c[h] && (k = (w.x - d.x) / (c.x - d.x), w.plotY += k * (c[h] - d[h]), w.y += k * (c.y - d.y))), g--, l++, 0 > g)); )
                ;
            }
            e.forEach((b2, c2) => {
              let d2;
              b2.plotX += v;
              if ("undefined" === typeof b2.plotY || t)
                0 <= b2.plotX && b2.plotX <= f.len ? t ? (b2.plotY = f.translate(b2.x, 0, 1, 0, 1), b2.plotX = D(b2.y) ? y.translate(b2.y, 0, 0, 0, 1) : 0) : b2.plotY = (f.opposite ? 0 : a4.yAxis.len) + f.offset : b2.shapeArgs = {};
              (r = e[c2 - 1]) && r.plotX === b2.plotX && ("undefined" === typeof r.stackIndex && (r.stackIndex = 0), d2 = r.stackIndex + 1);
              b2.stackIndex = d2;
            });
            this.onSeries = m2;
          }
          const p = [];
          a3.compose = function(a4) {
            if (J.pushUnique(p, a4)) {
              const h = a4.prototype;
              h.getPlotBox = q;
              h.translate = m;
            }
            return a4;
          };
          a3.getPlotBox = q;
          a3.translate = m;
        })(B || (B = {}));
        return B;
      });
      L(a, "Series/Flags/FlagsSeries.js", [
        a["Series/Flags/FlagsPoint.js"],
        a["Series/Flags/FlagsSeriesDefaults.js"],
        a["Series/Flags/FlagsSymbols.js"],
        a["Core/Globals.js"],
        a["Series/OnSeriesComposition.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Utilities.js"]
      ], function(a2, A, J, K, G, D, E, B, t) {
        ({ noop: K } = K);
        const { distribute: q } = D, { series: m, seriesTypes: { column: p } } = E, { addEvent: n, defined: h, extend: g, merge: e, objectEach: u, wrap: I } = t;
        class L2 extends p {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          animate(a3) {
            a3 && this.setClip();
          }
          drawPoints() {
            var a3 = this.points, f = this.chart;
            const g2 = f.renderer, m2 = f.inverted, l = this.options, n2 = l.y, d = this.yAxis, b = {}, c = [];
            let k, p2;
            let t2, x;
            let A2, E2, G2;
            for (t2 = a3.length; t2--; ) {
              x = a3[t2];
              E2 = (m2 ? x.plotY : x.plotX) > this.xAxis.len;
              k = x.plotX;
              var D2 = x.stackIndex;
              var J2 = x.options.shape || l.shape;
              p2 = x.plotY;
              "undefined" !== typeof p2 && (p2 = x.plotY + n2 - ("undefined" !== typeof D2 && D2 * l.stackDistance));
              x.anchorX = D2 ? void 0 : x.plotX;
              A2 = D2 ? void 0 : x.plotY;
              G2 = "flag" !== J2;
              D2 = x.graphic;
              "undefined" !== typeof p2 && 0 <= k && !E2 ? (D2 && x.hasNewShapeType() && (D2 = D2.destroy()), D2 || (D2 = x.graphic = g2.label("", null, null, J2, null, null, l.useHTML).addClass("highcharts-point").add(this.markerGroup), x.graphic.div && (x.graphic.div.point = x), D2.isNew = true), D2.attr({ align: G2 ? "center" : "left", width: l.width, height: l.height, "text-align": l.textAlign }), f.styledMode || D2.attr(this.pointAttribs(x)).css(e(l.style, x.style)).shadow(l.shadow), 0 < k && (k -= D2.strokeWidth() % 2), J2 = { y: p2, anchorY: A2 }, l.allowOverlapX && (J2.x = k, J2.anchorX = x.anchorX), D2.attr({ text: x.options.title || l.title || "A" })[D2.isNew ? "attr" : "animate"](J2), l.allowOverlapX || (b[x.plotX] ? b[x.plotX].size = Math.max(b[x.plotX].size, D2.width) : b[x.plotX] = { align: G2 ? 0.5 : 0, size: D2.width, target: k, anchorX: k }), x.tooltipPos = [k, p2 + d.pos - f.plotTop]) : D2 && (x.graphic = D2.destroy());
            }
            if (!l.allowOverlapX) {
              let e2 = 100;
              u(b, function(a4) {
                a4.plotX = a4.anchorX;
                c.push(a4);
                e2 = Math.max(a4.size, e2);
              });
              q(c, m2 ? d.len : this.xAxis.len, e2);
              for (const c2 of a3)
                f = c2.plotX, (f = (a3 = c2.graphic) && b[f]) && a3 && (h(f.pos) ? a3[a3.isNew ? "attr" : "animate"]({ x: f.pos + (f.align || 0) * f.size, anchorX: c2.anchorX }).show().isNew = false : a3.hide().isNew = true);
            }
            l.useHTML && this.markerGroup && I(this.markerGroup, "on", function(a4) {
              return B.prototype.on.apply(a4.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
            });
          }
          drawTracker() {
            const a3 = this.points;
            super.drawTracker();
            for (const e2 of a3) {
              const f = e2.graphic;
              f && (e2.unbindMouseOver && e2.unbindMouseOver(), e2.unbindMouseOver = n(f.element, "mouseover", function() {
                0 < e2.stackIndex && !e2.raised && (e2._y = f.y, f.attr({ y: e2._y - 8 }), e2.raised = true);
                for (const f2 of a3)
                  f2 !== e2 && f2.raised && f2.graphic && (f2.graphic.attr({ y: f2._y }), f2.raised = false);
              }));
            }
          }
          pointAttribs(a3, e2) {
            const f = this.options, g2 = a3 && a3.color || this.color;
            let h2 = f.lineColor, m2 = a3 && a3.lineWidth;
            a3 = a3 && a3.fillColor || f.fillColor;
            e2 && (a3 = f.states[e2].fillColor, h2 = f.states[e2].lineColor, m2 = f.states[e2].lineWidth);
            return { fill: a3 || g2, stroke: h2 || g2, "stroke-width": m2 || f.lineWidth || 0 };
          }
          setClip() {
            m.prototype.setClip.apply(this, arguments);
            false !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
          }
        }
        L2.compose = J.compose;
        L2.defaultOptions = e(p.defaultOptions, A);
        G.compose(L2);
        g(L2.prototype, {
          allowDG: false,
          forceCrop: true,
          invertible: false,
          noSharedTooltip: true,
          pointClass: a2,
          sorted: false,
          takeOrdinalPosition: false,
          trackerGroups: ["markerGroup"],
          buildKDTree: K,
          init: m.prototype.init
        });
        E.registerSeriesType("flags", L2);
        "";
        return L2;
      });
      L(a, "Core/Chart/StockChart.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Templating.js"], a["Core/Defaults.js"], a["Stock/Navigator/NavigatorDefaults.js"], a["Stock/RangeSelector/RangeSelectorDefaults.js"], a["Stock/Scrollbar/ScrollbarDefaults.js"], a["Core/Series/Series.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, A, J, K, G, D, E, B, t, q) {
        function m(a3, b) {
          return "xAxis" === a3 ? {
            minPadding: 0,
            maxPadding: 0,
            overscroll: 0,
            ordinal: true,
            title: { text: null },
            labels: { overflow: "justify" },
            showLastLabel: true
          } : "yAxis" === a3 ? { labels: { y: -2 }, opposite: r(b.opposite, true), showLastLabel: !(!b.categories && "category" !== b.type), title: { text: null } } : {};
        }
        function p(a3, b) {
          return "xAxis" === a3 ? (a3 = { type: "datetime", categories: void 0 }, r(b.navigator && b.navigator.enabled, G.enabled, true) && (a3.startOnTick = false, a3.endOnTick = false), a3) : {};
        }
        const { format: n } = J, { getOptions: h } = K, { addEvent: g, clamp: e, defined: u, extend: I, find: L2, isNumber: C, isString: f, merge: y, pick: r, splat: l } = q;
        class v extends A {
          init(a3, b) {
            const c = h(), d = a3.xAxis, e2 = a3.yAxis;
            var f2 = r(a3.navigator && a3.navigator.enabled, G.enabled, true);
            a3.xAxis = a3.yAxis = void 0;
            f2 = y({ chart: { panning: { enabled: true, type: "x" }, zooming: { pinchType: "x" } }, navigator: { enabled: f2 }, scrollbar: { enabled: r(E.enabled, true) }, rangeSelector: { enabled: r(D.rangeSelector.enabled, true) }, title: { text: null }, tooltip: { split: r(c.tooltip.split, true), crosshairs: true }, legend: { enabled: false } }, a3, { isStock: true });
            a3.xAxis = d;
            a3.yAxis = e2;
            f2.xAxis = l(a3.xAxis || {}).map(function(b2, d2) {
              return y(m(
                "xAxis",
                b2
              ), c.xAxis, c.xAxis && c.xAxis[d2], b2, p("xAxis", a3));
            });
            f2.yAxis = l(a3.yAxis || {}).map(function(a4, b2) {
              return y(m("yAxis", a4), c.yAxis, c.yAxis && c.yAxis[b2], a4);
            });
            super.init(f2, b);
          }
          createAxis(a3, b) {
            b.axis = y(m(a3, b.axis), b.axis, p(a3, this.userOptions));
            return super.createAxis(a3, b);
          }
        }
        (function(a3) {
          a3.stockChart = function(b, c, d) {
            return new a3(b, c, d);
          };
        })(v || (v = {}));
        g(B, "setOptions", function(a3) {
          let b;
          this.chart.options.isStock && (this.is("column") || this.is("columnrange") ? b = { borderWidth: 0, shadow: false } : this.is("scatter") || this.is("sma") || (b = { marker: { enabled: false, radius: 2 } }), b && (a3.plotOptions[this.type] = y(a3.plotOptions[this.type], b)));
        });
        g(a2, "autoLabelAlign", function(a3) {
          const { chart: b, options: c } = this, d = b._labelPanes = b._labelPanes || {}, e2 = c.labels;
          if (b.options.isStock && "yAxis" === this.coll) {
            const b2 = c.top + "," + c.height;
            !d[b2] && e2.enabled && (15 === e2.distance && 1 === this.side && (e2.distance = 0), "undefined" === typeof e2.align && (e2.align = "right"), d[b2] = this, a3.align = "right", a3.preventDefault());
          }
        });
        g(a2, "destroy", function() {
          const a3 = this.chart, b = this.options && this.options.top + "," + this.options.height;
          b && a3._labelPanes && a3._labelPanes[b] === this && delete a3._labelPanes[b];
        });
        g(a2, "getPlotLinePath", function(a3) {
          function b(a4) {
            const b2 = "xAxis" === a4 ? "yAxis" : "xAxis";
            a4 = c.options[b2];
            return C(a4) ? [g2[b2][a4]] : f(a4) ? [g2.get(a4)] : d.map(function(a5) {
              return a5[b2];
            });
          }
          let c = this, d = this.isLinked && !this.series ? this.linkedParent.series : this.series, g2 = c.chart, h2 = g2.renderer, l2 = c.left, m2 = c.top, n2, p2, q2, t2, v2 = [], x = [], y2, A2, B2 = a3.translatedValue, D2 = a3.value, E2 = a3.force, G2;
          if (g2.options.isStock && false !== a3.acrossPanes && "xAxis" === c.coll || "yAxis" === c.coll)
            a3.preventDefault(), x = b(c.coll), y2 = c.isXAxis ? g2.yAxis : g2.xAxis, y2.forEach(function(a4) {
              if (u(a4.options.id) ? -1 === a4.options.id.indexOf("navigator") : 1) {
                var b2 = a4.isXAxis ? "yAxis" : "xAxis";
                b2 = u(a4.options[b2]) ? g2[b2][a4.options[b2]] : g2[b2][0];
                c === b2 && x.push(a4);
              }
            }), A2 = x.length ? [] : [c.isXAxis ? g2.yAxis[0] : g2.xAxis[0]], x.forEach(function(a4) {
              -1 !== A2.indexOf(a4) || L2(A2, function(b2) {
                return b2.pos === a4.pos && b2.len === a4.len;
              }) || A2.push(a4);
            }), G2 = r(B2, c.translate(D2, void 0, void 0, a3.old)), C(G2) && (c.horiz ? A2.forEach(function(a4) {
              let b2;
              p2 = a4.pos;
              t2 = p2 + a4.len;
              n2 = q2 = Math.round(G2 + c.transB);
              "pass" !== E2 && (n2 < l2 || n2 > l2 + c.width) && (E2 ? n2 = q2 = e(n2, l2, l2 + c.width) : b2 = true);
              b2 || v2.push(["M", n2, p2], ["L", q2, t2]);
            }) : A2.forEach(function(a4) {
              let b2;
              n2 = a4.pos;
              q2 = n2 + a4.len;
              p2 = t2 = Math.round(m2 + c.height - G2);
              "pass" !== E2 && (p2 < m2 || p2 > m2 + c.height) && (E2 ? p2 = t2 = e(p2, m2, m2 + c.height) : b2 = true);
              b2 || v2.push(["M", n2, p2], ["L", q2, t2]);
            })), a3.path = 0 < v2.length ? h2.crispPolyLine(v2, a3.lineWidth || 1) : null;
        });
        t.prototype.crispPolyLine = function(a3, b) {
          for (let c = 0; c < a3.length; c += 2) {
            const d = a3[c], e2 = a3[c + 1];
            d[1] === e2[1] && (d[1] = e2[1] = Math.round(d[1]) - b % 2 / 2);
            d[2] === e2[2] && (d[2] = e2[2] = Math.round(d[2]) + b % 2 / 2);
          }
          return a3;
        };
        g(a2, "afterHideCrosshair", function() {
          this.crossLabel && (this.crossLabel = this.crossLabel.hide());
        });
        g(a2, "afterDrawCrosshair", function(a3) {
          var b, c;
          if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && C(this.min) && C(this.max)) {
            var d = this.chart, e2 = this.logarithmic, f2 = this.crosshair.label, g2 = this.horiz, h2 = this.opposite, l2 = this.left, m2 = this.top, p2 = this.width, q2 = this.crossLabel, t2 = f2.format, u2 = "", v2 = "inside" === this.options.tickPosition, x = false !== this.crosshair.snap, y2 = 0, A2 = a3.e || this.cross && this.cross.e;
            a3 = a3.point;
            var B2 = this.min, D2 = this.max;
            e2 && (B2 = e2.lin2log(B2), D2 = e2.lin2log(D2));
            e2 = g2 ? "center" : h2 ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
            q2 || (q2 = this.crossLabel = d.renderer.label("", 0, void 0, f2.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (a3 && a3.series ? a3.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
              align: f2.align || e2,
              padding: r(f2.padding, 8),
              r: r(f2.borderRadius, 3),
              zIndex: 2
            }).add(this.labelGroup), d.styledMode || q2.attr({ fill: f2.backgroundColor || a3 && a3.series && a3.series.color || "#666666", stroke: f2.borderColor || "", "stroke-width": f2.borderWidth || 0 }).css(I({ color: "#ffffff", fontWeight: "normal", fontSize: "0.7em", textAlign: "center" }, f2.style || {})));
            g2 ? (p2 = x ? (a3.plotX || 0) + l2 : A2.chartX, m2 += h2 ? 0 : this.height) : (p2 = l2 + this.offset + (h2 ? p2 : 0), m2 = x ? (a3.plotY || 0) + m2 : A2.chartY);
            t2 || f2.formatter || (this.dateTime && (u2 = "%b %d, %Y"), t2 = "{value" + (u2 ? ":" + u2 : "") + "}");
            u2 = x ? this.isXAxis ? a3.x : a3.y : this.toValue(g2 ? A2.chartX : A2.chartY);
            x = a3 && a3.series ? a3.series.isPointInside(a3) : C(u2) && u2 > B2 && u2 < D2;
            A2 = "";
            t2 ? A2 = n(t2, { value: u2 }, d) : f2.formatter && C(u2) && (A2 = f2.formatter.call(this, u2));
            q2.attr({ text: A2, x: p2, y: m2, visibility: x ? "inherit" : "hidden" });
            f2 = q2.getBBox();
            !C(q2.x) || g2 || h2 || (p2 = q2.x - f2.width / 2);
            if (C(q2.y))
              if (g2) {
                if (v2 && !h2 || !v2 && h2)
                  m2 = q2.y - f2.height;
              } else
                m2 = q2.y - f2.height / 2;
            g2 ? (b = l2 - f2.x, c = l2 + this.width - f2.x) : (b = "left" === this.labelAlign ? l2 : 0, c = "right" === this.labelAlign ? l2 + this.width : d.chartWidth);
            q2.translateX < b && (y2 = b - q2.translateX);
            q2.translateX + f2.width >= c && (y2 = -(q2.translateX + f2.width - c));
            q2.attr({ x: p2 + y2, y: m2, anchorX: g2 ? p2 : this.opposite ? 0 : d.chartWidth, anchorY: g2 ? this.opposite ? d.chartHeight : 0 : m2 + f2.height / 2 });
          }
        });
        B.prototype.forceCropping = function() {
          const a3 = this.chart, b = this.options.dataGrouping;
          return false !== this.allowDG && b && r(b.enabled, a3.options.isStock);
        };
        g(A, "update", function(a3) {
          a3 = a3.options;
          "scrollbar" in a3 && this.navigator && (y(true, this.options.scrollbar, a3.scrollbar), this.navigator.update({}), delete a3.scrollbar);
        });
        return v;
      });
      L(a, "masters/modules/stock.src.js", [
        a["Core/Globals.js"],
        a["Series/DataModifyComposition.js"],
        a["Stock/Navigator/Navigator.js"],
        a["Stock/RangeSelector/RangeSelector.js"],
        a["Stock/Scrollbar/Scrollbar.js"],
        a["Core/Axis/OrdinalAxis.js"],
        a["Series/OHLC/OHLCSeries.js"],
        a["Series/Flags/FlagsSeries.js"],
        a["Core/Chart/StockChart.js"]
      ], function(a2, A, J, K, G, D, E, B, t) {
        a2.Navigator = J;
        a2.RangeSelector = K;
        a2.Scrollbar = G;
        a2.StockChart = a2.stockChart = t.stockChart;
        A.compose(a2.Series, a2.Axis, a2.Point);
        B.compose(a2.Renderer);
        J.compose(a2.Axis, a2.Chart, a2.Series);
        E.compose(a2.Series);
        D.compose(
          a2.Axis,
          a2.Series,
          a2.Chart
        );
        K.compose(a2.Axis, a2.Chart);
        G.compose(a2.Axis);
      });
      L(a, "masters/highstock.src.js", [a["masters/highcharts.src.js"]], function(a2) {
        a2.product = "Highstock";
        return a2;
      });
      a["masters/highstock.src.js"]._modules = a;
      return a["masters/highstock.src.js"];
    });
  }
});
export default require_highstock();
//# sourceMappingURL=highcharts_highstock.js.map
